<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试题</title>
      <link href="/2021/10/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/10/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>go 操作 kafka | 李文周的博客</p><p>李文周的 Blog Go 语言 kafka 分布式 消息队列 topic index 分片 去中心化</p><p>Kafka 是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展等特点。本文介绍了如何使用 Go 语言发送和接收 kafka 消息。</p><h2 id="sarama"><a href="#sarama" class="headerlink" title="sarama"></a>sarama</h2><p>Go 语言中连接 kafka 使用第三方库:<a href="https://github.com/Shopify/sarama" target="_blank" rel="noopener">github.com/Shopify/sarama</a>。</p><h3 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;Shopify&#x2F;sarama</span><br></pre></td></tr></table></figure></div><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>sarama</code> v1.20 之后的版本加入了<code>zstd</code>压缩算法，需要用到 cgo，在 Windows 平台编译时会提示类似如下错误：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># github.com&#x2F;DataDog&#x2F;zstd</span><br><span class="line">exec: &quot;gcc&quot;:executable file not found in %PATH%</span><br></pre></td></tr></table></figure></div><p>所以在 Windows 平台请使用 v1.19 版本的 sarama。</p><h2 id="连接-kafka-发送消息"><a href="#连接-kafka-发送消息" class="headerlink" title="连接 kafka 发送消息"></a>连接 kafka 发送消息</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com&#x2F;Shopify&#x2F;sarama&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 基于sarama第三方库开发的kafka client</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">config :&#x3D; sarama.NewConfig()</span><br><span class="line">config.Producer.RequiredAcks &#x3D; sarama.WaitForAll          &#x2F;&#x2F; 发送完数据需要leader和follow都确认</span><br><span class="line">config.Producer.Partitioner &#x3D; sarama.NewRandomPartitioner &#x2F;&#x2F; 新选出一个partition</span><br><span class="line">config.Producer.Return.Successes &#x3D; true                   &#x2F;&#x2F; 成功交付的消息将在success channel返回</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造一个消息</span><br><span class="line">msg :&#x3D; &amp;sarama.ProducerMessage&#123;&#125;</span><br><span class="line">msg.Topic &#x3D; &quot;web_log&quot;</span><br><span class="line">msg.Value &#x3D; sarama.StringEncoder(&quot;this is a test log&quot;)</span><br><span class="line">&#x2F;&#x2F; 连接kafka</span><br><span class="line">client, err :&#x3D; sarama.NewSyncProducer([]string&#123;&quot;192.168.1.7:9092&quot;&#125;, config)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;producer closed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer client.Close()</span><br><span class="line">&#x2F;&#x2F; 发送消息</span><br><span class="line">pid, offset, err :&#x3D; client.SendMessage(msg)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;send msg failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;pid:%v offset:%v\n&quot;, pid, offset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="连接-kafka-消费消息"><a href="#连接-kafka-消费消息" class="headerlink" title="连接 kafka 消费消息"></a>连接 kafka 消费消息</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com&#x2F;Shopify&#x2F;sarama&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; kafka consumer</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">consumer, err :&#x3D; sarama.NewConsumer([]string&#123;&quot;127.0.0.1:9092&quot;&#125;, nil)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;fail to start consumer, err:%v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">partitionList, err :&#x3D; consumer.Partitions(&quot;web_log&quot;) &#x2F;&#x2F; 根据topic取到所有的分区</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;fail to get list of partition:err%v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(partitionList)</span><br><span class="line">for partition :&#x3D; range partitionList &#123; &#x2F;&#x2F; 遍历所有的分区</span><br><span class="line">&#x2F;&#x2F; 针对每个分区创建一个对应的分区消费者</span><br><span class="line">pc, err :&#x3D; consumer.ConsumePartition(&quot;web_log&quot;, int32(partition), sarama.OffsetNewest)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;failed to start consumer for partition %d,err:%v\n&quot;, partition, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer pc.AsyncClose()</span><br><span class="line">&#x2F;&#x2F; 异步从每个分区消费信息</span><br><span class="line">go func(sarama.PartitionConsumer) &#123;</span><br><span class="line">for msg :&#x3D; range pc.Messages() &#123;</span><br><span class="line">fmt.Printf(&quot;Partition:%d Offset:%d Key:%v Value:%v&quot;, msg.Partition, msg.Offset, msg.Key, msg.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(pc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《后端从入门到熟悉-正式篇》</title>
      <link href="/2021/10/23/9.%E5%90%8E%E7%AB%AF%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/%E3%80%8A%E5%90%8E%E7%AB%AF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89-%E6%AD%A3%E5%BC%8F%E7%AF%87%E3%80%8B/"/>
      <url>/2021/10/23/9.%E5%90%8E%E7%AB%AF%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/%E3%80%8A%E5%90%8E%E7%AB%AF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89-%E6%AD%A3%E5%BC%8F%E7%AF%87%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>嗨喽，大家好呀！我是简凡，一位游走于各互联网大厂间的新时代农民工。从本篇开始，我开始按照企业对于后端开发者的需求层级，将成长阶段拆分为入门、初级、中级、高级、史诗级，逐步深入的为大家介绍后端的学习内容，下面开始正题。</p><h2 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h2><p>首先说前期准备，承接序言中的观点，为了让每一轮的知识学习更加扎实，也为了学习的结果、Demo沉淀下来，用于以后的复习、回溯，我们要开始做以下事情：</p><ul><li><p>选择自己的云笔记，个人建议用语雀，上一篇做过分析。然后参考简凡一样建立自己后端的体系框架，未来逐步往里面增添内容</p></li><li><p>准备好集成开发环境，建议直接用jetbrains，Java选用idea，Go选用Goland，<a href="https://www.jetbrains.com/" target="_blank" rel="noopener">https://www.jetbrains.com/</a></p></li><li><p>我会给大家提供的Excel学习路线，并整理成WBS的格式，放在我的微信公众号”简凡丶”中供大家下载，公众号回复“学习路线”即可获取。大家可以按照自己的情况完善计划，然后每天进行打卡，用于监督学习进度，激励自己不断完善自己的知识体系。后面我会定期对路线图进行完善，补充内容，大家可以通过关注我的公众号，第一时间获得更新通知。</p></li><li><p>学习思路：</p><ul><li>入门阶段建议用视频+文档的方式学习，视频可以帮助我们少走一些弯路，尽快建立认知。文档可以帮助形成完整的知识体系，并帮助我们快速整理笔记。高级阶段通过文档学习往往效率会更高，接收的知识也更加准确，且成体系。<ul><li>初级阶段要多敲代码，手敲代码时我们才会发现对一些知识点并未理解透彻，对所学的知识一定要做扎实。高级阶段要多读优秀的开源代码，从中学习借鉴好的代码设计，去粗取精，最终形成自己的代码风格。</li></ul></li></ul></li></ul><h2 id="二、入门阶段：掌握一门语言"><a href="#二、入门阶段：掌握一门语言" class="headerlink" title="二、入门阶段：掌握一门语言"></a>二、入门阶段：掌握一门语言</h2><h4 id="2-1-编程语言"><a href="#2-1-编程语言" class="headerlink" title="2.1 编程语言"></a>2.1 编程语言</h4><p>其实做软件开发有时候就和写一篇说明文一样，将一件业务需求描述清楚，程序就可以按照预想的运行起来了。所以我们先要掌握一门语言，用于和计算机打交道，告诉它我们要做些什么。</p><p>为了和操作系统打交道，我们先要学习Java、Golang、Python、C++等后端语言。这里简单说一下编程语言的选择，现在的中、小型公司多以Java为主，因为Java的生态更完善，说白了就是应用框架更丰富，开箱即用，各种业务需求场景都有比较成熟的解决方案，社区也比较活跃，甚至到了内卷的状态🐶。然后就是Golang，目前生态还不够完善，开源项目不够丰富，但解决大多数的需求还是没问题的。现在大厂都在拥抱云原生，而且大厂自己也有一定的自研能力，所以有些转向了Golang。另外，Golang语法相对Java较为简单，学习成本较低，并且天然支持并发编程。最后说下Python，现在比较常见的应用领域是机器学习、数据分析等，但作为后端语言在性能方面无优势，而且是弱类型语言，不利于建立自己的代码规范，不太建议新手将其作为主要的后端语言来用。</p><p>言归正传，下面分别列举了Java、Golang的语言入门内容：</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634560652542-1234e1ce-0735-413a-b4c0-bf9bbb75f53c.png" class="lazyload"></p><h4 id="2-2-数据库"><a href="#2-2-数据库" class="headerlink" title="2.2 数据库"></a>2.2 数据库</h4><p>有时我们需要将数据存储起来，就要用到数据库，为了与数据库打交道，我们需要学习：</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634560723990-c14255a8-f1ba-4aac-ae4b-1874a5975d59.png" class="lazyload"></p><h4 id="2-3-前端"><a href="#2-3-前端" class="headerlink" title="2.3 前端"></a>2.3 前端</h4><p>为了后续与前端页面打交道，我们需要开始掌握前端基础：</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634560967073-f499e7f8-f700-4fa2-97dd-8a1bf353ac0b.png" class="lazyload"></p><h4 id="2-4-研发工具"><a href="#2-4-研发工具" class="headerlink" title="2.4 研发工具"></a>2.4 研发工具</h4><p>为了更高效的开发程序，我们需要一个集成开发环境，这里为大家推荐idea全家桶，golang用goland：</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634560801680-28cb1e1c-dd39-4a10-bd1e-04ad7f14034f.png" class="lazyload"></p><p>至此，我们就算完成的常用语言的入门，但这还不足以让我们开发出一个Web项目，我们来继续看下一节。</p><h2 id="三、初级阶段：Web开发初窥"><a href="#三、初级阶段：Web开发初窥" class="headerlink" title="三、初级阶段：Web开发初窥"></a>三、初级阶段：Web开发初窥</h2><h4 id="3-1-网络、计算机系统基础"><a href="#3-1-网络、计算机系统基础" class="headerlink" title="3.1 网络、计算机系统基础"></a>3.1 网络、计算机系统基础</h4><p>既然要开发一个web应用，我们就首先需要掌握一些网络基础知识，以便于了解数据是如何在网络上进行传输的。企业级的项目基本都是部署在Linux服务器上的，所以我们要开始学习linux知识和shell命令。<a href="https://doc.code-nav.cn/roadmap/java" target="_blank" rel="noopener"></a><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634561389685-a919b1b1-da38-4907-a6e2-5b2c1313555a.png" class="lazyload"><a href="https://doc.code-nav.cn/roadmap/java" target="_blank" rel="noopener"></a>    </p><h4 id="3-2-Web入门"><a href="#3-2-Web入门" class="headerlink" title="3.2 Web入门"></a>3.2 Web入门</h4><p>我们选择的后端语言都有成熟的Web框架供我们使用，这样我们就可以很方便的与前端页面，与数据库打交道。对于Java我们要开始学习JavaWeb基础，学习Spring全家桶。对于Golang，现在比较主流的Web框架是beego或者是gin。此外，开发者们会把某些通用功能，开发成组件，通过SDK包的方式开源出来，所以我们要学习包管理工具，以便引用自己或他人的代码。Java中常用的是Maven和Gradle，Golang中官方提供了go module。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634562391132-72dd9139-5f11-49c2-9bf3-a98b58bea34e.png" class="lazyload"></p><h4 id="3-3-前端框架"><a href="#3-3-前端框架" class="headerlink" title="3.3 前端框架"></a>3.3 前端框架</h4><p>此时我们可以开始学习一些前端框架，来帮助我们更好，更快速开发前端页面。这里只写了JQuery，因为上手比较容易，当然你也可以学习下VUE，本篇我将其放到了中级阶段里了。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634562865609-10c2a402-0867-4eca-b27a-365c718ade12.png" class="lazyload"></p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634564795517-a603458e-f846-4de0-b3ea-f5ad5f4bcc34.png" class="lazyload"></p><p>至此，我们就可以开发一个小型单体Web应用了。中级阶段里我们会开始利用各种开源框架协助我们实现复杂的业务需求，然后学习如何接入微服务，将大型应用拆分为一个个单体服务，以便在企业级开发中更加快速的迭代需求。学习代码管理，并关注自己的代码规范。</p><h2 id="四、中级阶段：应对复杂多变的业务需求"><a href="#四、中级阶段：应对复杂多变的业务需求" class="headerlink" title="四、中级阶段：应对复杂多变的业务需求"></a>四、中级阶段：应对复杂多变的业务需求</h2><p>中级阶段我们的目标就是成为一个合格的CRUD Boy，那我们要做哪些事情呢？</p><h4 id="4-1-巩固基础"><a href="#4-1-巩固基础" class="headerlink" title="4.1 巩固基础"></a>4.1 巩固基础</h4><p>进入中级阶段，建议大家首先要做一遍基础的巩固，要将我们在入门和初级阶段沉淀的知识真正成为我们自己的。那该怎么做呢？很简单，通过阅读业界优秀书籍，官方文档，再次比对我们的笔记，并对其进行总结和完善。这时我们对前面知识的理解会更加深入，甚至上升一个层次。此时我们可以再学习一下Nginx、Netty网络框架，加深我们对网络通信的理解。Java的话还可以学习一下Java8。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634891238845-379a8e34-c323-45c2-ad9f-a3ad8f95d2ae.png" class="lazyload"></p><p>我们还需要学习一些并发编程的知识，来提升我们程序的运行效率。</p><ul><li>Java</li></ul><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634891407507-694d7ea5-8e80-4194-a3ac-4da95041da4a.png" class="lazyload"></p><ul><li>Golang</li></ul><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634891546918-ea64e7e0-3831-4aa5-96fd-8dbc49acd9b7.png" class="lazyload"></p><p>进一步学习一些编程语言是如何与计算机系统打交道的，以便于我们理解程序的运行机制，也为以后做性能调优打下基础</p><ul><li>Java</li></ul><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634891786044-e68c5d69-0a7e-400c-90fb-6173fbb0ed17.png" class="lazyload"></p><ul><li>Golang：GPM、pprof</li></ul><h4 id="4-2-提升代码质量"><a href="#4-2-提升代码质量" class="headerlink" title="4.2 提升代码质量"></a>4.2 提升代码质量</h4><p>为了避免流水账形式的代码，我们要开始学习设计模式和代码规范。让自己的代码变得优雅起来。学习下Mysql的底层知识和性能优化，让我们的sql也变得高效起来。另外，我们需要开始学习数据结构的知识，开始刷刷算法题了。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634649226591-b12aff8f-1b3b-491e-968c-f25fe4102b15.png" class="lazyload"></p><ul><li>Java</li></ul><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634891296718-5ca71b3d-cac6-483b-8587-6b5d4a3d594d.png" class="lazyload"></p><ul><li>Golang</li></ul><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634891893990-bf233198-7c2f-4f36-bb20-cb24e0505af5.png" class="lazyload"></p><ul><li>Mysql</li></ul><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634892226663-d8387f87-8954-4f37-aaed-05b6ac2b0274.png" class="lazyload"></p><ul><li>算法与数据结构</li></ul><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634911523124-46c97237-6fc4-4bd5-b7cc-862697dde45c.png" class="lazyload"></p><h4 id="4-3-学习应用框架"><a href="#4-3-学习应用框架" class="headerlink" title="4.3 学习应用框架"></a>4.3 学习应用框架</h4><p>为了解决大型应用开发中的种种需求，每种通用的业务场景都有写开源框架和中间件来支持我们方便快捷的解决需求。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634892090401-dda5a4ba-ec29-4192-8c09-8af8a02fe2c5.png" class="lazyload"></p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634892259615-28822cce-0350-4f96-8b62-2b4144b6057b.png" class="lazyload"></p><p>对于前端，我们也可以学习下vue、Node.js、npm，协助我们更好、更方便的开发前端项目</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634892358451-fb8b535d-6a9e-43f2-95ce-cae6522baa9d.png" class="lazyload"></p><h4 id="4-4-代码管理"><a href="#4-4-代码管理" class="headerlink" title="4.4 代码管理"></a>4.4 代码管理</h4><p>我们在这个阶段每天可能都会写很多的代码了，我们需要学习下代码管理工具，将我们的项目管理起来。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634892475409-688ccd89-5c74-435d-b2c1-d0ae6c074706.png" class="lazyload"></p><h4 id="4-5-分布式系统"><a href="#4-5-分布式系统" class="headerlink" title="4.5 分布式系统"></a>4.5 分布式系统</h4><p>真正的企业级大型项目往往都是分布式部署，所以我们要开始学习各种分布式场景解决方案对应框架的使用。另外，企业为了更快的迭代、更好的组织大型应用分分向微服务进行转型，把单体项目拆分成了一个个微服务。所以这里也变成的很多企业对于后端开发者的必备需求之一了。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634892746944-888f115b-42aa-4005-b2f5-062d004d0de1.png" class="lazyload"></p><p>学习完第四章节，恭喜你变成了一个合格的CRUD boy了。</p><h2 id="五、高级阶段：面向薪资编程"><a href="#五、高级阶段：面向薪资编程" class="headerlink" title="五、高级阶段：面向薪资编程"></a>五、高级阶段：面向薪资编程</h2><p>为了”薪资提升”，咳咳，不，是为了技术的进阶。我们需要了解我们应用的框架的设计原理，实现细节，常见问题，技术选型等等，开始向高级研发工程师进阶。另外，还需要多多阅读开源项目，了解其项目结构，实现细节等，俗话说“它山之石可以攻玉”。</p><h4 id="5-1-框架进阶"><a href="#5-1-框架进阶" class="headerlink" title="5.1 框架进阶"></a>5.1 框架进阶</h4><p>这个阶段我们要做的有：</p><ul><li>拓展知识的广度，学习掌握更多需求场景的解决方案，如分布式事务，数据库的读写分离、分库分表，如何解决接口的幂等性问题等。</li><li>拓展知识的深度，了解框架原理、实现细节、技术选型、常见的生产问题，帮助我们更好的使用框架来解决需求，也让我们的系统运行的更加稳定。企业中，尤其是在线业务系统，都非常重视系统稳定性，如果我们平时不注重相关底层知识的积累，对于中间件的应用浮于表面，很可能就搞出个BUG，并且出现问题时还无从着手。或是，我们想去做基础架构相关的开发，更加需要积累底层知识了。</li></ul><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634911306670-c76c4256-eec6-4d29-986c-2e1668ff7748.png" class="lazyload"></p><h4 id="5-2-项目实战"><a href="#5-2-项目实战" class="headerlink" title="5.2 项目实战"></a>5.2 项目实战</h4><p>这个阶段我们要开始积累实战经验，如果还在学习阶段，就多看看开源的框架源码。如果我们已经工作，那就要注重工作中的总结。行动中思考，就是始终保持好奇，不断从工作中发现问题，不断带着问题回到工作中去；不断思考，不断在工作中验证思考；不断从工作中总结抽象，不断对工作进行复盘，持续不断把工作内容和全领域的知识交叉验证，反复实践。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634910650780-30338969-3582-42fa-9316-ffe9c520c48c.png" class="lazyload"></p><h2 id="六、史诗级阶段：持续精进"><a href="#六、史诗级阶段：持续精进" class="headerlink" title="六、史诗级阶段：持续精进"></a>六、史诗级阶段：持续精进</h2><p>如果把前面5步都做到优秀，基本你已经可以对齐高级研发工程师了，如果你项目经验很好，还可能会更高。那我们还可以做些什么呢？</p><h4 id="6-1-持续精进"><a href="#6-1-持续精进" class="headerlink" title="6.1 持续精进"></a>6.1 持续精进</h4><p>这个阶段其实就是第5步的进一步递进，继续拓展知识的深度和广度，例如进行源码阅读，例如学一些机器学习、大数据相关的知识。但有我们要记住技术永远是服务于业务的，我们尽量不要脱离业务盲目去拓展广度，而是注重原有业务进行深度的钻研，甚至可以尝试依据于技术，创造出新的产品需求，来让产品变的更好，或是提升产研效率等。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634912035666-89bb3a1a-f13d-4862-91bf-728abd5cdb90.png" class="lazyload"></p><h4 id="6-2-系统设计"><a href="#6-2-系统设计" class="headerlink" title="6.2 系统设计"></a>6.2 系统设计</h4><p>作为技术人，我们给自己定的职业目标可能是一个技术专家，可能是一个架构师，也可能是技术和管理兼具的技术经理。但是无论如何，我们都需要一定的系统设计能力。此外，我们还需要开始积累行业背景知识，例如，如果设计一个电商系统，如何设计一个机器学习平台，如何设计一个供应链系统等等，当然要根据你的工作背景而定。</p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1634912201169-513eb1a8-69cf-4f6b-b4fb-fa9797fa152e.png" class="lazyload"></p><h4 id="6-3-由术到道"><a href="#6-3-由术到道" class="headerlink" title="6.3 由术到道"></a>6.3 由术到道</h4><p>我们部门在每一轮面试求职者的时候，除了看求职者的技术能力如何，还会观察他是否在工作中勤于思考、善于总结，甚至能否沉淀出方法论来；是否具有自己思维体系，有结构化思维能力；是否具有良好的沟通力、共情力、表达力等等。其实，这些往往是我们容易忽略的。如果我们未来想走的更远，这些往往是必要的，甚至是首要的。后面我也会写一些相关的文章，与大家共勉。</p><h2 id="七、写在最后"><a href="#七、写在最后" class="headerlink" title="七、写在最后"></a>七、写在最后</h2><p>写了这么多终于算是完结散花了，祝大家早日找到自己心仪的工作，我们下期见，Peace😘</p><p>我是简凡，一个励志用最简单的语言，描述最复杂问题的新时代农民工。<strong>求点赞，求关注</strong>，如果你对此篇文章有什么疑惑，欢迎在我的微信公众号中留言，我还可以为你提供以下帮助：</p><ul><li><p>帮助建立自己的知识体系</p></li><li><p>互联网真实高并发场景实战讲解</p></li><li><p>不定期分享Golang、Java相关业内的经典场景实践</p></li></ul><p>我的博客：<a href="https://besthpt.github.io/" target="_blank" rel="noopener">https://besthpt.github.io/</a></p><p>微信公众号：”简凡丶“</p>]]></content>
      
      
      <categories>
          
          <category> 后端分享心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端分享心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《后端从入门到熟悉-序言》</title>
      <link href="/2021/10/11/9.%E5%90%8E%E7%AB%AF%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/%E3%80%8A%E5%90%8E%E7%AB%AF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89-%E5%BA%8F%E8%A8%80%E3%80%8B/"/>
      <url>/2021/10/11/9.%E5%90%8E%E7%AB%AF%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/%E3%80%8A%E5%90%8E%E7%AB%AF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89-%E5%BA%8F%E8%A8%80%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、写在前面的话"><a href="#一、写在前面的话" class="headerlink" title="一、写在前面的话"></a>一、写在前面的话</h1><p>嗨喽，大家好呀！我是简凡，一位游走于各互联网大厂间的新时代农民工。<br>这是我初写博客的第一个系列，做为曾经编程小白我，也经历了长期的困惑迷惘，想学点什么做点什么，但又无从下手😂 。所以想在此分享下这一路走来的成长之路，希望能帮助到正在观看文章的你。为了让成长变得更加可以操作，所以我不想直接扔一篇什么后端成神之路的路线图xmind出来，而是通过成长的第一人称视角去一步步完成这个系列。<br>首先介绍先这个系列的标题，后端从入门到熟悉，为什么要用熟悉呢？因为程序员要学会的第一件事就是低调🐶 ，众所周知要是在简历里面写上精通某某，你会被面试官问的体无完肤，哈哈。那又是为什么用了后端，而没有写具体的语言呢？因为我曾经是Javaer，现在是一个Gopher，我期待从一个更通用的视角来看待后端开发的知识体系。言归正传，俗话说磨刀不误砍柴工，所以这篇序言我不会讲入门第一步该怎么做，而是打算从以下三方面来进行，因为掌握了这些才会让后面的路走的坚实、稳固，这也是你未来成长为技术大牛的真正核心：</p><ol><li>克服学习过程中的长期性迷惘，和间歇性懒惰</li><li>开始建立自己的知识体系</li><li>合理利用自己的时间<h1 id="二、如何成长为一位技术大牛"><a href="#二、如何成长为一位技术大牛" class="headerlink" title="二、如何成长为一位技术大牛"></a>二、如何成长为一位技术大牛</h1><h2 id="2-1-咬定青山不放松，立根原在破岩中"><a href="#2-1-咬定青山不放松，立根原在破岩中" class="headerlink" title="2.1 咬定青山不放松，立根原在破岩中"></a>2.1 咬定青山不放松，立根原在破岩中</h2>首先第一点，作为一个技术人我们可能会常常会处于一种知识焦虑的状态，比如你想要学习，想要进步，但不知道今天该做些什么，明天要做些什么，这个月要做些什么。又比如你明明似乎很想达成一件事，但常常还没起步就被别的事情吸引过去了，打了半天游戏，刷了半天抖音，一天就过去了。别担心，首先有所焦虑这是件好事，证明了你对未来有所期待，你所欠缺的就是一条能通向你未来的切实可行的道路和一种反馈激励机制，促使你乐此不疲的去达成你的愿望。那我们该如何做呢？这里我想提四个关键词：目标、计划、执行力、正反馈。<h3 id="2-1-1-目标"><a href="#2-1-1-目标" class="headerlink" title="2.1.1 目标"></a>2.1.1 目标</h3>首先说目标，举个例子，比如你的目标是，我想学会Java，我想学会Golang。其实这不算是目标，我认为目标中必须要包含一些关键要素，时间、地点、程度。<br>还是已学习Java为例，你可以给自己设置一个短期目标，我想在学校图书馆里7天内学习完Java基础，我想在1个月内学会JavaWeb基础，并且能跟着做一个小型项目，这样你会给自己锁定一个场景，你每天睁开眼就知道了，我今天要去图书馆，为了达成我要在7天内学习完Java语言基础的目标。这里还要注意的是长期目标是由一个个短期目标构建成的，我们如果定的目标太大就很难跟踪执行，我们可以学习互联网的管理理念来管理自己，”小步快走”，将一个大的目标进行逐级拆解，变为短周期的目标，一般目标时间不要超过一个月。有人可能觉得7天学会Java基础是不是有点激进呢？其实并不是，我们要相信自己的潜力，一个稍高一点的目标才能激发我们不断为达成目标的愿望，并且在目标达成收获更强烈的正反馈。然后来说什么是“程度”，这里讲的学习完Java基础，学习完JavaWeb，会做一个小型Web项目，都算是一种程度。这种程度会让我们的目标更加清晰，我们在执行时会知道，如果我坚持完成，就会有一个怎样的收获，那么做起来也能更有动力了。此外一个带有程度的清晰的目标，才能为我们的下一步“计划”，做一个很好的铺垫。<h3 id="2-1-2-计划-amp-正反馈"><a href="#2-1-2-计划-amp-正反馈" class="headerlink" title="2.1.2 计划&amp;正反馈"></a>2.1.2 计划&amp;正反馈</h3>为了达成我们的目标，我们需要详细的列一份计划，这里有几点要注意。<br>一是，计划一定要细致，拆分到切实可执行的操作单位，每个操作单位执行时间不要超过3天，比如你的计划项是学会Java基础，这个是不可操作的，因为Java基础还包含很多，最终你的这个计划项就会变得不可监控。而你把计划项列为学习Java中的变量和运算符，这样你就可以每天对你的计划项进行打卡了，你也能不断的收获到正反馈，感觉得到自己在不断打怪升级。<br>二是，计划要有时间和完成度的说明，这里我给大家推荐一个最简单的管理工具，用excel写一个WBS（想要获取wbs模板可以关注我的微信公众号“简凡丶”，后台回复wbs），这样我们就可以不断的跟踪我们的目标达成程度啦。</li></ol><p><img alt="image" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/image.png" class="lazyload"><br>三是，我们在一段时期还有其他想要达成的目标，比如想学习理财、学习一项乐器，这里建议主要不宜太多，个人建议不要超过3个。否则容易把自己的生活搞的混乱，最终哪个目标都没有达成。我们知道多线程的程序，如果CPU是单核的，往往还不如单线程顺序处理，因为程序上下文切换时会消耗无谓资源。我们要抓住主要矛盾，保持对主要目标的专注度，才能让时间更加高效。</p><h3 id="2-1-3-执行力"><a href="#2-1-3-执行力" class="headerlink" title="2.1.3 执行力"></a>2.1.3 执行力</h3><p>我很喜欢一句简单且实用的话，干就完了。当我们遇到困难，去查资料，去和人交流，总之干就完了。当我遇到懈怠，还在给自己的启动学习，创造理由，创造空间，干就完了。在程序员这个行业付出和收获成正比的，想要高薪，好的待遇就要不断付出，保持学习。如果选择躺尸，就是会在年龄较大的时候，面临淘汰。像管理一个项目一样，开始对自己的学习、工作，乃至人生进行一个规划和管理吧，你的人生一定会逐渐变的清晰、灿烂起来。</p><h3 id="2-1-4-总结"><a href="#2-1-4-总结" class="headerlink" title="2.1.4 总结"></a>2.1.4 总结</h3><p>讲到这里我们就可以按照目标-&gt;计划-&gt;执行-&gt;正反馈-&gt;下一阶段目标，这样循环递进的方式看到我们成长的进度条在直线向前了。</p><h2 id="2-2-学而不思则罔，思而不学则殆"><a href="#2-2-学而不思则罔，思而不学则殆" class="headerlink" title="2.2 学而不思则罔，思而不学则殆"></a>2.2 学而不思则罔，思而不学则殆</h2><p>我们在学习的过程常常会遇到学到后面，前面的知识就忘了，甚至想查也无从查起，只能再学一遍。这是因为我们没有记录，知识在脑子里都是一个个碎片，彼此之间没发生上下文联系。那我们该如何做呢？<br>一句话，开始记笔记，并逐步建立自己的知识体系，然后对自己的体系进行完善和定期重构。在《金字塔思维》一书中说，人在一小段时间，最多记住7件事，再多出来就会将前面的淡忘。那我们该如何让繁杂的知识在脑中记忆的更加牢固呢？答案就是对知识进行分层。例如，你要去菜市场买菜，要买葡萄、黄瓜、苹果、茄子，如果你只零散的记住几样物品，到菜市场你就有可能忘记了一两样。但你如果对他们进行分类，分为蔬菜和水果，蔬菜有黄瓜和茄子，水果有葡萄和苹果，这样的话，你就变得不容易忘记。再进一步，你如果有意识知道一共要买四件物品，蔬菜两件，水果两件，最终买完时，进行一个check，看看是否买了四件物品，这样你最终就一定不会漏买了。这就是典型的的结构化思维的实际应用。它可以帮助我们加深记忆，建立知识之间的联系，甚至激发我们的创造性思维。所以现在你已经认识到建立知识体系的重要性了吧。</p><h3 id="2-2-1-如何建立知识体系"><a href="#2-2-1-如何建立知识体系" class="headerlink" title="2.2.1 如何建立知识体系"></a>2.2.1 如何建立知识体系</h3><p>下面我们来说如何去建立自己的知识体系。我曾经学习和实际应用过多门开发语言，比如Java和Golang，Python等，我发现了在各语言之间，其实是有相同的学习的逻辑顺序的。<br>我们学习一门语言，首先肯定要学习语言基础，包含基础语法和语言特性等。然后就是为了实现一个后端业务需求我们要学习Web框架，来帮助我们方便快捷的和网络与数据库打交道，以便我们快速实现一个单体项目。例如，此时Java中要开始学习Spring、SpringMVC，然后学习在SpringMVC基础上进一步封装的SpringBoot，对于Golang我们可能会学习beego、学习Gin。再接下来就是对于一些复杂的大型系统需要为了业务的快速迭代和基础层的复用，需要把单体项目拆分为微服务。此时我们要开始学习微服务框架，例如，Java要学Dubbo、学SpringCloud，Golang中要学习gRpc、Micro等。当然有时我们还需要解决某种业务场景，就需要一些语言框架或者中间件，辅助我们高效解决应用需求。比如我们需要存储页面中的图片，会用到对象存储OSS；再比如我们需要一个中心缓存，来减轻数据库压力，加速我们的查询请求，我们会用到MemCache、Redis等，我们需要对业务流量进行异步、消峰我们需要用到消息队列。这些需求场景每种语言都会有相关的SDK来供我们操作使用这些中间件来解决问题。当然这里只是列举了后端体系的一小部分，后面几期我会按照技术层级的深度与广度逐步递进，逐步揭开后端体系的神秘面纱，并为大家整理出适合不同成长阶段的学习路线。<br>言归正传，你会从我上面的表述中发现建立知识体系的两个要素，第一，是对知识进行分层，在每个成长阶段，根据自己的情况，将所学知识深入到一定程度。例如，你是一个刚入门的小白，在第一轮学习时，就要去掌握JVM调优，掌握各种设计模式，这是不必要的，第一个阶段你应该现已独立开发一个项目为前提，去进行初级阶段的学习。当你可以较为熟练的写出一个应用了，再去学习设计模式，阅读开源代码学习人家的项目构建，才是正确的路线。”小步快走”，可以帮助一个企业或个人构建一条快速成长的高速轨道。第二，是不断摄取优秀的开源文章或项目，来完善你知识的体系，并定期对你的知识体系review。<br>此外，工欲善其事必先利其器，我们还需要一个好的笔记应用协助我们构建知识体系。这里是我当时选取笔记软件的需求(优先级递减)：</p><ol><li>支持全局关键词搜索，只有这样笔记本才能成为我们的第二个大脑，随时可以获取想要的资源</li><li>页面支持目录大纲，建立一篇文章中的知识层级</li><li>简洁、清晰、赏心悦目的编辑页面，并且支持Markdown</li><li>支持云同步，支持多端同步，这样可以防止数据丢失，还可以没事时随时拿来回顾下以前的知识</li><li>有客服，能聆听到用户意愿，并对产品进行更新（这里吐槽下oneNote,感觉微软做的产品真的不够用心）</li><li>可以做知识共享，作为博客对外输出</li></ol><p>综合以上几点，我在诸多笔记软件中选出了语雀，或者直接用typora写Markdown也是不错的，但由于自己写的Markdown图片需要找图床保存，还容易失效，我个人最终选择的语雀。这里只想说语雀yyds。这里有个小插曲，当时由于公司网络隔离原因语雀突然不能用了，联系了官方后端小哥，效率很高，当天就帮助了我解决了问题，这里给一个赞👍🏻</p><h2 id="2-3-光景不待人，须叟发成丝"><a href="#2-3-光景不待人，须叟发成丝" class="headerlink" title="2.3 光景不待人，须叟发成丝"></a>2.3 光景不待人，须叟发成丝</h2><p>上面说完了方法的问题，下面再说下心态问题吧，与君共勉。这里第一个要说的就是程序员的35岁问题，其实是实际存在的，原因我觉得大致是这样，这个行业目前比较火热，竞争激烈，所以会有源源不断的新人涌入进来，那企业方自然有了更多的选择，所以自然会觉得同等水平下，一位工作年限较短的人比另外一位更加有潜力，更加热爱学习。所以用更少的钱，招聘一位技术优秀，可塑性强，学习能力强、潜力深的青年人自然成了自然而然的事情。<br>那对于已经进入这个行业该如何自处呢？其实没别的办法，只能自己卷自己了😭，我们至少要让自己的工作年限至少能匹配上同等水平的要求，而且越早达到目标水平，那我们未来的溢价空间就越大，因为这体现着你未来的潜力，这也是企业选择技术人才的一个重要目标。<br>所以快速成长，成为了IT人的刚需，所以还在懒惰踟蹰不前的你，别犹豫了，就是干！<br>另外，这里还想说一点，就是避免假忙，聚焦成长。对于已经步入职场的同学经常会被繁杂的事情所干扰，似乎很忙的样子，但当你想要跳槽时却发现自己好像又什么都不会了，所以拼命的刷八股文。恰好最近部门在扩招，我也面试了很多类似的人，面试者是刷的八股文，还是有真正的实战经验一深问就看出来了。其实对于面试官来说刷八股文并不会引起多少反感，容易让面试官引起反感的是面试者表现出的对于工作和学习缺乏思考的意识，此时往往会被评价为缺少潜力。“潜力”这个词很神奇，就跟相亲时候的“感觉”一词似的，一旦被评价为没“潜力”，那拿到offer的希望也就渺茫了。所以，我们在工作中一定要勤于思考、善于总结、把一些通用的事情形成“方法论”，才能成为面试官和老板眼里一个有“潜力”的developer，才能让自己在繁杂的工作中收获成长。</p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p>啰啰嗦嗦的说了好多，希望能给渴望成长的你一些启迪。从下一篇开始，我们将正式进入《后端从入门到熟悉之路-入门篇》，一起探索如何从一个编程小白成长为一个初级开发工程师，我们下期见，Peace😘</p><blockquote><p>我是简凡，一个励志用最简单的语言，描述最复杂问题的新时代农民工。<strong>求点赞，求关注</strong>，我会为你提供以下帮助：</p><ul><li>帮助建立自己的知识体系</li><li>互联网真实高并发场景实战讲解</li><li>不定期分享Golang、Java相关业内的经典场景实践</li></ul></blockquote><p>我的博客：<a href="https://besthpt.github.io/" target="_blank" rel="noopener">https://besthpt.github.io/</a></p><blockquote><p>微信公众号：<br><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1633094381436-599e5e08-34bf-4d7a-88fb-e9a4b30ebea3.png" class="lazyload"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端分享心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端分享心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存一致性问题</title>
      <link href="/2021/10/01/3.%20redis/redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/01/3.%20redis/redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在高并发的情况下，如果当删除完缓存的时候，这时去更新数据库，但还没有更新完，另外一个请求来查询数据，发现缓存里没有，就去数据库里查，以商品库存为例，如果数据库中产品的库存是100，那么查询到的库存是100，然后插入缓存，插入完缓存后，原来那个更新数据库的线程把数据库更新为了99，导致数据库与缓存不一致的情况。这种情况如何解决比较好呢？     本文从以下三个部分进行浅谈，1、讲解缓存更新策略2、对每种策略进行缺点分析3、针对缺点给出改进方案     对于缓存和数据库的操作，主要有以下两种方式。 </p><h1 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h1><p>​    先删除缓存，数据库还没有更新成功，此时如果读取缓存，缓存不存在，去数据库中读取到的是旧值，缓存不一致发生。 </p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/333.png" class="lazyload"></p><p>​    该方案看似没毛病。使用先操作缓存（<strong>delete</strong>），再操作数据库。假如删除缓存成功，更新数据库失败了。缓存里没有数据，数据库里是之前的数据，数据没有不一致，对业务无影响。只是下一次读取，会多一次<strong>cache</strong> miss。     </p><p>但是如果放在并发场景下，一个写请求过来，删除了缓存，准备更新数据库（还没更新完成）。然后一个读请求过来，缓存未命中，从数据库读取旧数据，再次放到缓存中，这时候，数据库更新完成了。此时的情况是，缓存中是旧数据，数据库里面是新数据，数据不一致的问题便会凸显出来。 </p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1627453992836-84c10e1c-ee81-4d6f-a0ea-c6c2d403ef29.png" class="lazyload"></p><p>对于该场景下的问题，可以采用延时双删策略进行解决。     </p><p>延时双删的方案的思路是，为了避免更新数据库的时候，其他线程从缓存中读取不到数据，就在更新完数据库之后，再<strong>sleep</strong>一段时间，然后再次删除缓存。<strong>sleep</strong>的时间要对业务读写缓存的时间做出评估，<strong>sleep</strong>时间大于读写缓存的时间即可。     </p><p>流程如下：     </p><p>线程1删除缓存，然后去更新数据库     </p><p>线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存     </p><p>线程1，根据估算的时间，<strong>sleep</strong>，由于<strong>sleep</strong>的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除     </p><p>如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值。 </p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1627453993480-59f1ec90-2031-4be0-b6e0-eb2a02ac2cdc.png" class="lazyload"></p><h1 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h1><p>既然上述先删缓存不行，那如果反过来操作，先更新数据库，再删除缓存呢？</p><p>这个就更明显的问题了，更新数据库成功，如果删除缓存失败或者还没有来得及删除，那么，其他线程从缓存中读取到的就是旧值，还是会发生不一致。 </p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1627453992612-d70f275f-a1c0-4adc-9563-ab5908b46da6.png" class="lazyload"></p><p>​    那么这种情况下该怎么处理呢？     </p><p>基于<strong>binlog</strong>日志和消息队列：     </p><ol><li><p>应用直接写数据到数据库中。     </p></li><li><p>数据库更新<strong>binlog</strong>日志。    </p></li><li><p>利用<strong>Canal</strong>中间件读取<strong>binlog</strong>日志。     </p></li><li><p>Canal借助于限流组件按频率将数据发到<strong>MQ</strong>中。     </p></li><li><p>应用监控<strong>MQ</strong>通道，将<strong>MQ</strong>的数据更新到<strong>Redis</strong>缓存中。     </p></li></ol><p>可以看到这种方案对开发来说比较轻量，不用太关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。 </p><p><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1627453993383-37b6a854-6cad-4933-9ed5-7bc7c23528f1.png" class="lazyload"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    首先，我们要明确一点，缓存不是更新，而应该是删除。     </p><p>​    删除缓存有两种方式：     </p><ul><li><p>先删除缓存，再更新数据库。解决方案是使用延迟双删。     </p></li><li><p>先更新数据库，再删除缓存。解决方案是消息队列或者其他binlog同步，引入消息队列会带来更多的问题，并不推荐直接使用。     </p><p>为什么是删除而不是更新呢？     </p></li></ul><p>​    我们以先更新数据库，再删除缓存来举例。     </p><p>​    如果是更新的话，那就是先更新数据库，再更新缓存。    </p><p>​    举个例子：如果数据库1小时内更新了1000次，那么缓存也要更新1000次，但是这个缓存可能在1小时内只被读取了1次，那么这1000次的更新有必要吗？     </p><p>反过来，如果是删除的话，就算数据库更新了1000次，那么也只是做了1次缓存删除，只有当缓存真正被读取的时候才去数据库加载。     </p><p>​    针对缓存一致性要求不是很高的场景，那么只通过设置超时时间就可以了。其实，如果不是很高的并发，无论你选择先删缓存还是后删缓存的方式，都几乎很少能产生这种问题，但是在高并发下，你应该知道怎么解决问题。     </p><p>​    最后，个人认为哈，没有十全十美的解决方案，总是需要牺牲一点东西滴。</p><blockquote><p>我是简凡，一个励志用最简单的语言，描述最复杂问题的新时代农民工。<strong>求点赞，求关注</strong>，我会为你提供以下帮助：</p><ul><li>帮助你建立自己的后端知识体系</li><li>互联网真实高并发场景实战讲解</li><li>不定期分享Golang、Java相关业内的经典场景实践</li></ul><p>我的博客：<a href="https://besthpt.github.io/" target="_blank" rel="noopener">https://besthpt.github.io/</a><br>微信公众号：<br><img alt="img" data-src="https://codebear-images.oss-cn-beijing.aliyuncs.com/1633094381436-599e5e08-34bf-4d7a-88fb-e9a4b30ebea3.png" class="lazyload"></p></blockquote><script src="https://readmore.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'post-content',        blogId: '24566-1633176031733-929',        name: '简凡丶',        qrcode: 'https://codebear-images.oss-cn-beijing.aliyuncs.com/getqrcode.jpeg',        keyword: '666',    });</script>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上服务的FGC问题排查</title>
      <link href="/2020/07/15/6.%20JVM/FGC%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2020/07/15/6.%20JVM/FGC%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章，我将以一个FGC频繁的线上案例作为引子，详细介绍下GC的排查过程，另外会结合GC的运行原理给出一份实践指南，希望对你有所帮助。内容分成以下3个部分：</p><ul><li>从一次FGC频繁的线上案例说起</li><li>GC的运行原理介绍</li><li>排查FGC问题的实践指南</li></ul><h2 id="从一次FGC频繁的线上案例说起"><a href="#从一次FGC频繁的线上案例说起" class="headerlink" title="从一次FGC频繁的线上案例说起"></a>从一次FGC频繁的线上案例说起</h2><p>去年10月份，我们的广告召回系统在程序上线后收到了FGC频繁的系统告警，通过下面的监控图可以看到：平均每35分钟就进行了一次FGC。而程序上线前，我们的FGC频次大概是2天一次。下面，详细介绍下该问题的排查过程。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kbo3d18WZsey7GqTSBxR7OfI15BdBhQPy2Q7Zd0k1S5drjWQFk59fte4mMyRXaHOIPnOZwYyfb8cQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h3 id="检查JVM配置"><a href="#检查JVM配置" class="headerlink" title="检查JVM配置"></a>检查JVM配置</h3><p>通过以下命令查看JVM的启动参数：</p><p>ps aux | grep “applicationName=adsearch”</p><blockquote><p>-Xms4g -Xmx4g -Xmn2g -Xss1024K </p><p>-XX:ParallelGCThreads=5 </p><p>-XX:+UseConcMarkSweepGC </p><p>-XX:+UseParNewGC </p><p>-XX:+UseCMSCompactAtFullCollection </p><p>-XX:CMSInitiatingOccupancyFraction=80</p></blockquote><p>可以看到堆内存为4G，新生代为2G，老年代也为2G，新生代采用ParNew收集器，老年代采用并发标记清除的CMS收集器，当老年代的内存占用率达到80%时会进行FGC。</p><p>进一步通过 jmap -heap 7276 | head -n20 可以得知新生代的Eden区为1.6G，S0和S1区均为0.2G。</p><h3 id="观察老年代的内存变化"><a href="#观察老年代的内存变化" class="headerlink" title="观察老年代的内存变化"></a>观察老年代的内存变化</h3><p>通过观察老年代的使用情况，可以看到：每次FGC后，内存都能回到500M左右，因此我们排除了内存泄漏的情况。</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><h3 id="通过jmap命令查看堆内存中的对象"><a href="#通过jmap命令查看堆内存中的对象" class="headerlink" title="通过jmap命令查看堆内存中的对象"></a>通过jmap命令查看堆内存中的对象</h3><p>通过命令 jmap -histo 7276 | head -n20</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>上图中，按照对象所占内存大小排序，显示了存活对象的实例数、所占内存、类名。可以看到排名第一的是：int[]，而且所占内存大小远远超过其他存活对象。至此，我们将怀疑目标锁定在了 int[] .</p><h3 id="进一步dump堆内存文件进行分析"><a href="#进一步dump堆内存文件进行分析" class="headerlink" title="进一步dump堆内存文件进行分析"></a>进一步dump堆内存文件进行分析</h3><p>锁定 int[] 后，我们打算dump堆内存文件，通过可视化工具进一步跟踪对象的来源。考虑堆转储过程中会暂停程序，因此我们先从服务管理平台摘掉了此节点，然后通过以下命令dump堆内存：</p><p>jmap -dump:format=b,file=heap 7276</p><p>通过JVisualVM工具导入dump出来的堆内存文件，同样可以看到各个对象所占空间，其中int[]占到了50%以上的内存，进一步往下便可以找到 int[] 所属的业务对象，发现它来自于架构团队提供的codis基础组件。</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><h3 id="通过代码分析可疑对象"><a href="#通过代码分析可疑对象" class="headerlink" title="通过代码分析可疑对象"></a>通过代码分析可疑对象</h3><p>通过代码分析，codis基础组件每分钟会生成约40M大小的int数组，用于统计TP99 和 TP90，数组的生命周期是一分钟。而根据第2步观察老年代的内存变化时，发现老年代的内存基本上也是每分钟增加40多M，因此推断：这40M的int数组应该是从新生代晋升到老年代。</p><p>我们进一步查看了YGC的频次监控，通过下图可以看到大概1分钟有8次左右的YGC，这样基本验证了我们的推断：因为CMS收集器默认的分代年龄是6次，即YGC 6次后还存活的对象就会晋升到老年代，而codis组件中的大数组生命周期是1分钟，刚好满足这个要求。</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>至此，整个排查过程基本结束了，那为什么程序上线前没出现此问题呢？通过上图可以看到：程序上线前YGC的频次在5次左右，此次上线后YGC频次变成了8次左右，从而引发了此问题。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了快速解决问题，我们将CMS收集器的分代年龄改成了15次，改完后FGC频次恢复到了2天一次，后续如果YGC的频次超过每分钟15次还会再次触发此问题。当然，我们最根本的解决方案是：优化程序以降低YGC的频率，同时缩短codis组件中int数组的生命周期，这里就不做展开了。</p><h2 id="GC的运行原理介绍"><a href="#GC的运行原理介绍" class="headerlink" title="GC的运行原理介绍"></a>GC的运行原理介绍</h2><p>上面整个案例的分析过程中，其实涉及到很多GC的原理知识，如果不懂得这些原理就着手处理，其实整个排查过程是很抓瞎的。</p><p>这里，我选择几个最核心的知识点，展开介绍下GC的运行原理，最后再给出一份实践指南。</p><h3 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h3><p>大家都知道: GC分为YGC和FGC，它们均发生在JVM的堆内存上。先来看下JDK8的堆内存结构：</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>可以看到，堆内存采用了分代结构，包括新生代和老年代。新生代又分为：Eden区，From Survivor区（简称S0），To Survivor区（简称S1区），三者的默认比例为8:1:1。另外，新生代和老年代的默认比例为1:2。</p><p>堆内存之所以采用分代结构，是考虑到绝大部分对象都是短生命周期的，这样不同生命周期的对象可放在不同的区域中，然后针对新生代和老年代采用不同的垃圾回收算法，从而使得GC效率最高。</p><h3 id="YGC是什么时候触发的？"><a href="#YGC是什么时候触发的？" class="headerlink" title="YGC是什么时候触发的？"></a>YGC是什么时候触发的？</h3><p>大多数情况下，对象直接在年轻代中的Eden区进行分配，如果Eden区域没有足够的空间，那么就会触发YGC（Minor GC），YGC处理的区域只有新生代。因为大部分对象在短时间内都是可收回掉的，因此YGC后只有极少数的对象能存活下来，而被移动到S0区（采用的是复制算法）。</p><p>当触发下一次YGC时，会将Eden区和S0区的存活对象移动到S1区，同时清空Eden区和S0区。当再次触发YGC时，这时候处理的区域就变成了Eden区和S1区（即S0和S1进行角色交换）。每经过一次YGC，存活对象的年龄就会加1。</p><h3 id="FGC又是什么时候触发的？"><a href="#FGC又是什么时候触发的？" class="headerlink" title="FGC又是什么时候触发的？"></a>FGC又是什么时候触发的？</h3><p>下面4种情况，对象会进入到老年代中：</p><ul><li>YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。</li><li>经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中。</li><li>动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。</li><li>大对象：由-XX:PretenureSizeThreshold启动参数控制，若对象大小大于此值，就会绕过新生代, 直接在老年代中分配。</li></ul><p>当晋升到老年代的对象大于了老年代的剩余空间时，就会触发FGC（Major GC），FGC处理的区域同时包括新生代和老年代。除此之外，还有以下4种情况也会触发FGC：</p><ul><li>老年代的内存使用率达到了一定阈值（可通过参数调整），直接触发FGC。</li><li>空间分配担保：在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC。</li><li>Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC。</li><li>System.gc() 或者Runtime.gc() 被显式调用时，触发FGC。</li></ul><h3 id="在什么情况下，GC会对程序产生影响？"><a href="#在什么情况下，GC会对程序产生影响？" class="headerlink" title="在什么情况下，GC会对程序产生影响？"></a>在什么情况下，GC会对程序产生影响？</h3><p>不管YGC还是FGC，都会造成一定程度的程序卡顿（即Stop The World问题：GC线程开始工作，其他工作线程被挂起），即使采用ParNew、CMS或者G1这些更先进的垃圾回收算法，也只是在减少卡顿时间，而并不能完全消除卡顿。</p><p>那到底什么情况下，GC会对程序产生影响呢？根据严重程度从高到底，我认为包括以下4种情况：</p><ul><li>FGC过于频繁：FGC通常是比较慢的，少则几百毫秒，多则几秒，正常情况FGC每隔几个小时甚至几天才执行一次，对系统的影响还能接受。但是，一旦出现FGC频繁（比如几十分钟就会执行一次），这种肯定是存在问题的，它会导致工作线程频繁被停止，让系统看起来一直有卡顿现象，也会使得程序的整体性能变差。</li><li>YGC耗时过长：一般来说，YGC的总耗时在几十或者上百毫秒是比较正常的，虽然会引起系统卡顿几毫秒或者几十毫秒，这种情况几乎对用户无感知，对程序的影响可以忽略不计。但是如果YGC耗时达到了1秒甚至几秒（都快赶上FGC的耗时了），那卡顿时间就会增大，加上YGC本身比较频繁，就会导致比较多的服务超时问题。</li><li>FGC耗时过长：FGC耗时增加，卡顿时间也会随之增加，尤其对于高并发服务，可能导致FGC期间比较多的超时问题，可用性降低，这种也需要关注。</li><li>YGC过于频繁：即使YGC不会引起服务超时，但是YGC过于频繁也会降低服务的整体性能，对于高并发服务也是需要关注的。</li></ul><p>其中，「FGC过于频繁」和「YGC耗时过长」，这两种情况属于比较典型的GC问题，大概率会对程序的服务质量产生影响。剩余两种情况的严重程度低一些，但是对于高并发或者高可用的程序也需要关注。</p><h2 id="排查FGC问题的实践指南"><a href="#排查FGC问题的实践指南" class="headerlink" title="排查FGC问题的实践指南"></a>排查FGC问题的实践指南</h2><p>通过上面的案例分析以及理论介绍，再总结下FGC问题的排查思路，作为一份实践指南供大家参考。</p><h3 id="清楚从程序角度，有哪些原因导致FGC？"><a href="#清楚从程序角度，有哪些原因导致FGC？" class="headerlink" title="清楚从程序角度，有哪些原因导致FGC？"></a>清楚从程序角度，有哪些原因导致FGC？</h3><ul><li>大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。</li><li>内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.</li><li>程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）</li><li>程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.</li><li>代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。</li><li>JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。</li></ul><h3 id="清楚排查问题时能使用哪些工具"><a href="#清楚排查问题时能使用哪些工具" class="headerlink" title="清楚排查问题时能使用哪些工具"></a>清楚排查问题时能使用哪些工具</h3><ul><li><p>公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。</p></li><li><p>JDK的自带工具，包括jmap、jstat等常用命令：</p><p># 查看堆内存各区域的使用率以及GC情况</p><p>jstat -gcutil -h20 pid 1000</p><p># 查看堆内存中的存活对象，并按空间排序</p><p>jmap -histo pid | head -n20</p><p># dump堆内存文件</p><p>jmap -dump:format=b,file=heap pid</p></li><li><p>可视化的堆内存分析工具：JVisualVM、MAT等</p></li></ul><h3 id="排查指南"><a href="#排查指南" class="headerlink" title="排查指南"></a>排查指南</h3><ul><li><p>查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）</p></li><li><p>了解该时间点之前有没有程序上线、基础组件升级等情况。</p></li><li><p>了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。</p></li><li><p>再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。</p></li><li><p>针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。</p></li><li><p>通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</p></li></ul><p>最后的话</p><p>这篇文章通过线上案例并结合GC原理详细介绍了FGC的排查过程，同时给出了一份实践指南。</p><p>后续会以类似的方式，再分享一个YGC耗时过长的案例，希望能帮助大家吃透GC问题排查，如果觉得本文对你有帮助，请帮忙转发或者点个再看！</p><end></end>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础</title>
      <link href="/2020/07/15/6.%20JVM/JVM%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/15/6.%20JVM/JVM%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM基础"><a href="#JVM基础" class="headerlink" title="JVM基础"></a>JVM基础</h2><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>本文介绍了一些常见的JVM中的面试题</p><hr><h2 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h2><ul><li><p><code>强引用：</code>发生 gc 的时候不会被回收。</p><p>之前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。比如下面这段代码中的object和str都是强引用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">String str = <span class="string">"StrongReference"</span>;</span><br></pre></td></tr></table></figure></div></li><li><p><code>软引用：</code>有用但不是必须的对象，在发生内存溢出之前会被回收。在Java中用java.lang.ref.SoftReference类来表示。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p></li><li><p><code>弱引用：</code>有用但不是必须的对象，在下一次GC时会被回收。应用场景：如果一个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么应该用 Weak Reference 来记住此对象。或者想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候就应该用弱引用，这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</p></li><li><p><code>虚引用：</code>和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动。</p></li></ul><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="说一下-JVM-的主要组成部分及其作用？"><a href="#说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分及其作用？"></a>说一下 JVM 的主要组成部分及其作用？</h3><p><img alt="image-20200607182848130" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjwj4acnpj31ho0tkwvt.jpg" class="lazyload"></p><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><ul><li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li><li>Execution engine（执行引擎）：执行classes中的指令。</li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li><li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li></ul><p><strong>作用</strong> ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h3 id="JVM的方法区和永久带是什么关系？"><a href="#JVM的方法区和永久带是什么关系？" class="headerlink" title="JVM的方法区和永久带是什么关系？"></a>JVM的方法区和永久带是什么关系？</h3><p>（1）方法区是规范层面的东西，规定了这一个区域要存放哪些东西</p><p>（2）永久带或者是metaspace是对方法区的不同实现，是实现层面的东西。</p><h3 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?"></a>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h3><ol><li><p>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。间接性地解决了永久代的OOM问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MetaspaceSize：初始化元空间大小，控制发生GC</span><br><span class="line">MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</span><br></pre></td></tr></table></figure></div></li><li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p></li></ol><h3 id="CodeCache"><a href="#CodeCache" class="headerlink" title="CodeCache"></a>CodeCache</h3><h4 id="JIT简介"><a href="#JIT简介" class="headerlink" title="JIT简介"></a>JIT简介</h4><p>JIT是just in time的缩写，也就是即时编译。通过JIT技术，能够做到Java程序执行速度的加速。那么，是怎么做到的呢？</p><p>我们都知道，Java是一门解释型语言（或者说是半编译，半解释型语言）。Java通过编译器javac先将源程序编译成与平台无关的Java字节码文件（.class），再由JVM解释执行字节码文件，从而做到平台无关。 但是，有利必有弊。对字节码的解释执行过程实质为：<strong>JVM先将字节码翻译为对应的机器指令，然后执行机器指令。</strong>很显然，这样经过解释执行，其执行速度必然不如直接执行二进制字节码文件。</p><p>而为了提高执行速度，便引入了 JIT 技术。通过<code>热点探测</code>，<strong>当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。</strong></p><p><strong><img alt="img" data-src="https://img-blog.csdnimg.cn/20190101150248567.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTAyNjg0,size_16,color_FFFFFF,t_70" class="lazyload"></strong></p><p><code>codecache</code>代码缓存区,主要存放JIT所编译的代码,同时还有Java所使用的本地方法代码也会存储在codecache中.</p><p><code>相关参数:</code></p><p><code>-XX:ReservedCodeCacheSize</code>  ：设置codeCache的size大小</p><p>一种推荐的设置思路是设置为当前值（或者默认值）的2倍 对于64位jvm，由于内存空间足够大，codeCache设置的过大不会对应用产生明显影响</p><p><code>-XX:+UseCodeCacheFlushing</code> ：启用code cache的回收机制。</p><ul><li>当codeCache将要耗尽时，最早被编译的一半方法将会被放到一个old列表中等待回收,在一定时间间隔内，如果方法没有被调用，这个方法就会被从codeCache充清除</li></ul><p>在jdk8中，提供了一个启动参数XX:+PrintCodeCache在jvm停止的时候打印出codeCache的使用情况</p><p>由于JIT是随着代码被调用的次数达到CompileThreshold之后进行的，因此，codecache使用也会随之增加，常见的问题就是，随着时间的推移应用占用CPU会随之增高，请求相应变慢等问题，这时就需要考虑codecache的问题了。</p><h3 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h3><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域</strong>。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：</p><p><img alt="image-20200610123657999" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn37yjhp4j30iq0czwh3.jpg" class="lazyload"></p><h4 id="分别介绍"><a href="#分别介绍" class="headerlink" title="分别介绍"></a>分别介绍</h4><ul><li><code>程序计数器</code>：程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</li><li><code>虚拟机栈</code>：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<ul><li>每个栈帧都存放以上4个信息，每个栈帧是一个<strong>方法</strong></li><li><strong>局部变量表</strong>，存放局部变量，例如int a=2;</li><li><strong>操作数栈</strong>存放帮助栈帧进行运算的临时操作数。</li><li><strong>动态链接</strong>：通过javap命令查看class文件，可以看到很多符号引用，在类加载的过程（静态链接）或运行过程会将部分符号引用在运行期间转化为直接引用。直接引用可被jvm通过命令调用。</li></ul></li><li><code>本地方法栈</code>：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li><code>Java堆</code>：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li><code>方法区</code>：用于存储已被虚拟机加载的类元信息、常量、静态变量、即时编译后的代码等数据。</li></ul><p><img alt="image-20200610124342656" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn3exp8l0j30he09uwfo.jpg" class="lazyload"></p><h4 id="Java-虚拟机栈会出现两种错误："><a href="#Java-虚拟机栈会出现两种错误：" class="headerlink" title="Java 虚拟机栈会出现两种错误："></a>Java 虚拟机栈会出现两种错误：</h4><p>StackOverFlowError 和 OutOfMemoryError。</p><ul><li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><h4 id="虚拟机栈和虚拟机堆区别"><a href="#虚拟机栈和虚拟机堆区别" class="headerlink" title="虚拟机栈和虚拟机堆区别"></a>虚拟机栈和虚拟机堆区别</h4><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h3 id="Java文件完整的加载运行过程"><a href="#Java文件完整的加载运行过程" class="headerlink" title="Java文件完整的加载运行过程"></a>Java文件完整的加载运行过程</h3><p>一个简单的学生类 <a href="https://camo.githubusercontent.com/6349bcfb73fc5bbf962fdaab7546c381b828136a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f32393034366137323163323534386530613036383065633562616634656139352d6e65772d696d61676562306234326535652d386532352d343039652d623762392d3635383661333961306238642e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/6349bcfb73fc5bbf962fdaab7546c381b828136a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f32393034366137323163323534386530613036383065633562616634656139352d6e65772d696d61676562306234326535652d386532352d343039652d623762392d3635383661333961306238642e706e67" class="lazyload"></a></p><p>一个main方法 <a href="https://camo.githubusercontent.com/6c5bb22ea8dbc90158b3207d8fd602731a14b42a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f61336433346433336561623734663666383734336563663632383037343435632d6e65772d696d61676530383530366139652d353130312d346633302d623062632d3361626263623866313839342e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/6c5bb22ea8dbc90158b3207d8fd602731a14b42a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f61336433346433336561623734663666383734336563663632383037343435632d6e65772d696d61676530383530366139652d353130312d346633302d623062632d3361626263623866313839342e706e67" class="lazyload"></a></p><p>执行main方法的步骤如下:</p><ol><li>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li>JVM 找到 App 的主程序入口，执行main方法</li><li>这个main中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的元信息</strong> 的引用</li><li>执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li>执行sayName()</li></ol><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="类加载器的流程（加校准解初使卸）"><a href="#类加载器的流程（加校准解初使卸）" class="headerlink" title="类加载器的流程（加校准解初使卸）"></a>类加载器的流程（加校准解初使卸）</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，校验，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>将class文件加载到内存</li><li>将静态数据结构转化成方法区中运行时的数据结构</li><li>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li></ol><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ol><li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的），但这里只是赋值为int a=0，即根据数据类型符默认值。</li><li>解析：虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化其实就是一个赋值的操作，它会执行一个类构造器的<clinit>()方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3</clinit></p><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>GC将无用对象从内存中卸载</p><h3 id="类加载器的加载顺序"><a href="#类加载器的加载顺序" class="headerlink" title="类加载器的加载顺序"></a>类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li>启动类加载器：BootStrap ClassLoader：rt.jar</li><li>拓展类加载器：Extention ClassLoader: 加载扩展的jar包</li><li>应用类加载器：App ClassLoader：指定的classpath下面的jar包</li><li>自定义类加载器：Custom ClassLoader</li></ol><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载</p><p>这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码。</p><h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Java类加载机制的强大之处在于，我们可以创建自定义的ClassLoader，自定义ClassLoader是Tomcat实现应用隔离、支持JSP，OSGI实现动态模块化的基础。 </p><p>怎么自定义呢？一般而言，继承类ClassLoader，重写findClass就可以了。怎么实现findClass呢？使用自己的逻辑寻找class文件字节码的字节形式，找到后，使用如下方法转换为Class对象：</p><p>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</p><p>name表示类名，b是存放字节码数据的字节数组，有效数据从off开始，长度为len。</p><p>看个例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_DIR = <span class="string">"data/c87/"</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String fileName = name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span><br><span class="line">        fileName = BASE_DIR + fileName + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = BinaryFileUtils.readFileToByteArray(fileName);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"failed to load class "</span> + name, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>MyClassLoader从BASE_DIR下的路径中加载类，转换为byte数组。MyClassLoader没有指定父ClassLoader，默认是系统类加载器，即ClassLoader.getSystemClassLoader()的返回值，不过，ClassLoader有一个可重写的构造方法，可以指定父ClassLoader：protected ClassLoader(ClassLoader parent) </p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>这到底有什么用呢？</p><ul><li>可以实现<code>隔离</code>，一个复杂的程序，内部可能按模块组织，不同模块可能使用同一个类，但使用的是不同版本，如果使用同一个类加载器，它们是无法共存的，不同模块使用不同的类加载器就可以实现隔离，Tomcat使用它隔离不同的Web应用，OSGI使用它隔离不同模块。</li><li>可以实现<code>热部署</code>，使用同一个ClassLoader，类只会被加载一次，加载后，即使class文件已经变了，再次加载，得到的也还是原来的Class对象，而使用MyClassLoader，则可以先创建一个新的ClassLoader，再用它加载Class，得到的Class对象就是新的，从而实现动态更新。</li></ul><h2 id="虚拟机堆"><a href="#虚拟机堆" class="headerlink" title="虚拟机堆"></a>虚拟机堆</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img alt="image-20200812110120377" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghnuhus4w6j316h0kh446.jpg" class="lazyload"></p><p>​        JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，默认比例是1:2，而非堆内存则为<strong>永久代</strong>（）。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。</p><h3 id="垃圾回收的过程"><a href="#垃圾回收的过程" class="headerlink" title="垃圾回收的过程"></a>垃圾回收的过程</h3><ol><li><p>当我们new一个对象后，会先放到<strong>Eden</strong>划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会<strong>预先申请</strong>好一块连续的内存空间并规定了对象存放的位置。</p></li><li><p>当Eden空间满了之后，会触发一个叫做<code>Minor GC</code>（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 <code>Minor GC</code>，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。</p></li><li><p>经过多次的 Minor GC后仍然存活的对象（<strong>这里的存活判断是15次，对应虚拟机参数XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15</strong>）会移动到老年代。</p></li><li><p>老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p></li><li><p>当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是<strong>堆内存设置的大小过小</strong>，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的<strong>对象大且多</strong>，而且它们一直在<strong>被引用</strong>从而长时间垃圾收集无法收集它们。JVM默认使用系统内存的1/4。</p></li></ol><p><a href="https://camo.githubusercontent.com/3c6ec61a270148e9f2bea602bce6998d8aa31bde/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f63303265636261336333336634333432396137363539383762393238653432332d6e65772d696d61676539336234366633642d333366392d343666392d613832352d6563373132396230303466362e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/3c6ec61a270148e9f2bea602bce6998d8aa31bde/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f63303265636261336333336634333432396137363539383762393238653432332d6e65772d696d61676539336234366633642d333366392d343666392d613832352d6563373132396230303466362e706e67" class="lazyload"></a></p><h3 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a>动态年龄判断</h3><p>​        一句话：当某年龄在survivor区占比超过预设值时，大于等于该年龄的对象会直接进行老年代，无需等到MaxTenuringThreshold中要求的15。</p><p>​        设定的参数为：-XX:TargetSurvivorRatio</p><h3 id="如何判断一个对象需要被干掉"><a href="#如何判断一个对象需要被干掉" class="headerlink" title="如何判断一个对象需要被干掉"></a>如何判断一个对象需要被干掉</h3><p><a href="https://camo.githubusercontent.com/29dbca08b9255c2e71c234dcf599ed0d93e90c81/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f31633164383562356662386234373233396166326135633034333665623264372d6e65772d696d61676530636431303832372d326639362d343333632d396231362d3933643466653439316438382e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/29dbca08b9255c2e71c234dcf599ed0d93e90c81/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f31633164383562356662386234373233396166326135633034333665623264372d6e65772d696d61676530636431303832372d326639362d343333632d396231362d3933643466653439316438382e706e67" class="lazyload"></a></p><p>​        程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法：</p><p>1.<code>引用计数器</code>：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</p><p>2.<code>可达性分析</code>：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。</p><p><code>能作为GC Roots的对象分为以下几种：</code></p><ol><li>虚拟机栈中引用的对象（局部变量）</li><li>本地方法栈中引用的对象</li><li>方法区中静态变量所引用的对象和常量引用的对象（静态变量）</li></ol><p>这种方法的优点是能够解决<strong>循环引用</strong>的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><h3 id="如何宣告一个对象的真正死亡"><a href="#如何宣告一个对象的真正死亡" class="headerlink" title="如何宣告一个对象的真正死亡"></a>如何宣告一个对象的真正死亡</h3><p>判断一个对象的死亡至少需要两次标记</p><ol><li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否重写了finalize()方法。如果对象重写了finalize()方法，则被放入F-Queue队列中。</li><li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p><img alt="image-20200610210559246" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfnhxjqulej30j607sdjv.jpg" class="lazyload"></p><p>例如：</p><p>开启逃逸分析后test2中的user对象，直接在栈内存中创建，当方法完成后直接被垃圾回收。jdk7以后默认开启逃逸分析。</p><p><img alt="image-20200610210625390" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfnhy0h9yyj309m09yzlk.jpg" class="lazyload"></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>常用的有标记清除，复制，标记整理和分代收集算法</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>Hotspot JVM把年轻代分为了三部分:1个Eden区和2个 Survivor区(分别叫from和to),默认比例为8:1:1,一般情况下 新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次 Minor gc后,如果仍然存活,将会被移到 Survivor区。对象在 Survivor区中每熬过一次 Minor gc,年齡就会增加1岁,当它的年齡(15默认)增加到一定程度时,就会被移动到 年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上),所以在<strong>年轻代的垃圾回收算法使用的是复制算法</strong>,复制算法的基本思想就是将内存分为两块,每次只用其中一块,当这一块内存用完,就将还活着的对象复制到另外一块上面。</p><p><code>好处</code>：复制算法不会产生内存碎片，对象完整不会丢。</p><p><code>缺点</code>：浪费了10%空间。</p><p><a href="https://camo.githubusercontent.com/532263eb835a296a059c16f25be1a2b2b4b23893/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66633334396662623962323034343935613533323166656265323738313864342d6e65772d696d61676534353932306139612d353532632d343635362d393464362d6533636134356666396237362e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/532263eb835a296a059c16f25be1a2b2b4b23893/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66633334396662623962323034343935613533323166656265323738313864342d6e65772d696d61676534353932306139612d353532632d343635362d393464362d6533636134356666396237362e706e67" class="lazyload"></a></p><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记清除算法就是分为“标记”和“清除”两个阶段。<strong>标记出所有需要回收的对象，标记结束后统一回收</strong>。</p><p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p><p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p><p><a href="https://camo.githubusercontent.com/f54d91118e4ffbd266bf7be3b7149881cb0a63fc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f30313630356439366438356634646161623962666135653730303066306433312d6e65772d696d61676537386530336238352d666265662d346466392d623431652d3262363364373864313139662e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/f54d91118e4ffbd266bf7be3b7149881cb0a63fc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f30313630356439366438356634646161623962666135653730303066306433312d6e65772d696d61676537386530336238352d666265662d346466392d623431652d3262363364373864313139662e706e67" class="lazyload"></a></p><p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p><p>标记整理算法唯一的<code>缺点</code>就是效率也不髙,不仅要<strong>标记所有存活对象,还要整理所有存活对象的引用地址</strong>。从效率上来说,标记整理算法要低于复制算法。</p><p><a href="https://camo.githubusercontent.com/24d3da571e399084768678257c97c1ecefadac06/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f32353939653966373232303734643334613366376664396630303736663132312d6e65772d696d61676563373631393265632d623633612d343365332d613664362d6366303166373439393533662e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/24d3da571e399084768678257c97c1ecefadac06/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f32353939653966373232303734643334613366376664396630303736663132312d6e65772d696d61676563373631393265632d623633612d343365332d613664362d6366303166373439393533662e706e67" class="lazyload"></a></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p><p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>HotSpot VM中的垃圾回收器，以及适用场景 <a href="https://camo.githubusercontent.com/e5b0e914fca887cfb0906a3a73b30a60d8fa984b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f31316539646364306631656534663235383336653666316334373130346335312d6e65772d696d61676536396531633536612d316434302d343933612d393930312d3665666336343761303166332e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/e5b0e914fca887cfb0906a3a73b30a60d8fa984b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f31316539646364306631656534663235383336653666316334373130346335312d6e65772d696d61676536396531633536612d316434302d343933612d393930312d3665666336343761303166332e706e67" class="lazyload"></a></p><p>串行：Serial（新生代） ，Serial Old（老年代），适用于单CPU的Client模式</p><p>并行：Parallel Scavenge （新生代）和 Parallel Old（老年代），侧重于吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间））优先，是jdk8默认的垃圾收集器，所以更适合做后台运算等不需要太多用户交互的任务。Parallel Old使用多线程和标记整理法</p><p>并行：ParNew（新生代）和CMS（老年代），侧重于响应速度优先。</p><p><code>ParNew：</code></p><p>多线程版的 Serial。多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，<strong>只有它能与 CMS 收集器配合工作</strong>。</p><h2 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h2><p>关注点是获得最短的回收停顿时间，用的是“标记-清除”算法，它运作过程分为四个步骤：</p><ul><li>初始标记（CMS initial mark）- Stop The World，标记GC_ROOT根节点及其子节点，时间短</li><li>并发标记（CMS concurrent mark），标记第一步接下来的节点。</li><li>重新标记（CMS remark）- Stop The World：补充标记前两步后新生成的节点。</li><li>并发清除（CMS concurrent sweep），</li></ul><p>其中并发标记、并发清除时间是相对较长的，都是可以和用户线程并发执行的，所以Stop The World时间是很短的，总体上来看就是并发执行的，这对要求响应速度较快的应用场景比较适合。</p><p><code>CMS缺点：</code></p><ul><li>对CPU资源敏感，抢占CPU资源将导致用户线程的CPU资源减少而变得缓慢；</li><li>无法处理浮动垃圾，在并发回收垃圾时，用户线程会产生新的垃圾对象，这些垃圾要等下次回收；</li><li>由于在并发回收的过程用户线程还在工作，这就需要预留一定的内存空间给用户线程，导致内存空间利用率下降；然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 <strong>Concurrent Mode Failure</strong> 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</li><li>CMS采用的是标记-清除算法，这就导致内存碎片化。若出现内存空间还很多，但由于碎片化的情况，无法满足大对象的分配，当顶不住要触发Full GC时开启内存碎片合并整理过程，这个过程是不能并发的，会Stop The World。</li></ul><p>到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old</p><p>从jdk9开始，G1收集器成为默认的垃圾收集器 目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。</p><p><img alt="image-20200611140259211" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfobbsd03zj30hj0eygmu.jpg" class="lazyload"></p><h2 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h2><p>​        通过引入 <code>Region</code> 的概念，从而将原来的整块堆内存空间划分成2048个的小空间，使得每个小空间可以单独进行垃圾回收。每块可作为Eden、Survivor、Old、Humongous中的一种。</p><p>​        这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>​        每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用来记录该 <code>Region</code> 对象的引用对象所在的 <code>Region</code>。在做可达性分析的时候就可以避免全堆扫描。</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong>：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中。这阶段需要停顿线程，但是可并行执行。</li><li><strong>筛选回收</strong>：首先对各个 <code>Region</code> 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p><code>优点</code>：</p><ul><li>空间整理，与<strong>CMS</strong>的<strong>标记-清理</strong>相比，它采用的是<strong>标记-整理</strong>，从局部Region来看又是<strong>复制算法</strong>；另外CMS在回收阶段将标记的垃圾全部回收，但G1根据设定参数，排序后，只回收优先级高的垃圾，缩短了垃圾回收的时间，保证了响应速度。</li><li>可预测停顿，可以让使用这指定在长度为M毫秒的是时间内，垃圾收集时间不能超过N毫秒；</li><li>年轻代初始赋值5%的内存空间，如果达到此空间，但还没达到设置的GC时间，就会动态增加年轻代的Region。</li></ul><p><img alt="image-20200610154046331" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggq7zvne60j30g8059tao.jpg" class="lazyload"></p><p>当一个对象大于Region大小的50%，称为巨型对象；它就会独占一个或多个Region，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区-Humongous Region</p><h2 id="JVM的常用参数"><a href="#JVM的常用参数" class="headerlink" title="JVM的常用参数"></a>JVM的常用参数</h2><h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3><p><code>-Xms</code></p><p>初始大小内存，默认为物理内存 1/64</p><p>等价于 -XX:InitialHeapSize</p><p><code>-Xmx</code></p><p>最大分配内存，默认为物理内存的 1/4</p><p>等价于 -XX:MaxHeapSize</p><p><strong>-Xms和-Xmx最好一致，以避免每次垃圾回收完成后JVM重新分配内存。</strong></p><p><code>-XX:SurvivorRatio</code></p><p>设置新生代中 eden 和 S0/S1 空间比例</p><p>默认 -XX:SurvivorRatio=8，Eden : S0 : S1 = 8 : 1 : 1</p><p><code>-XX:NewRatio</code></p><p>配置年轻代和老年代在堆结构的占比</p><p>默认 -XX:NewRatio=2 新生代占1，老年代占2，年轻代占整个堆的 1/3</p><p><code>-Xss</code></p><p>设置单个线程栈的大小，一般默认为 512-1024k</p><p>等价于 -XX:ThreadStackSize</p><p>在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p><p><code>-XX:MetaspaceSize</code></p><p>设置元空间大小（元空间的本质和永久代类似，都是对 JVM 规范中的方法区的实现，不过元空间于永久代之间最大区别在于，元空间并不在虚拟中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地内存限制）</p><p>元空间默认比较小，我们可以调大一点</p><p><code>-XX:MaxTenuringThreshold</code></p><p>设置垃圾最大年龄</p><p><code>-XX:+PrintGCDetails</code></p><p>输出详细 GC 收集日志信息 </p><p><img alt="image-20200812112340234" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghnv54e8gaj30ks01ywh6.jpg" class="lazyload"></p><h3 id="G1-GC的参数选项"><a href="#G1-GC的参数选项" class="headerlink" title="G1 GC的参数选项"></a>G1 GC的参数选项</h3><table><thead><tr><th>参数名</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>-XX:+UseG1GC</td><td>==使用G1收集器==</td><td>JDK1.8中还需要显式指定</td></tr><tr><td>-XX:MaxGCPauseMillis=n</td><td>设置一个==期望的最大GC暂停时间==，这是一个柔性的目标，JVM会尽力去达到这个目标</td><td>200</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent=n</td><td>当整个堆的空间使用百分比超过这个值时，就会触发一次并发收集周期，记住是整个堆</td><td>45</td></tr><tr><td>-XX:NewRatio=n</td><td>新生代和老年代的比例</td><td>2</td></tr><tr><td>-XX:SurvivorRatio=n</td><td>Eden空间和Survivor空间的比例</td><td>8</td></tr><tr><td>-XX:MaxTenuringThreshold=n</td><td>对象在新生代中经历的最多的新生代收集，或者说最大的岁数</td><td>G1中是15</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>设置垃圾收集器的并行阶段的垃圾收集线程数</td><td>不同的平台有不同的值</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>设置垃圾收集器并发执行GC的线程数</td><td>n一般是ParallelGCThreads的四分之一</td></tr><tr><td>-XX:G1ReservePercent=n</td><td>设置作为==空闲空间的预留内存百分比==，以降低目标空间溢出（疏散失败）的风险。默认值是 10%。增加或减少这个值，请确保对总的 Java 堆调整相同的量</td><td>10</td></tr><tr><td>-XX:G1HeapRegionSize=n</td><td>分区的大小</td><td>堆内存大小的1/2000，单位是MB，值是2的幂，范围是1MB到32MB之间</td></tr><tr><td>-XX:G1HeapWastePercent=n</td><td>设置您愿意浪费的堆百分比。如果可回收百分比小于堆废物百分比，JavaHotSpotVM不会启动混合垃圾回收周期（注意，这个参数可以用于调整混合收集的频率）。</td><td>JDK1.8是5</td></tr><tr><td>-XX:G1MixedGCCountTarget=8</td><td>设置并发周期后需要执行多少次混合收集，如果混合收集中STW的时间过长，可以考虑增大这个参数。（注意：这个可以用来调整每次混合收集中回收掉老年代分区的多少，即调节混合收集的停顿时间）</td><td>8</td></tr><tr><td>-XX:G1MixedGCLiveThresholdPercent=n</td><td>一个分区是否会被放入mix GC的CSet的阈值。对于一个分区来说，它的存活对象率如果超过这个比例，则改分区不会被列入mixed gc的CSet中</td><td>JDK1.6和1.7是65，JDK1.8是85</td></tr></tbody></table><h2 id="关于JVM调优的一些方面"><a href="#关于JVM调优的一些方面" class="headerlink" title="关于JVM调优的一些方面"></a>关于JVM调优的一些方面</h2><p>我们可以尝试对JVM进行调优，主要就是堆内存那块</p><h3 id="调整最大堆内存和最小堆内存"><a href="#调整最大堆内存和最小堆内存" class="headerlink" title="调整最大堆内存和最小堆内存"></a>调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB))</p><p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p><p>开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>我们执行下面的代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);    <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//当前可用的总空间</span></span><br></pre></td></tr></table></figure></div><p>注意：此处设置的是Java堆大小，也就是新生代大小 + 老年代大小 <a href="https://camo.githubusercontent.com/9a9d237967393ea65368245aacc26b93eb787f84/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f35653762333532633136643734633738396336363561663436643361323530392d6e65772d696d61676564643634356461652d333037642d343537322d623665322d6235613939323561343663642e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/9a9d237967393ea65368245aacc26b93eb787f84/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f35653762333532633136643734633738396336363561663436643361323530392d6e65772d696d61676564643634356461652d333037642d343537322d623665322d6235613939323561343663642e706e67" class="lazyload"></a></p><p>设置一个VM options的参数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms5m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure></div><p><a href="https://camo.githubusercontent.com/caf41e27bf203a1281f20969d94cd790258a6a12/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66653939653335356634373534666134626537343237636236353236316633642d6e65772d696d61676562623563663438352d393966382d343365622d383830392d3261383965366131373638652e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/caf41e27bf203a1281f20969d94cd790258a6a12/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66653939653335356634373534666134626537343237636236353236316633642d6e65772d696d61676562623563663438352d393966382d343365622d383830392d3261383965366131373638652e706e67" class="lazyload"></a></p><p>再次启动main方法</p><p><a href="https://camo.githubusercontent.com/b536da4f44b4b683f323afb045009f734095da49/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f33303035333966363536303034336464386133666530383564323834323065362d6e65772d696d61676533633538316132652d313936662d346230312d393066312d6332373733316234363130622e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/b536da4f44b4b683f323afb045009f734095da49/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f33303035333966363536303034336464386133666530383564323834323065362d6e65772d696d61676533633538316132652d313936662d346230312d393066312d6332373733316234363130622e706e67" class="lazyload"></a> 这里GC弹出了一个Allocation Failure分配失败，这个事情发生在PSYoungGen，也就是年轻代中</p><p>这时候申请到的内存为18M，空闲内存为4.214195251464844M</p><p>我们此时创建一个字节数组看看，执行下面的代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] b &#x3D; new byte[1 * 1024 * 1024];</span><br><span class="line">System.out.println(&quot;分配了1M空间给数组&quot;);</span><br><span class="line">System.out.println(&quot;Xmx&#x3D;&quot; + Runtime.getRuntime().maxMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);  &#x2F;&#x2F;系统的最大空间</span><br><span class="line">System.out.println(&quot;free mem&#x3D;&quot; + Runtime.getRuntime().freeMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);  &#x2F;&#x2F;系统的空闲空间</span><br><span class="line">System.out.println(&quot;total mem&#x3D;&quot; + Runtime.getRuntime().totalMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);</span><br></pre></td></tr></table></figure></div><p><a href="https://camo.githubusercontent.com/1225930990b2cf980c6acf943d630d1cdbd82798/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f62646437313764306133333934626537613733333736303035323737333337342d6e65772d696d61676533373162356435392d303032302d343039312d393837342d3630336330616230303733642e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/1225930990b2cf980c6acf943d630d1cdbd82798/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f62646437313764306133333934626537613733333736303035323737333337342d6e65772d696d61676533373162356435392d303032302d343039312d393837342d3630336330616230303733642e706e67" class="lazyload"></a></p><p>此时free memory就又缩水了，不过total memory是没有变化的。Java会尽可能将total mem的值维持在最小堆内存大小</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte[] b &#x3D; new byte[10 * 1024 * 1024];</span><br><span class="line">System.out.println(&quot;分配了10M空间给数组&quot;);</span><br><span class="line">System.out.println(&quot;Xmx&#x3D;&quot; + Runtime.getRuntime().maxMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);  &#x2F;&#x2F;系统的最大空间</span><br><span class="line">System.out.println(&quot;free mem&#x3D;&quot; + Runtime.getRuntime().freeMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);  &#x2F;&#x2F;系统的空闲空间</span><br><span class="line">System.out.println(&quot;total mem&#x3D;&quot; + Runtime.getRuntime().totalMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);  &#x2F;&#x2F;当前可用的总空间</span><br></pre></td></tr></table></figure></div><p><a href="https://camo.githubusercontent.com/1eea5da0254d2ebc0dc1af43082a0f4ae47bd0bc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f30666437353530616532313434616463613865643265646531326435666239362d6e65772d696d61676530633331666632302d323839642d343038382d386336372d6138343664306335643165302e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/1eea5da0254d2ebc0dc1af43082a0f4ae47bd0bc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f30666437353530616532313434616463613865643265646531326435666239362d6e65772d696d61676530633331666632302d323839642d343038382d386336372d6138343664306335643165302e706e67" class="lazyload"></a></p><p>这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total memory已经变成了15M，这就是已经申请了一次内存的结果。</p><p>此时我们再跑一下这个代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">System.out.println(&quot;Xmx&#x3D;&quot; + Runtime.getRuntime().maxMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);    &#x2F;&#x2F;系统的最大空间</span><br><span class="line">System.out.println(&quot;free mem&#x3D;&quot; + Runtime.getRuntime().freeMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);  &#x2F;&#x2F;系统的空闲空间</span><br><span class="line">System.out.println(&quot;total mem&#x3D;&quot; + Runtime.getRuntime().totalMemory() &#x2F; 1024.0 &#x2F; 1024 + &quot;M&quot;);  &#x2F;&#x2F;当前可用的总空间</span><br></pre></td></tr></table></figure></div><p><a href="https://camo.githubusercontent.com/279fdb13bff8b2970b9977f93091f2389c957a25/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f34636334346235643564316334306334383634306563653661323936623161632d6e65772d696d61676534623537626166362d303835622d343135302d396336302d6163353162306638313564372e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/279fdb13bff8b2970b9977f93091f2389c957a25/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f34636334346235643564316334306334383634306563653661323936623161632d6e65772d696d61676534623537626166362d303835622d343135302d396336302d6163353162306638313564372e706e67" class="lazyload"></a></p><p>此时我们手动执行了一次fullgc，此时total memory的内存空间又变回5.5M了，此时又是把申请的内存释放掉的结果。</p><h3 id="调整新生代和老年代的比值"><a href="#调整新生代和老年代的比值" class="headerlink" title="调整新生代和老年代的比值"></a>调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p><h3 id="调整Survivor区和Eden区的比值"><a href="#调整Survivor区和Eden区的比值" class="headerlink" title="调整Survivor区和Eden区的比值"></a>调整Survivor区和Eden区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个Survivor区和eden的比值</p><p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p><h3 id="设置年轻代和老年代的大小"><a href="#设置年轻代和老年代的大小" class="headerlink" title="设置年轻代和老年代的大小"></a>设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10</p><p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;你要输出的日志路径</span><br></pre></td></tr></table></figure></div><p>一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p><h3 id="永久区的设置"><a href="#永久区的设置" class="headerlink" title="永久区的设置"></a>永久区的设置</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize -XX:MaxPermSize</span><br></pre></td></tr></table></figure></div><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p><p>tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。</p><h3 id="JVM的栈参数调优"><a href="#JVM的栈参数调优" class="headerlink" title="JVM的栈参数调优"></a>JVM的栈参数调优</h3><h4 id="调整每个线程栈空间的大小"><a href="#调整每个线程栈空间的大小" class="headerlink" title="调整每个线程栈空间的大小"></a>调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p><h4 id="设置线程栈的大小"><a href="#设置线程栈的大小" class="headerlink" title="设置线程栈的大小"></a>设置线程栈的大小</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XXThreadStackSize：</span><br><span class="line">    设置线程栈的大小(0 means use default stack size)</span><br></pre></td></tr></table></figure></div><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了</p><h3 id="JVM其他参数介绍"><a href="#JVM其他参数介绍" class="headerlink" title="JVM其他参数介绍"></a>JVM其他参数介绍</h3><p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p><h4 id="设置垃圾最大年龄"><a href="#设置垃圾最大年龄" class="headerlink" title="设置垃圾最大年龄"></a>设置垃圾最大年龄</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold</span><br><span class="line">    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.</span><br><span class="line">    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,</span><br><span class="line">    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,</span><br><span class="line">    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</span><br></pre></td></tr></table></figure></div><h4 id="设置堆空间存活时间"><a href="#设置堆空间存活时间" class="headerlink" title="设置堆空间存活时间"></a>设置堆空间存活时间</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:SoftRefLRUPolicyMSPerMB</span><br><span class="line">    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。</span><br></pre></td></tr></table></figure></div><h4 id="设置对象直接分配在老年代"><a href="#设置对象直接分配在老年代" class="headerlink" title="设置对象直接分配在老年代"></a>设置对象直接分配在老年代</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PretenureSizeThreshold</span><br><span class="line">    设置对象超过多大时直接在老年代分配，默认值是0。</span><br></pre></td></tr></table></figure></div><h4 id="设置TLAB占eden区的比例"><a href="#设置TLAB占eden区的比例" class="headerlink" title="设置TLAB占eden区的比例"></a>设置TLAB占eden区的比例</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:TLABWasteTargetPercent</span><br><span class="line">    设置TLAB占eden区的百分比，默认值是1% 。</span><br></pre></td></tr></table></figure></div><h4 id="设置是否优先YGC"><a href="#设置是否优先YGC" class="headerlink" title="设置是否优先YGC"></a>设置是否优先YGC</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CollectGen0First</span><br><span class="line">    设置FullGC时是否先YGC，默认值是false。</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次jvm问题排查过程</title>
      <link href="/2020/07/15/6.%20JVM/%E4%B8%80%E6%AC%A1jvm%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/15/6.%20JVM/%E4%B8%80%E6%AC%A1jvm%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>年老代报警：内存占用95%以上，持续1分钟以上，只能重启tomcat server</p><p>语义报警：连续3次，间隔10秒，服务器没有响应</p><h1 id="2-信息收集"><a href="#2-信息收集" class="headerlink" title="2. 信息收集"></a>2. 信息收集</h1><p>访问日志：$TOMCAT_HOME/log/localhost_access_log.txt</p><p>gc日志：$TOMCAT_HOME/log/gc.log</p><p>应用日志：</p><p>heapdump：报警时收集</p><h1 id="3-分析与定位"><a href="#3-分析与定位" class="headerlink" title="3. 分析与定位"></a>3. 分析与定位</h1><h2 id="3-1-访问日志分析"><a href="#3-1-访问日志分析" class="headerlink" title="3.1 访问日志分析"></a>3.1 访问日志分析</h2><p>问题时间段内 耗时60秒以上的url大部分都是/client/account/overview/accountReport!reportJson.action</p><p>查看Struts配置，对应的Action类和方法是com.baidu.union.report.InitAccountReportAction.reportJson()</p><h2 id="3-2-gc日志分析"><a href="#3-2-gc日志分析" class="headerlink" title="3.2 gc日志分析"></a>3.2 gc日志分析</h2><p>![image-20201028095230949](/Users/hepeitan/Library/Application Support/typora-user-images/image-20201028095230949.png)</p><p>年老代无法回收，频繁发生CMS收集，被minor gc打断发生concurrent mode failure，转为串行收集。</p><p>初步结论：结合3.1、3.2占用内存较大的方法必然执行时间很长，是InitAccountReportAction.reportJson()导致了问题</p><h2 id="3-3-heapdump分析"><a href="#3-3-heapdump分析" class="headerlink" title="3.3 heapdump分析"></a>3.3 heapdump分析</h2><p>两个较大对象：ArrayList和byte[]，ArrayList的详细类型展开可以看到ArrayList&lt;HashMap&lt;String, Long&gt;&gt;</p><h2 id="3-4-应用日志"><a href="#3-4-应用日志" class="headerlink" title="3.4 应用日志"></a>3.4 应用日志</h2><p><strong>===============response head from doris======================================<br>ActualRecNum: 1385308800<br>TotalNum: 0<br>RecordSize: 187<br>StatusCode: 0<br>=================response head from doris====================================</strong></p><p><a href="http://wiki.baidu.com/pages/createpage.action?spaceKey=ecomop&title=ActualRecNum&linkCreation=true&fromPageId=104888992" target="_blank" rel="noopener">ActualRecNum</a>: 1385308800 这个返回数据量明显有问题</p><p>查看错误信息：</p><p>[work@yf-cloud04root]$ more root.log.2013-12-11-18|grep Exception<br><a href="http://java.net/" target="_blank" rel="noopener">java.net</a>.SocketException:Socket is closed<br><a href="http://java.net/" target="_blank" rel="noopener">java.net</a>.SocketException:Socket closed<br><a href="http://java.net/" target="_blank" rel="noopener">java.net</a>.SocketException:Broken pipe</p><p>貌似是多线程的问题，并发线程共享一个socket导致。</p><h2 id="3-5-查看代码"><a href="#3-5-查看代码" class="headerlink" title="3.5 查看代码"></a>3.5 查看代码</h2><p>根据3.3、3.4，问题可能出现在doris访问上，查看doris代码，getDortisData方法返回值ArrayList与Heapdump中4G对象相同</p><p><img alt="img" data-src="http://wiki.baidu.com/download/attachments/104888992/c381e12ac84f1353dbbc35fd48366347.png?version=1&modificationDate=1434457675847&api=v2" class="lazyload"></p><p>获取doris返回数据代码</p><p><img alt="img" data-src="http://wiki.baidu.com/download/attachments/104888992/de727ccf69245da0b0297274e59ae43f.png?version=1&modificationDate=1434457675849&api=v2" class="lazyload"></p><p>构造java对象代码</p><p><img alt="img" data-src="http://wiki.baidu.com/download/attachments/104888992/2d9d8d47d776fdea291172ab2f51e97d.png?version=1&modificationDate=1434457675858&api=v2" class="lazyload"></p><p>unionweb的doris客户端会根据返回数据的字节码位置解析返回数据大小、业务数据等信息，如果两个线程共享一个socket，</p><p>就会出现返回数据解析错误，比如ActualRecNum: 1385308800，这种问题。</p><h2 id="3-6-多线程问题分析"><a href="#3-6-多线程问题分析" class="headerlink" title="3.6 多线程问题分析"></a>3.6 多线程问题分析</h2><p>首先查看socket连接池的获取、回收方法，没有问题。</p><p>union-web使用SSH，经典的Action-Serivce-Dao三层结构，spring默认使用singliton管理bean，三层中有一个bean是共享的都可能导致这个问题。</p><p>使用btrace调试代码，发现问题发生在Service层，对象地址一样说明是同一个对象</p><h2 id="3-7-其他问题"><a href="#3-7-其他问题" class="headerlink" title="3.7 其他问题"></a>3.7 其他问题</h2><p>记录调试日志发现socket连接池可用连接一直是0，但是active却能达到max 100,</p><p>调试发现这段代码有问题</p><p>com.baidu.darwin.doris.driver.SocketDriver中</p><p>结合配置文件，代码中缺少正确创建socket跳出的机制，每次调用都会产生一个无法返回pool的socket</p><p>最终Pool通过_numActive计数到达max，但是仅有一个socket可用</p><h1 id="4-修复问题"><a href="#4-修复问题" class="headerlink" title="4. 修复问题"></a>4. 修复问题</h1><p>4.1 修改spring关于*Mgr *Dao的配置，添加注解，scope改为prototype</p><p>4.2 修改代码，socket正确创建则跳出循环</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列面试总结</title>
      <link href="/2020/05/19/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2020/05/19/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>网上Java的资料零零散散，甚至有一些错误，作者希望能结合自己的实际开发经验和面试经验，对Spring知识体系进行系统梳理。</p><p>本文参考主要【引用】中的内容，并结合自己的日常积累，欢迎留言交流指正。</p><h2 id="为什么使用消息队列？"><a href="#为什么使用消息队列？" class="headerlink" title="为什么使用消息队列？"></a><strong>为什么使用消息队列？</strong></h2><p>（1）<code>解耦</code>：可以在多个系统之间进行解耦，将原本通过网络之间的调用的方式改为使用MQ进行消息的异步通讯，只要该操作不是需要同步的，就可以改为使用MQ进行不同系统之间的联系，这样项目之间不会存在耦合，系统之间不会产生太大的影响，就算一个系统挂了，也只是消息挤压在MQ里面没人进行消费而已，不会对其他的系统产生影响。</p><p> <strong>我用线程，线程池去做不是一样的么？</strong></p><p>你一个订单流程，你扣积分，扣优惠券，发短信，扣库存。。。等等这么多业务要调用这么多的接口，<strong>每次加一个你要调用一个接口然后还要重新发布系统</strong>，而且加消息队列出问题易于分离定位.</p><p>（2）<code>异步</code>：加入一个操作设计到好几个步骤，这些步骤之间不需要同步完成，比如客户去创建了一个订单，还要去客户轨迹系统添加一条轨迹、去库存系统更新库存、去客户系统修改客户的状态等等。这样如果这个系统都直接进行调用，那么将会产生大量的时间，这样对于客户是无法接收的；并且像添加客户轨迹这种操作是不需要去同步操作的，如果使用MQ将客户创建订单时，将后面的轨迹、库存、状态等信息的更新全都放到MQ里面然后去异步操作，这样就可加快系统的访问速度，提供更好的客户体验。</p><p><strong>应用</strong>：发送邮件、短信、微信推送</p><p>（3）<code>削峰</code>：一个系统访问流量有高峰时期，也有低峰时期，比如说，中午整点有一个抢购活动等等。比如系统平时流量并不高，一秒钟只有100多个并发请求，系统处理没有任何压力，一切风平浪静，到了某个抢购活动时间，系统并发访问了剧增，比如达到了每秒5000个并发请求，而我们的系统每秒只能处理2000个请求，那么由于流量太大，我们的系统、数据库可能就会崩溃。这时如果使用MQ进行流量削峰，将用户的大量消息直接放到MQ里面，然后我们的系统去按自己的最大消费能力去消费这些消息，就可以保证系统的稳定，只是可能要跟进业务逻辑，给用户返回特定页面或者稍后通过其他方式通知其结果。</p><h2 id="技术选型？"><a href="#技术选型？" class="headerlink" title="技术选型？"></a>技术选型？</h2><ul><li><code>RabbitMQ</code></li></ul><p>==优点==</p><ol><li>支持多种语言、文档齐全；</li><li><strong>并发性能高</strong>，性能极其好，延时很低，达到微秒级；</li><li>管理界面 较丰富，在互联网公司也有较大规模的应用，社区活跃度高；</li><li>有很好的消息异常机制、消息确认机制、持久化机制，可靠性高。</li><li>如果 消息异常，RabbitMQ提供消息跟踪机制，使用者可以找出发生了什么；队列可以在集群中的机器上 进行镜像，以确保在硬件问题下还保证 消息安全；</li><li>管理界面较丰富，在互联网公司也有较大规模的应用，社区活跃度高。</li></ol><p>==缺点==</p><ol><li><p>基于 erlang 开发，很难进行二次定制开发</p></li><li><p>吞吐量方面虽然稍逊于 Kafka 和 RocketMQ</p></li></ol><p><code>RocketMQ</code></p><p>==优点==</p><ol><li><p>Java语言开发，代码我们可以直接阅读，便于二次开发</p><ol start="2"><li>吞吐量较好，支持千万级的吞吐量。</li><li>可用性高，支持分布式。<ol start="4"><li>支持分布式事务</li></ol></li></ol></li></ol><p>==缺点==</p><ol><li>支持的客户端语言 不多，目前是Java 及 C++，其中C++ 还不成熟；</li><li>RocketMQ 社区关注度及成熟度也不及前两者；</li><li>没有 Web 管理界面，提供了一个 CLI (命令行界面)     管理工具带来 查询、管理 和诊断各种问题；</li><li>没有在 MQ 核心里实现 JMS 等接口，有些系统要迁移需要修改大量代码；</li></ol><p><code>Kafka</code></p><p>==优点==</p><ol><li><p>但是提供超高的吞吐量，ms 级的延迟</p><ol start="2"><li>极高的可用性以及可靠性，而且分布式可以任意扩展。</li><li>如果是大数据领域的实时数据同步、实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题。</li></ol></li></ol><p>==缺点==</p><ol><li>重复消息。Kafka保证每条消息至少送达一次，虽然几率很小，但一条消息可能被送达多次。</li><li>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；</li><li>复杂性。Kafka需要Zookeeper的支持，Topic一般需要人工创建，部署和维护比一般MQ成本更高。</li></ol><p><code>ActiveMQ</code></p><p>==缺点==</p><p>  社区活跃度不及 RabbitMQ 高；</p><p>  根据其他用户反馈，会出莫名其妙的问题，会丢失消息；</p><p>  目前重心放到 activemq 6.0 产品 Apollo，对 5.x 的维护较少；</p><h2 id="业务场景落地"><a href="#业务场景落地" class="headerlink" title="业务场景落地"></a>业务场景落地</h2><p>在API模块，在接口正确返回时需要需要干几件事情：</p><ol><li>图像存储（耗时20ms）</li><li>扣减剩余次数（耗时100ms）</li><li>日志记录（耗时80ms）</li><li>接口统计（耗时50ms）</li><li>邮件发送（耗时几秒）。</li></ol><p><img alt="image-20200526134053813" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5srua1bjj30lf0cewh1.jpg" class="lazyload"></p><h3 id="那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？"><a href="#那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？" class="headerlink" title="那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？"></a>那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？</h3><p>问题是个好问题，但是没必要考虑，业务系统本身就是自己的开发人员维护的，你积分扣失败关我下单的什么事情？你管好自己下单系统的就好了。</p><p><strong>Tip</strong>：话是这么说，但是这其实是用了消息队列的一个缺点，涉及到<strong>分布式事务</strong>的知识点，把下单，优惠券，积分。。。都放在一个事务里面一样，要成功一起成功，要失败一起失败。</p><h2 id="集群崩溃-如何保证数据不丢失？"><a href="#集群崩溃-如何保证数据不丢失？" class="headerlink" title="集群崩溃,如何保证数据不丢失？"></a>集群崩溃,如何保证数据不丢失？</h2><h3 id="持久化队列"><a href="#持久化队列" class="headerlink" title="持久化队列"></a>持久化队列</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(name = <span class="string">"hello"</span>,durable = <span class="string">"true"</span>) )</span><br></pre></td></tr></table></figure></div><p>但是给hello队列做持久化，而hello1不做，并重启rabbitmq</p><p><img alt="img" data-src="https://images2017.cnblogs.com/blog/821560/201801/821560-20180104195009221-4259994.png" class="lazyload"></p><p>　　可以看到重启后，hello队列还在，hello1队列消失了，但是原本hello中的一条消息也没有保存下来。所以在这边我们仅仅做到了消息队列的持久化，还没有做消息持久化。</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>RabbitMQ遵循AMQP协议,使用RabbitTemplate 默认消息是持久化的，但只有在队列也是持久化时才有作用.RabbitMQ会将消息写入磁盘上的一个持久化日志文件</p><h2 id="正常消费-如何保障消息不会丢失"><a href="#正常消费-如何保障消息不会丢失" class="headerlink" title="正常消费,如何保障消息不会丢失"></a>正常消费,如何保障消息不会丢失</h2><h3 id="生产者端"><a href="#生产者端" class="headerlink" title="生产者端"></a>生产者端</h3><p>RabbitMQ 提供了两种可靠性的确认策略 Confrim / Transaction.</p><h4 id="Confrim"><a href="#Confrim" class="headerlink" title="Confrim"></a>Confrim</h4><p>异步确认模式:发送线程不会立即得到MQ反馈结果，发送后通过callback确认成功失败，类似线程池，效率高</p><p>发送线程：由于是异步确认模式，当RabbitMQ Server突然失联，发送线程仍会继续发送多条消息，之后发现链接断开，抛出异常</p><p>假设RabbitMQ Server 接收500挂掉</p><p> 发送线程：700 </p><p> 实际接收 RabbitMQ Server：500</p><p> callback线程 失败：200（预期 未具体测试）</p><p>缺点：发送线程认为已经发送成功，但是却失败了，反馈结果只能通callback获得，多线程问题，如未处理callback，则消息丢失</p><p>优点：性能好</p><p>消息确认模式在SpringBoot中的使用:<a href="https://blog.csdn.net/ABIGJUN/article/details/93385838" target="_blank" rel="noopener">https://blog.csdn.net/ABIGJUN/article/details/93385838</a></p><h4 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h4><p>事务确认模式:</p><p>发送线程会立即得到MQ反馈结果，同一线程中，多个发送阻塞进行，同db Transaction一样支持失败回滚等，效率高</p><p>发送线程：由于是事务确认模式，当RabbitMQ Server突然失联，发送线程得不到当前正在发送消息的回执，直接抛出异常</p><p>假设RabbitMQ Server 接收500挂掉</p><p> 发送线程：500</p><p> 实际接收 RabbitMQ Server：500</p><p>缺点：同步发送，逐条确认，效率低</p><p>优点：同步发送，发送线程可以立即得到反馈结果，对于主线程消息不丢失</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>RabbitMQ遵循AMQP协议,使用RabbitTemplate 默认消息是持久化的，但只有在队列也是持久化时才有作用.RabbitMQ会将消息写入磁盘上的一个持久化日志文件.</p><p>自定义的Rabbit工具类,发送消息的时候将deliveryMode=2</p><h3 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h3><p>关闭自动确认机制,设置消息的ack,当消费者消费一个消息的时候,会返回给rabbitmq对应queue一个ack消息,这样就保证了消息消费完成.</p><hr><h2 id="如何保证消息的幂等性"><a href="#如何保证消息的幂等性" class="headerlink" title="如何保证消息的幂等性"></a>如何保证消息的幂等性</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景:"></a>场景:</h3><p>一般消息队列的使用，我们都是有<strong>重试机制</strong>的，就是说我下游的业务发生异常了，我会抛出异常并且要求你<strong>重新发一次</strong>。</p><p>我这个活动这里发生错误，你要求重发肯定没问题。但是大家<strong>仔细想一下</strong>问题在哪里？</p><p>是的，不止你一个人监听这个消息啊，<strong>还有别的服务也在监听</strong>，他们也会失败啊，他一失败他也要求重发，但是你这里其实是成功的，重发了，你的钱不就加了两次了？</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在<code>消息生产</code>时，MQ<strong>内部</strong>针对每条生产者发送的消息生成一个唯一，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；<br>在<code>消息消费</code>时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重的依据，避免同一条消息被重复消费。</p><p>这个问题针对业务场景来答分以下几点：</p><p>1.比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</p><p>2.再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</p><p>3.如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p><h2 id="如何保证消费顺序性"><a href="#如何保证消费顺序性" class="headerlink" title="如何保证消费顺序性"></a>如何保证消费顺序性</h2><h3 id="场景1-多个consumer"><a href="#场景1-多个consumer" class="headerlink" title="场景1:多个consumer"></a>场景1:多个consumer</h3><p>一个queue，多个consumer，这不明显乱了,如下代码:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(name = <span class="string">"work"</span>) )</span><br><span class="line">    <span class="comment">// @RabbitHandler // 不需要此注解了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"receiver1："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(name = <span class="string">"work"</span>) )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"receiver2："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>生产者根据商品ID计算出hash值,对队列数取余,就可以让相同id会压到同一队列;拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理.</p><p><img alt="image-20200526161706292" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5xacwb7rj30a60e9t92.jpg" class="lazyload"></p><h3 id="场景2-多线程"><a href="#场景2-多线程" class="headerlink" title="场景2:多线程"></a>场景2:多线程</h3><p><img alt="image-20200526213155996" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf66dx0l6ij30wy0ahacg.jpg" class="lazyload"></p><hr><h2 id="有几百万消息持续积压几小时，说说怎么解决？"><a href="#有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="有几百万消息持续积压几小时，说说怎么解决？"></a>有几百万消息持续积压几小时，说说怎么解决？</h2><h3 id="场景1-大量消息在-mq-里积压了几个小时了还没解决"><a href="#场景1-大量消息在-mq-里积压了几个小时了还没解决" class="headerlink" title="场景1:大量消息在 mq 里积压了几个小时了还没解决"></a>场景1:大量消息在 mq 里积压了几个小时了还没解决</h3><p><code>现象</code></p><p>你看这问法，其实本质针对的场景，都是说可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？</p><p><code>解决</code></p><p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</p><p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p><ul><li><strong>先修复 consumer</strong> 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li><li>新建一个 topic，partition 是原来的 10 倍，<strong>临时建立好原先 10 倍的 queue 数量</strong>。</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询<strong>写入临时建立好的 10 倍数量的 queue</strong>。</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。==这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。==</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li></ul><h3 id="场景2-mq-中的消息过期失效了"><a href="#场景2-mq-中的消息过期失效了" class="headerlink" title="场景2:mq 中的消息过期失效了"></a>场景2:mq 中的消息过期失效了</h3><p><code>现象:</code></p><p>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是<strong>大量的数据会直接搞丢</strong>。</p><p><code>解决</code></p><p>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p><p>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p><h3 id="场景3-mq-都快写满了"><a href="#场景3-mq-都快写满了" class="headerlink" title="场景3:mq 都快写满了"></a>场景3:mq 都快写满了</h3><p>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，<strong>消费一个丢弃一个，都不要了</strong>，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="死信队列和延迟队列的使用"><a href="#死信队列和延迟队列的使用" class="headerlink" title="死信队列和延迟队列的使用"></a>死信队列和延迟队列的使用</h3><p><strong>死信消息：</strong></p><ol><li>消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false</li><li>消息过期了</li><li>队列达到最大的长度</li></ol><p><strong>过期消息：</strong></p><p>​        在 rabbitmq 中存在2种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个 死信 消息。</p><p><strong>队列设置</strong>：在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒</p><p><strong>单个消息设置</strong>：是设置消息属性的 expiration 参数的值，单位为 毫秒</p><p><code>延时队列</code>：在rabbitmq中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。</p><p><strong>有了以上的基础知识，我们完成以下需求：</strong></p><p>需求：用户在系统中创建一个订单，如果超过时间用户没有进行支付，那么自动取消订单。</p><p>分析：</p><p>​    1、上面这个情况，我们就适合使用延时队列来实现，那么延时队列如何创建</p><p>​    2、延时队列可以由 过期消息+死信队列 来时间</p><p>​    3、过期消息通过队列中设置 x-message-ttl 参数实现</p><p>​    4、死信队列通过在队列申明时，给队列设置 x-dead-letter-exchange 参数，然后另外申明一个队列绑定x-dead-letter-exchange对应的交换器。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory(); </span><br><span class="line">factory.setHost(<span class="string">"127.0.0.1"</span>); </span><br><span class="line">factory.setPort(AMQP.PROTOCOL.PORT); </span><br><span class="line">factory.setUsername(<span class="string">"guest"</span>); </span><br><span class="line">factory.setPassword(<span class="string">"guest"</span>); </span><br><span class="line">Connection connection = factory.newConnection(); </span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 声明一个接收被删除的消息的交换机和队列 </span></span><br><span class="line">String EXCHANGE_DEAD_NAME = <span class="string">"exchange.dead"</span>; </span><br><span class="line">String QUEUE_DEAD_NAME = <span class="string">"queue_dead"</span>; </span><br><span class="line">channel.exchangeDeclare(EXCHANGE_DEAD_NAME, BuiltinExchangeType.DIRECT); </span><br><span class="line">channel.queueDeclare(QUEUE_DEAD_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>); </span><br><span class="line">channel.queueBind(QUEUE_DEAD_NAME, EXCHANGE_DEAD_NAME, <span class="string">"routingkey.dead"</span>); </span><br><span class="line"> </span><br><span class="line">String EXCHANGE_NAME = <span class="string">"exchange.fanout"</span>; </span><br><span class="line">String QUEUE_NAME = <span class="string">"queue_name"</span>; </span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); </span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(); </span><br><span class="line"><span class="comment">// 统一设置队列中的所有消息的过期时间 </span></span><br><span class="line">arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">30000</span>); </span><br><span class="line"><span class="comment">// 设置超过多少毫秒没有消费者来访问队列，就删除队列的时间 </span></span><br><span class="line">arguments.put(<span class="string">"x-expires"</span>, <span class="number">20000</span>); </span><br><span class="line"><span class="comment">// 设置队列的最新的N条消息，如果超过N条，前面的消息将从队列中移除掉 </span></span><br><span class="line">arguments.put(<span class="string">"x-max-length"</span>, <span class="number">4</span>); </span><br><span class="line"><span class="comment">// 设置队列的内容的最大空间，超过该阈值就删除之前的消息</span></span><br><span class="line">arguments.put(<span class="string">"x-max-length-bytes"</span>, <span class="number">1024</span>); </span><br><span class="line"><span class="comment">// 将删除的消息推送到指定的交换机，一般x-dead-letter-exchange和x-dead-letter-routing-key需要同时设置</span></span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"exchange.dead"</span>); </span><br><span class="line"><span class="comment">// 将删除的消息推送到指定的交换机对应的路由键 </span></span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"routingkey.dead"</span>); </span><br><span class="line"><span class="comment">// 设置消息的优先级，优先级大的优先被消费 </span></span><br><span class="line">arguments.put(<span class="string">"x-max-priority"</span>, <span class="number">10</span>); </span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments); </span><br><span class="line">channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>); </span><br><span class="line">String message = <span class="string">"Hello RabbitMQ: "</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123; </span><br><span class="line"><span class="comment">// expiration: 设置单条消息的过期时间 </span></span><br><span class="line">AMQP.BasicProperties.Builder properties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">.priority(i).expiration( i * <span class="number">1000</span> + <span class="string">""</span>); </span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, properties.build(), (message + i).getBytes(<span class="string">"UTF-8"</span>)); </span><br><span class="line">&#125; </span><br><span class="line">channel.close(); </span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></div><hr><h3 id="rabbitmq的镜像集群-后续拓展"><a href="#rabbitmq的镜像集群-后续拓展" class="headerlink" title="rabbitmq的镜像集群(后续拓展)"></a>rabbitmq的镜像集群(后续拓展)</h3><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会<strong>存在于多个实例上</strong>，就是说，每个 RabbitMQ 节点都有这个 queue 的一个<strong>完整镜像</strong>，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把<strong>消息同步</strong>到多个实例的 queue 上。</p><p><img alt="image-20200526162823922" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5xm3e7j6j30hf0cgmxi.jpg" class="lazyload"></p><p>那么<strong>如何开启这个镜像集群模式</strong>呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是<strong>镜像集群模式的策略</strong>，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就<strong>没有扩展性可言</strong>了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并<strong>没有办法线性扩展</strong>你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</p><h3 id="RocketMQ入门"><a href="#RocketMQ入门" class="headerlink" title="RocketMQ入门"></a>RocketMQ入门</h3><p><a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/mq/RocketMQ.md" target="_blank" rel="noopener">https://github.com/AobingJava/JavaFamily/blob/master/docs/mq/RocketMQ.md</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring技术总结</title>
      <link href="/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>网上Java的资料零零散散，甚至有一些错误，作者希望能结合自己的实际开发经验和面试经验，对Spring知识体系进行系统梳理。</p><p>本文参考主要【引用】中的内容，并结合自己的日常积累，欢迎留言交流指正。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p><strong>注：本文主要参考</strong></p></li><li><p>链接：<a href="https://www.jianshu.com/p/e1848e2aa7c3" target="_blank" rel="noopener">https://www.jianshu.com/p/e1848e2aa7c3</a></p></li></ul><h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h2><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：<a href="https://spring.io/。" target="_blank" rel="noopener">https://spring.io/。</a></p><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p><p>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p><ul><li>IOC/DI（控制反转，Dependency Injection，依赖注入）</li><li>AOP（Aspect Oriented Programming，面向切面编程）</li></ul><h2 id="列举一些重要的Spring模块？"><a href="#列举一些重要的Spring模块？" class="headerlink" title="列举一些重要的Spring模块？"></a>列举一些重要的Spring模块？</h2><p>下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p><img alt="image-20200512174528926" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gept5vphtlj30fe0b6tcu.jpg" class="lazyload"></p><ul><li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IOC 依赖注入功能。</li><li><strong>Spring Aspects</strong> ：该模块为与AspectJ的集成提供支持。</li><li><strong>Spring AOP</strong> ：提供了面向方面的编程实现。</li><li><strong>Spring JDBC</strong> : Java数据库连接。</li><li><strong>Spring JMS</strong> ：Java消息服务。</li><li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li><li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li><li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li></ul><h2 id="Spring-创建对象的三种方式"><a href="#Spring-创建对象的三种方式" class="headerlink" title="Spring 创建对象的三种方式"></a>Spring 创建对象的三种方式</h2><h3 id="通过构造方法创建"><a href="#通过构造方法创建" class="headerlink" title="通过构造方法创建"></a>通过构造方法创建</h3><p>无参构造创建:默认情况.</p><p>有参构造创建:需要明确配置</p><p>需要在类中提供有参构造方法</p><p>在 applicationContext.xml 中设置调用哪个构造方法创建对象</p><p>如果设定的条件匹配多个构造方法执行最后的构造方法</p><p> index : 参数的索引,从 0 开始</p><p>name: 参数名</p><p>type:类型(区分开关键字和封装类 int 和Integer)</p><p><img alt="&lt;bean id— &quot;peo&quot;  refi}l bean  String  value  &lt;constructor-arg index=&quot;O&quot; name= &quot;id&quot; type=&quot;int&quot;  value= &quot;123  &lt;constructor-arg &quot; name= &quot;name&quot;  type= &quot;java. lang.String &quot; value= &quot; " data-src="file:////Users/hepeitan/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/1F1E534F-4653-F642-94E2-2161574E0DB5.png" class="lazyload"></p><h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><p>工厂设计模式:帮助创建类对象.一个工厂可以生产多个对象.</p><p>实例工厂:需要先创建工厂,才能生产对象</p><p>实现步骤:必须要有一个实例工厂</p><p><img alt="mau  aldoad 3!lqnd  } ,AucnoeFldoad ssep 3!lqnd " data-src="file:////Users/hepeitan/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/A5CFC417-F152-684B-82FE-FF22186B2533.png" class="lazyload"></p><p>在 applicationContext.xml 中配置工厂对象和需要创建的对象</p><p><img alt="&lt; ea &quot;  class &quot;com.bjsxt.pojo.PeopLeFactory&quot;&gt;&lt;/—  &lt;bean  id— &quot;peol &quot;  factory-bean  &quot;factory &quot;  factory- method— &quot;newrnstance &quot; bean &gt; " data-src="file:////Users/hepeitan/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/029DC20C-769F-8D49-8739-3E4C68781972.png" class="lazyload"></p><h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><p>不需要创建工厂,快速创建对象.</p><p>实现步骤：</p><p>编写一个静态工厂(在方法上添加static)</p><p><img alt="mau  aldoad 311as 3!lqnd  } ,AucnoeFldoad ssep 3!lqnd " data-src="file:////Users/hepeitan/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/853A1076-8F63-9E46-BEE5-618B18F86FBB.png" class="lazyload"></p><p>在applicationContext.xml 中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo2"</span> <span class="attr">class</span>=<span class="string">"com.bjsxt.pojo.PeopleFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h2 id="谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="谈谈自己对于 Spring IoC 和 AOP 的理解"></a>谈谈自己对于 Spring IoC 和 AOP 的理解</h2><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p><p>IoC 完成的事情原先由程序员主动通过 new 实例化对象事情,转交给 Spring 负责. </p><p>IoC 最大的作用:<code>解耦</code>. 程序员不需要管理对象.解除了对象管理和程序员之间的耦合.</p><p>DI：当一个类(A)中需要依赖另一个类()对象时,把 B 赋值给 A 的过程就叫做依赖注入. </p><p><strong>Spring IOC的初始化过程：</strong> </p><p><img alt="image-20200512175046188" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1geptbathsuj30jo01gwek.jpg" class="lazyload"></p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img alt="image-20200512202505951" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepxruoqm3j30jx09r76q.jpg" class="lazyload"></p><p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p><h2 id="动态代理原理"><a href="#动态代理原理" class="headerlink" title="动态代理原理"></a>动态代理原理</h2><p>静态代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。</p><p>每一个类都需要创建代理对象会很麻烦，而动态代理就是在运行时通过反射机制动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为。</p><h3 id="Java-SDK代理与cglib代理比较"><a href="#Java-SDK代理与cglib代理比较" class="headerlink" title="Java SDK代理与cglib代理比较"></a>Java SDK代理与cglib代理比较</h3><p><code>JDK代理</code>面向的是一组接口，它为这些接口动态创建了一个实现类。</p><p><code>cglib代理</code>面向的是一个具体的类，它动态创建了一个新类，继承了该类，重写了其方法。</p><p><code>JDK代理</code>的是对象，需要先有一个实际对象，自定义的InvocationHandler引用该对象，然后创建一个代理类和代理对象，客户端访问的是代理对象，代理对象最后再调用实际对象的方法。</p><p><code>cglib代理</code>的是类，创建的对象只有一个。</p><p>如果目的都是为一个类的方法增强功能，Java SDK要求该类必须有接口，且只能处理接口中的方法，cglib没有这个限制。</p><h2 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h2><p>Spring定义了多种Bean作用域，可以基于这些作用域创建bean，包括：</p><ul><li><strong>单例</strong>（Singleton）：在整个应用中，只创建bean的一个实例。</li><li><strong>原型</strong>（Prototype）：多例,每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li><li><strong>会话</strong>（Session）：在Web应用中，为每个会话创建一个bean实例。</li><li><strong>请求</strong>（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li></ul><p>在代码里看起来是这样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIsBean</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></div><p>XML版本：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"BEANID"</span> <span class="attr">class</span> = <span class="string">"net.itxm.beans"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>在默认情况下，Spring应用上下文中所有bean都是作为以<code>单例</code>（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。</p><p>在大多数情况下，单例bean是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p><h5 id="scope-属性"><a href="#scope-属性" class="headerlink" title="scope 属性"></a>scope 属性</h5><ol><li><bean>的属性</bean></li><li>作用:控制对象有效范围(单例,多例等)</li><li><bean>标签对应的对象默认是单例的.无论获取多少次,都是同一个对象</bean></li><li>scope 可取值</li></ol><ul><li>singleton 默认值,单例</li><li>prototype 多例,每次获取重新实例化</li><li>request 每次请求重新实例化</li><li>session      每个会话对象内,对象是单例的.</li><li>application      在application 对象内是单例</li><li>global    session  spring推 出 的 , 依 赖 于spring-webmvc-portle类似于session</li></ul><h2 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p><ul><li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中。</li></ul><h2 id="Spring-中的-bean-生命周期（ioc加载过程）"><a href="#Spring-中的-bean-生命周期（ioc加载过程）" class="headerlink" title="Spring 中的 bean 生命周期（ioc加载过程）?"></a>Spring 中的 bean 生命周期（ioc加载过程）?</h2><p>1、扫描Spring配置文件，根据标签的解析结果生成beanDefinition，并将所有的bd存放在map中。</p><p>2、遍历map，对beanDefinition进行validate校验，包括bean作用域、是不是懒加载的。</p><p>3、得到bean所对应的class对象，推断构造方法。</p><p>4、通过反射实例化这个对象</p><p>5、提前暴露一个Bean工厂将BeanFactory容器实例传入</p><p>6、填充属性–自动注入</p><p>7、Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean</p><ul><li>如果bean实现了<code>BeanNameAware</code>接口，Spring将bean的ID传递给<strong>setBean-Name()</strong>方法；</li><li>如果bean实现了<code>BeanFactoryAware</code>接口，Spring将调用<strong>setBeanFactory()</strong>方法，将BeanFactory容器实例传入；</li><li>如果bean实现了<code>ApplicationContextAware</code>接口，Spring将调用<strong>setApplicationContext()</strong>方法，将bean所在的应用上下文的引用传入进来；</li></ul><p>8、BeanPostProcessor：前置方法-aop</p><p>9、InitializingBean和init-method：执行我们自己定义的初始化方法</p><p>10、BeanPostProcessor：后置方法-aop</p><p>11、将Bean放到单例池中</p><p>12、使用</p><p>13、destroy：bean的销毁</p><h2 id="Spring循环依赖能否启动成功？"><a href="#Spring循环依赖能否启动成功？" class="headerlink" title="Spring循环依赖能否启动成功？"></a>Spring循环依赖能否启动成功？</h2><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a><strong>三级缓存</strong></h3><ul><li>Spring能够轻松的解决属性的循环依赖正式用到了三级缓存，在AbstractBeanFactory中有详细的注释。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**一级缓存，用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**二级缓存 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**三级缓存 存放 bean 工厂对象，用于解决循环依赖*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></div><ul><li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。</li><li>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean</li><li>三级缓存：singletonFactories，三级缓存，存放实例化完成的Bean工厂。</li><li>创建bean的时候Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取，如果还是获取不到就从三级缓存singletonFactories中取（Bean调用构造函数进行实例化后，即使属性还未填充，就可以通过三级缓存向外提前暴露依赖的引用值（提前曝光），根据对象引用能定位到堆中的对象，其原理是基于Java的引用传递），取到后从三级缓存移动到了二级缓存完全初始化之后将自己放入到一级缓存中供其他使用。</li></ul><h3 id="单例Bean"><a href="#单例Bean" class="headerlink" title="单例Bean"></a>单例Bean</h3><p>可以<strong>启动成功</strong>，Spring利用三级缓存，在实例化一个bean的时候，是首先递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性。</p><h3 id="为什么Spring不能解决构造器的循环依赖？"><a href="#为什么Spring不能解决构造器的循环依赖？" class="headerlink" title="为什么Spring不能解决构造器的循环依赖？"></a>为什么Spring不能解决构造器的循环依赖？</h3><p>因为加入singletonFactories三级缓存的前提是执行了构造器，在Bean调用构造器实例化之前，一二三级缓存并没有Bean的任何相关信息，在实例化之后才放入三级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。</p><p><code>构造器循环依赖解决办法：</code>在构造函数中使用@Lazy注解延迟加载。在注入依赖时，先注入代理对象，当首次使用时再创建对象说明：一种互斥的关系而非层次递进的关系，故称为三个Map而非三级缓存的缘由 完成注入；</p><h3 id="为什么多实例Bean不能解决循环依赖？"><a href="#为什么多实例Bean不能解决循环依赖？" class="headerlink" title="为什么多实例Bean不能解决循环依赖？"></a>为什么多实例Bean不能解决循环依赖？</h3><p>多实例Bean是每次创建都会调用doGetBean方法，而不是去缓存里面找，根本没有使用一二三级缓存，肯定不能解决循环依赖。</p><h2 id="Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？"><a href="#Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？" class="headerlink" title="Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？"></a>Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？</h2><p><a href="https://blog.csdn.net/zgmzyr/article/details/39380477" target="_blank" rel="noopener">https://blog.csdn.net/zgmzyr/article/details/39380477</a></p><p>spring启动时有id或name优先按id或name进行注入，没有按class进行注入</p><p>spring对<code>同一配置文件</code>中相同<strong>id或者name</strong>的两个或以上的bean时，做直接抛异常的处理，而对<code>不同配置文件</code>中相同id或者名称的bean，只会在打印日志级别为info的信息，信息内容大概为”Overriding bean definition for bean xxx : replacing xxx with beanDefinition “.</p><p>那么最终spring容器只会实例化后面的这个bean，后者将前者覆盖了。这种情况下，要排查问题很困难。</p><p>那么如何解决这个问题呢?靠程序员自律？绝对不定义重复名称的bean？我觉得这个是非常不靠谱的,因为项目依赖可能比较复杂,开发人员不尽相同.所以我认为只有通过在程序中引入一种报错机制才能解决这个问题。</p><p>上次在调试spring源代码时，无意中发现DefaultListableBeanFactory类有一个<code>allowBeanDefinitionOverriding</code>属性,其默认值为true.</p><p>想到只要将其值更改为false时就可能可以解决上面的问题，即存在id或者name相同的bean时，不是打印出相关信息，而是直接抛异常，这样就可以迫使开发人员必须解决id或者name重复的问题后才能成功启动容器。</p><h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">《面试官:“谈谈Spring中都用到了那些设计模式?”。》</a> 。</p><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等</li><li><strong>装饰器模式</strong>： 依赖注入就需要使用BeanWrapper。</li><li><strong>策略模式</strong>： Bean的实例化的时候决定采用何种方式初始化bean实例</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。Advice（通知）的类型有：BeforeAdvice、AfterReturningAdvice、ThrowSadvice 等。每个类型 Advice（通知）都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。Spring 需要将每个 Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对 Advice 进行转换。</li><li>……</li></ul><h2 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些?"></a>将一个类声明为Spring的 bean 的注解有哪些?</h2><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code>注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于拿个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h2 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h2><h3 id="AOP-主要应用场景有："><a href="#AOP-主要应用场景有：" class="headerlink" title="AOP 主要应用场景有："></a><strong>AOP 主要应用场景有：</strong></h3><ul><li>记录日志</li><li>监控性能</li><li>权限控制</li><li>事务管理</li></ul><h3 id="AOP使用哪种动态代理"><a href="#AOP使用哪种动态代理" class="headerlink" title="AOP使用哪种动态代理?"></a><strong>AOP使用哪种动态代理?</strong></h3><ul><li>当bean的是实现中存在接口或者是Proxy的子类，—jdk动态代理；不存在接口，spring会采用CGLIB来生成代理对象；</li><li>JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。</li><li>Proxy 利用 InvocationHandler（定义横切逻辑） 接口动态创建 目标类的代理对象。</li></ul><h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a><strong>jdk动态代理</strong></h3><ul><li>通过bind方法建立代理与真实对象关系，通过Proxy.newProxyInstance（target）生成代理对象</li><li>代理对象通过反射invoke方法实现调用真实对象的方法</li></ul><h3 id="动态代理与静态代理区别"><a href="#动态代理与静态代理区别" class="headerlink" title="动态代理与静态代理区别"></a><strong>动态代理与静态代理区别</strong></h3><ul><li>静态代理，程序运行前代理类的.class文件就存在了；</li><li>动态代理：在程序运行时利用反射动态创建代理对象&lt;复用性，易用性，更加集中都调用invoke&gt;</li></ul><h3 id="CGLIB与JDK动态代理区别"><a href="#CGLIB与JDK动态代理区别" class="headerlink" title="CGLIB与JDK动态代理区别"></a><strong>CGLIB与JDK动态代理区别</strong></h3><ul><li>Jdk必须提供接口才能使用；</li><li>CGLIB不需要，只要一个非抽象类就能实现动态代理</li></ul><h2 id="SpringMVC-工作原理了解吗"><a href="#SpringMVC-工作原理了解吗" class="headerlink" title="SpringMVC 工作原理了解吗?"></a>SpringMVC 工作原理了解吗?</h2><h3 id="SpringMVC中重要组件"><a href="#SpringMVC中重要组件" class="headerlink" title="SpringMVC中重要组件"></a>SpringMVC中重要组件</h3><ol><li>DispatcherServlet : 前端控制器,接收所有请求(如果配置@WebServlte(“/“)     不包含jsp) </li><li>HandlerMapping:     解析请求格式的.判断希望要执行哪个具体的方法. </li><li>HandlerAdapter: 负责调用具体的方法. </li><li>ViewResovler:视图解析器.解析结果,准备跳转到具体的物理视图</li></ol><h3 id="SpringMVC请求流程"><a href="#SpringMVC请求流程" class="headerlink" title="SpringMVC请求流程"></a>SpringMVC请求流程</h3><p><img alt="image-20200512213852945" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepzwm3m0sj30sf0bxaf4.jpg" class="lazyload"></p><p><img alt="0shrwj.png" data-src="https://s1.ax1x.com/2020/10/10/0shrwj.png" class="lazyload"> </p><p>参考： </p><p><a href="https://www.cnblogs.com/sunniest/p/4555801.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunniest/p/4555801.html</a></p><h2 id="介绍一下-SpringBootApplication注解"><a href="#介绍一下-SpringBootApplication注解" class="headerlink" title="介绍一下@SpringBootApplication注解"></a>介绍一下@SpringBootApplication注解</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure;</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters &#x3D; &#123;</span><br><span class="line">@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line">@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line">package org.springframework.boot;</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>可以看出大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>注解的集合。根据 SpringBoot官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的bean，注解默认会扫描该类所在的包下所有的类。</li><li><code>@Configuration</code>：允许在上下文中注册额外的bean或导入其他配置类</li></ul><h2 id="SpringBoot-的自动配置是如何实现的"><a href="#SpringBoot-的自动配置是如何实现的" class="headerlink" title="SpringBoot 的自动配置是如何实现的?"></a>SpringBoot 的自动配置是如何实现的?</h2><ul><li>@EnableAutoConfiguration找到META-INF/spring.factories（需要创建的bean在里面）配置文件</li><li>读取每个starter中的spring.factories文件，将配置的所有EnableAutoConﬁguration的值加入到了容器中；</li><li>根据Condition注解判断其中的类是否需要加载</li><li>将要加载的类通过Configration进行加载，利用@ConfigerationProperties注解，将配置文件中的信息加载进来。</li></ul><p><code>@EnableAutoConfiguration</code>是启动自动配置的关键，源码如下(建议自己打断点调试，走一遍基本的流程)：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>以WebSecurityEnablerConfiguration为例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(WebSecurityConfigurerAdapter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">name</span> </span>= BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityEnablerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>WebSecurityEnablerConfiguration</code>类中使用<code>@ConditionalOnBean</code>指定了容器中必须还有<code>WebSecurityConfigurerAdapter</code> 类或其实现类。所以，一般情况下 Spring Security 配置类都会去实现 <code>WebSecurityConfigurerAdapter</code>，这样自动将配置就完成了。</p><p>更多内容可以参考这篇文章：<a href="https://sylvanassun.github.io/2018/01/08/2018-01-08-spring_boot_auto_configure/" target="_blank" rel="noopener">https://sylvanassun.github.io/2018/01/08/2018-01-08-spring_boot_auto_configure/</a></p><h2 id="SpringBoot启动流程（敖丙）"><a href="#SpringBoot启动流程（敖丙）" class="headerlink" title="SpringBoot启动流程（敖丙）"></a>SpringBoot启动流程（敖丙）</h2><ul><li><p>new springApplication对象，利用spi机制加载applicationContextInitializer， applicationLister接口实例（META-INF/spring.factories）；</p></li><li><p>调run方法准备Environment，加载应用上下文（applicationContext），发布事件 很多通过lister实现</p></li><li><p>创建spring容器， refreshContext（） ，实现starter自动化配置，spring.factories文件加载， bean实例化</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring 技术内幕》</li><li><a href="http://www.cnblogs.com/wmyskxz/p/8820371.html" target="_blank" rel="noopener">http://www.cnblogs.com/wmyskxz/p/8820371.html</a></li><li><a href="https://www.journaldev.com/2696/spring-interview-questions-and-answers" target="_blank" rel="noopener">https://www.journaldev.com/2696/spring-interview-questions-and-answers</a></li><li><a href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/" target="_blank" rel="noopener">https://www.edureka.co/blog/interview-questions/spring-interview-questions/</a></li><li><a href="https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/" target="_blank" rel="noopener">https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/</a></li><li><a href="http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/" target="_blank" rel="noopener">http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/</a></li><li><a href="https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired" target="_blank" rel="noopener">https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务全知道</title>
      <link href="/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1%E5%85%A8%E7%9F%A5%E9%81%93/"/>
      <url>/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E4%BA%8B%E5%8A%A1%E5%85%A8%E7%9F%A5%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p><em>Guide 哥：大家应该都能背上面这句话了，下面我结合我们日常的真实开发来谈一谈。</em></p><p>我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 <code>savePerson()</code>方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，要不就都不执行。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void savePerson() &#123;</span><br><span class="line"> personDao.save(person);</span><br><span class="line"> personDetailDao.save(personDetail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另外，需要格外注意的是：<strong>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的<code>innodb</code>引擎。但是，如果把数据库引擎变为 <code>myisam</code>，那么程序也就不再支持事务了！</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdersService</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrdersDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED,</span><br><span class="line">                isolation = Isolation.DEFAULT, readOnly = <span class="keyword">false</span>, timeout = -<span class="number">1</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小红账户多1000</span></span><br><span class="line">  accountDao.addMoney(<span class="number">1000</span>,xiaohong);</span><br><span class="line">  <span class="comment">//模拟突然出现的异常，比如银行中可能为突然停电等等</span></span><br><span class="line">    <span class="comment">//如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//小王账户少1000</span></span><br><span class="line">  accountDao.reduceMoney(<span class="number">1000</span>,xiaoming);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另外，数据库事务的 ACID 四大特性是事务的基础，下面简单来了解一下。</p><h2 id="事物的特性（ACID）了解么"><a href="#事物的特性（ACID）了解么" class="headerlink" title="事物的特性（ACID）了解么?"></a>事物的特性（ACID）了解么?</h2><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TxIvneY939LqG6hdevkph67hKSibNrTR1R9db2OPlDVyTgojcMO33PSRRx9kOeHViaVDsqbia2LnZ5mw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><ul><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事务所干扰也就是说多个事务并发执行时，一个事务的执行不应影响其他事务的执行；</li><li><strong>持久性:</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p>​        ==事务的ACID是通过InnoDB日志和锁来保证。事务的<strong>隔离性</strong>是通过<u>数据库锁</u>的机制实现的，<strong>持久性</strong>通过<u>redo log</u>（重做日志）来实现，<strong>原子性和一致性</strong>通过回滚日志<u>Undo log</u>来实现。==</p><p>​        <code>UndoLog的原理</code>很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。 和Undo Log相反，<code>RedoLog记录</code>的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。 </p><h2 id="事务隔离级别（isolation）"><a href="#事务隔离级别（isolation）" class="headerlink" title="事务隔离级别（isolation）"></a>事务隔离级别（isolation）</h2><p>  在多线程或并发访问下如何保证访问到的数据具有完整性的？</p><p>  A）脏读: 修改时允许读取</p><p>  B)  不可重复读: 读取时允许修改,一次事务读取不一致</p><p>  C)  幻读: 读取时允许插入</p><ul><li><p><code>DEFAULT</code>:     默认值,由底层数据库自动判断应该使用什么隔离界别。</p></li><li><p><code>READ_UNCOMMITTED</code>:     可以读取未提交数据,可能出现脏读,不重复读,幻读.</p></li><li><p><code>READ_COMMITTED</code>:只能读取其他事务已提交数据.可以防止脏读,可能出现不可重复读和幻读.</p></li><li><p><code>REPEATABLE_READ</code>: 读取的数据添加锁,基于mvcc快照机制实现，防止其他事务修改此数据,保证一个事务读取到相同的数据，可以防止不可重复读.脏读,可能出现幻读.<strong>mysql和互联网场景下默认的隔离级别</strong></p></li><li><p><code>SERIALIZABLE</code>:     排队操作,对整个表添加锁.一个事务在操作数据时,另一个事务等待事务操作完成后才能操作这个表.</p><p><code>这里需要注意的是：</code>与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong><code>REPEATABLE-READ</code>（可重读）</strong> 事务隔离级别下使用的是 间隙锁（Next-Key算法)，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code>（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL 标准的 <strong><code>SERIALIZABLE</code>(可串行化)</strong> 隔离级别。</p></li></ul><h3 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）"></a>间隙锁（Next-Key锁）</h3><p>  当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。</p><p>  举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid &gt; <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></div><p>  是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>  InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p><p>  很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><h2 id="事务传播属性"><a href="#事务传播属性" class="headerlink" title="事务传播属性"></a>事务传播属性</h2><p><code>REQUIRED</code>：需要。有事务，我跟你混；没事务我新建个；</p><p><code>SUPPORTS</code>：支持。有事务，我支持；没有事务我也不新建；</p><p><code>REQUIRES_NEW</code>：需要自己New个。没有，我新建个；有我也不搭理你，我自己建个，独立回滚。</p><p>必须有事务：<code>MANDATORY</code>没有就报错，<code>NESTED</code>没有我新建个，有我嵌套一个。</p><p>必须没事务：<code>NEVER</code>有就报错，<code>NOT_SUPPORTED</code>有我也不搭理你。</p><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><p>下面，用一个例子来解释下各个传播属性的不同：<br>在数据库中新建了一张产品表，两条数据，一条产品id为1，产品名称为IPhone6S，另一条产品id为2，产品名称为MAC PRO。</p><p>两个服务serviceA和serviceB，serviceA的methodA方法先减IPhone6S的库存，然后调用serviceB中methodB方法扣减MAC Pro库存，为了观察，methodA最后手动抛出异常，模拟回滚场景。</p><h4 id="REQUIRED-默认值"><a href="#REQUIRED-默认值" class="headerlink" title="REQUIRED(默认值)"></a>REQUIRED(默认值)</h4><p>如果当前有事务,就在事务中执行,如果当前没有事务,新建一个事务.</p><p>==需要个事务==：你有我跟着你混，你没有我自己创建个。</p><ul><li><p>外部有事务时，内部继承外部事务，异常时，共同回滚。</p></li><li><p>外部无事务时，内部新建事务，独立回滚。</p></li></ul><p>  在传播属性为PROPAGATION_REQUIRED时，事务加入方会使用当前事务，methodA代码为</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      TransactionTemplate transactionTemplate = <span class="keyword">new</span> TransactionTemplate(transactionManager);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">          transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">              OrdProduct product = ordProductMapper.selectForUpdate(<span class="number">1</span>);</span><br><span class="line">              System.out.println(<span class="string">"before update "</span> + product.getProductName() + <span class="string">", inventory is: "</span> + product.getInventory());</span><br><span class="line">              product.setInventory(product.getInventory() - <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">int</span> result = ordProductMapper.updateInventoryByProductId(<span class="number">1</span>, product.getInventory());</span><br><span class="line">              serviceB.methodB();</span><br><span class="line">              <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          OrdProduct product1 = ordProductMapper.selectForUpdate(<span class="number">1</span>);</span><br><span class="line">          OrdProduct product2 = ordProductMapper.selectForUpdate(<span class="number">2</span>);</span><br><span class="line">          System.out.println(<span class="string">"after update "</span> + product1.getProductName() + <span class="string">", inventory is: "</span> + product1.getInventory());</span><br><span class="line">          System.out.println(<span class="string">"after update "</span> + product2.getProductName() + <span class="string">", inventory is: "</span> + product2.getInventory());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><p>  methodB的代码为：</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">       TransactionTemplate transactionTemplate = <span class="keyword">new</span> TransactionTemplate(transactionManager);</span><br><span class="line">       transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">       transactionTemplate.execute(transactionStatus -&gt; &#123;</span><br><span class="line">           OrdProduct product = ordProductMapper.selectForUpdate(<span class="number">2</span>);</span><br><span class="line">           System.out.println(<span class="string">"before update "</span> + product.getProductName() +  <span class="string">", inventory is: "</span> + product.getInventory());</span><br><span class="line">           product.setInventory(product.getInventory() -<span class="number">1</span> );</span><br><span class="line">           <span class="keyword">int</span> result = ordProductMapper.updateInventoryByProductId(<span class="number">2</span>, product.getInventory());</span><br><span class="line">           <span class="comment">/*if (result == 1) &#123;</span></span><br><span class="line"><span class="comment">               throw new RuntimeException("test");</span></span><br><span class="line"><span class="comment">           &#125;*/</span></span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>  methodA在完成6s的减库存操作后，调用methodB，methodB的传播属性是PROPAGATION_REQUIRED，此时methodA已经起了事务，methodB会使用现存的事务，在methodA抛出异常后，两个方法的减库存操作都会回滚。</p><ul><li><p><strong>当前没有事务，则新建一个事务</strong><br>methodA代码逻辑不用transactionTemplate.execute()方式执行，methodB方法去除注释抛出异常，methodB会新建一个事务，执行后methodB会回滚，methodA不会，即mac库存不变，6s库存减1；</p><h4 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a>REQUIRES_NEW</h4></li><li><p>必须在事务中执行,如果当前没有事务,新建事务,如果当前有事务,把当前事务挂起.</p></li><li><p>内部事务和外部事务分离开，独立回滚。</p><h4 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a>SUPPORTS</h4><p>如果当前有事务就在事务中执行,如果当前没有事务,就在非事务状态下执行.</p></li><li><ul><li><strong>支持当前事务*</strong>和REQUIRED行为相同；</li><li><strong>没有当前事务，则以非事务的方式执行**</strong>（报错后均不进行回滚)</li></ul><p>methodA代码逻辑不用transactionTemplate.execute()方式执行，methodB方法去除注释抛出异常，methodB不会新建事务，执行后两个方法都不会回滚，两个产品的库存均减1.</p><h4 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a>MANDATORY</h4><p>必须在事务内部执行,如果当前有事务,就在事务中执行,如果<strong>没有事务报错</strong>.</p></li><li><p>==必须有事务==：没有我就报错。</p></li><li><p>methodA代码逻辑不用transactionTemplate.execute()方式执行，执行时则会抛出如下异常.</p></li><li><pre><code class="dart">org.springframework.transaction.IllegalTransactionStateException: No existing transaction found <span class="keyword">for</span> transaction marked <span class="keyword">with</span> propagation <span class="string">'mandatory'</span>&lt;!--￼<span class="number">5</span>--&gt;</code></pre></li></ul><p><code>声明式事务:</code></p><ol><li>事务控制代码已经由spring写好.</li><li>程序员只需要声明出<strong>哪些方法</strong>需要进行事务控制和<strong>如何进行</strong>事务控制.</li><li>声明式事务都是针对于<strong>ServiceImpl类</strong>下方法的. </li><li>事务管理器基于通知(advice)的.</li><li>在spring配置文件中配置声明式事务，配置事务的<code>传播行为</code>、<code>只读属性</code>、<code>隔离级别</code>、<code>何时回滚</code>（rollback-for）</li></ol><h3 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h3><h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4><h5 id="Transactional-的作用范围"><a href="#Transactional-的作用范围" class="headerlink" title="@Transactional 的作用范围"></a><code>@Transactional</code> 的作用范围</h5><ol><li><strong>方法</strong> ：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上，否则不生效。</strong></li><li><strong>类</strong> ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li><li><strong>接口</strong> ：不推荐在接口上使用。</li></ol><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>使用 <code>@Transactional</code>注解进行事务管理的示例代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation=propagation.PROPAGATION_REQUIRED)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Customer dbCustomer = customerService.getCustomerById(<span class="number">2060</span>);</span><br><span class="line">    User user = userMapper.selectByPrimaryKey(<span class="number">93</span>);</span><br><span class="line">    dbCustomer.setRealName(<span class="string">"b"</span>);</span><br><span class="line">    user.setName(<span class="string">"b"</span>);</span><br><span class="line">    customerMapper.updateByPrimaryKey(dbCustomer);</span><br><span class="line">    userMapper.updateByPrimaryKey(user);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="事务管理接口介绍"><a href="#事务管理接口介绍" class="headerlink" title="事务管理接口介绍"></a>事务管理接口介绍</h5><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p><ul><li><code>PlatformTransactionManager</code>： （平台）事务管理器，Spring 事务策略的核心。</li><li><code>TransactionDefinition</code>： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li><li><code>TransactionStatus</code>： 事务运行状态。</li></ul><p>我们可以把 <code>PlatformTransactionManager</code> 接口可以被看作是事务上层的管理者，而 <strong><code>TransactionDefinition</code></strong> 和 <code>TransactionStatus</code> 这两个接口可以看作是事物的描述。</p><p><code>PlatformTransactionManager</code> 会根据 <code>TransactionDefinition</code> 的定义比如事务超时时间、隔离界别、传播行为等来进行事务管理 ，而 <code>TransactionStatus</code> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h4 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通知 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务增强，事务如何切入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 传播行为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"create*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"remove*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"select*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务增强以及切入点表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span></span></span><br><span class="line"><span class="tag"><span class="attr">pointcut</span>=<span class="string">"execution(* com.exocr.service..*.*(..))"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="声明式事务中的属性"><a href="#声明式事务中的属性" class="headerlink" title="声明式事务中的属性"></a>声明式事务中的属性</h3><p><img alt="img" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf95xljabwj309q08pjsu.jpg" class="lazyload"></p><ul><li><p><strong>name=</strong>”” 哪些方法需要有事务控制，支持*通配符</p></li><li><p><strong>readonly=</strong>”boolean” 是否是只读事务.</p><ul><li>如果为 true,告诉数据库此事务为只读事务.数据库优化,会对性能有一定提升,所以只要是查询的方法,建议使用。</li><li>如果为 false(默认值),事务需要提交的事务.建议新增,删除,修改.</li></ul></li><li><p><strong>propagation</strong> 控制事务传播行为.</p></li><li><p><strong>isolation=</strong>”” 事务隔离级别</p></li><li><p><strong>rollback</strong>-for=”异常类型全限定路径”:当出现什么异常时需要进行回滚</p></li></ul><p>  业务示例代码如下：进行插入操作获取返回值，当全部成功后认为新增成功，否则失败。由Spring进行事务回滚。</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insTbItemDesc</span><span class="params">(TbItem tbItem, TbItemDesc desc,TbItemParamItem paramItem)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        index= tbItemMapper.insertSelective(tbItem);</span><br><span class="line">        index+= tbItemDescMapper.insertSelective(desc);</span><br><span class="line">        index+=tbItemParamItemMapper.insertSelective(paramItem);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"新增失败,数据还原"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>  XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</p><h2 id><a href="#" class="headerlink" title></a></h2><h3 id="Transactional-事务注解原理"><a href="#Transactional-事务注解原理" class="headerlink" title="@Transactional 事务注解原理"></a><code>@Transactional</code> 事务注解原理</h3><p>  面试中在问 AOP 的时候可能会被问到的一个问题。简单说下吧！</p><p>  我们知道，<code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用<strong>动态代理</strong>实现的。如果目标对象<strong>实现了接口</strong>，默认情况下会采用 <strong>JDK 的动态代理</strong>，如果目标对象没有实现了接口,会使用 <strong>CGLIB 动态代理</strong>。</p><p>  多提一嘴：<code>createAopProxy()</code> 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下：</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">   Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">   <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">      <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>  如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><h4 id="Spring-AOP-自调用问题"><a href="#Spring-AOP-自调用问题" class="headerlink" title="Spring AOP 自调用问题"></a>Spring AOP 自调用问题</h4><p>  若同一类中的其他没有 <code>@Transactional</code> 注解的方法内部调用有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。</p><p>  这是由于<code>Spring AOP</code>代理的原因造成的，因为只有当 <code>@Transactional</code> 注解的方法在==类以外被调用的时候，Spring 事务管理才生效。==</p><p>  <code>MyService</code> 类中的<code>method1()</code>调用<code>method2()</code>就会导致<code>method2()</code>的事务失效。</p>  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     method2();</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>  解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p><h4 id="Transactional-的使用注意事项总结"><a href="#Transactional-的使用注意事项总结" class="headerlink" title="@Transactional 的使用注意事项总结"></a><code>@Transactional</code> 的使用注意事项总结</h4><pre><code>1. `@Transactional` 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；2. 避免同一个类中调用 `@Transactional` 注解的方法，这样会导致事务失效；3. 正确的设置 `@Transactional` 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败4. ......</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络相关基础</title>
      <link href="/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h2><p>HTTP 是一种 <code>超文本传输协议(Hypertext Transfer Protocol)</code>，**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p><p>HTTPS 的全称是 <code>Hypertext Transfer Protocol Secure</code>，从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。</p><p>也就是说，<strong>HTTPS 就是身披了一层 SSL 的 HTTP</strong>。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD19RoMWPIg8hv6BJZOaAle0qiclXjXBF4UUH9TWfjwmdibwP7EHssGqhA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>那么，HTTP 和 HTTPS 的主要区别是什么呢？</p><ul><li>最简单的，HTTP 在地址栏上的协议是以 <code>http://</code> 开头，而 HTTPS 在地址栏上的协议是以 <code>https://</code> 开头</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.cxuanblog.com/</span></span><br><span class="line">https:<span class="comment">//www.cxuanblog.com/</span></span><br></pre></td></tr></table></figure></div><ul><li>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 <strong>密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法</strong> 能够解决上面这些问题。</li></ul><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD7epCiaoQwrgS3xQsl4f0b0h6jopmrQO9ryZHhia6EicGN2fDBKQj1as2g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><ul><li>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。</li></ul><h2 id="HTTP-Get-和-Post-区别"><a href="#HTTP-Get-和-Post-区别" class="headerlink" title="HTTP Get 和 Post 区别"></a>HTTP Get 和 Post 区别</h2><p>HTTP 中包括许多方法，<strong>Get 和 Post 是 HTTP 中最常用的两个方法</strong>，基本上使用 HTTP 方法中有 99% 都是在使用 Get 方法和 Post 方法，所以有必要我们对这两个方法有更加深刻的认识。</p><ul><li><p>get 方法一般用于请求，比如你在浏览器地址栏输入 <code>www.cxuanblog.com</code> 其实就是发送了一个 get 请求，它的主要特征是请求服务器返回资源，而 post 方法一般用于</p><p><code>表单</code>的提交，相当于是把信息提交给服务器，等待服务器作出响应，get 相当于一个是 pull/拉的操作，而 post 相当于是一个 push/推的操作。</p></li><li><p>get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造；</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure></div><p>而 post 方法是把参数放在请求体 body 中的，这对用户来说不可见。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test&#x2F;demo_form.asp HTTP&#x2F;1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure></div><ul><li>get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。</li><li>get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。</li><li>get 请求在浏览器反复的 <code>回退/前进</code> 操作是无害的，而 post 操作会再次提交表单请求。</li><li>get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</li></ul><h2 id="什么是无状态协议，HTTP-是无状态协议吗，怎么解决"><a href="#什么是无状态协议，HTTP-是无状态协议吗，怎么解决" class="headerlink" title="什么是无状态协议，HTTP 是无状态协议吗，怎么解决"></a>什么是无状态协议，HTTP 是无状态协议吗，怎么解决</h2><p><code>无状态协议(Stateless Protocol)</code> 就是指<strong>浏览器对于事务的处理没有记忆能力</strong>。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。</p><p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 <code>小甜饼(Cookie)</code> 的机制。它能够让浏览器具有<code>记忆</code>能力。</p><p>如果你的浏览器允许 cookie 的话，查看方式 <strong>chrome://settings/content/cookies</strong></p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDsCBfLLWyK87vklbxJHwlVkL8xicYPDIbW7VEfKjNCjS2YMnpP17ya6w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>也就说明你的记忆芯片通电了…… 当你向服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 Set-Cookie：JSESSIONID=XXXXXXX 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 JSESSIONID=XXXXXXX 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDnLQ4cbMCZLF9ibM2km6nu7wyy0b9vZFq3L03vSG3omzRhncV68By8Ig/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDt4V7IRicwA7d9MIEdibHaxiaFBPaSKD2A3kuwxwM6micorkKJqiasj9AicaQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>还有一种方式是使用 JWT 机制，它也是能够让你的浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点</p><ul><li>JWT 的 Cookie 信息存储在<code>客户端</code>，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。</li><li>JWT 支持跨域认证，Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</li></ul><h2 id="UDP-和-TCP-的区别"><a href="#UDP-和-TCP-的区别" class="headerlink" title="UDP 和 TCP 的区别"></a>UDP 和 TCP 的区别</h2><p>TCP 和 UDP 都位于计算机网络模型中的运输层，它们负责传输应用层产生的数据。下面我们就来聊一聊 TCP 和 UDP 分别的特征和他们的区别</p><h3 id="UDP-是什么"><a href="#UDP-是什么" class="headerlink" title="UDP 是什么"></a>UDP 是什么</h3><p>UDP 的全称是 <code>User Datagram Protocol</code>，用户数据报协议。它不需要所谓的<code>握手</code>操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。</p><blockquote><p>数据报是与分组交换网络关联的传输单元。</p></blockquote><p>UDP 的特点主要有</p><ul><li>UDP 能够支持容忍数据包丢失的带宽密集型应用程序</li><li>UDP 具有低延迟的特点</li><li>UDP 能够发送大量的数据包</li><li>UDP 能够允许 DNS 查找，DNS 是建立在 UDP 之上的应用层协议。</li></ul><h3 id="TCP-是什么"><a href="#TCP-是什么" class="headerlink" title="TCP 是什么"></a>TCP 是什么</h3><p>TCP 的全称是<code>Transmission Control Protocol</code> ，传输控制协议。它能够帮助你确定计算机连接到 Internet 以及它们之间的数据传输。通过三次握手来建立 TCP 连接，三次握手就是用来启动和确认 TCP 连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。</p><p>TCP 的主要特点有</p><ul><li>TCP 能够确保连接的建立和数据包的发送</li><li>TCP 支持错误重传机制</li><li>TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送</li><li>TCP 能够提供错误校验和，甄别有害的数据包。</li></ul><h3 id="TCP-和-UDP-的不同"><a href="#TCP-和-UDP-的不同" class="headerlink" title="TCP 和 UDP 的不同"></a>TCP 和 UDP 的不同</h3><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDcsTFw3N3N0qAiche76WjEFl1TE3ckqW9oIT5yeEBiaHeKL1OpWd9Y9vA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>下面为你罗列了一些 TCP 和 UDP 的不同点，方便理解，方便记忆。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDcUC1xOPDkPMCnPWX4DutTkGW3ooiaoEl8yoyPwcrLlkB8h5wlhMNqmw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h2 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h2><p>TCP 三次握手和四次挥手也是面试题的热门考点，它们分别对应 TCP 的连接和释放过程。下面就来简单认识一下这两个过程</p><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>在了解具体的流程前，我们需要先认识几个概念</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD58Npf1AOxttKsHPFl4aOQ54Znzk6P3mic47cYsh2RLgQMibV4I8iaKbZw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><ul><li>SYN：它的全称是 <code>Synchronize Sequence Numbers</code>，同步序列编号。是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立 TCP 连接时，首先会发送的一个信号。客户端在接受到 SYN 消息时，就会在自己的段内生成一个随机值 X。</li><li>SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。</li><li>ACK：<code>Acknowledge character</code>, 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。</li></ul><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDA1U4Yibbc99AU5HU3dv9A4WGuhdQHP4X1REia3oibJZevyDBKRictC58bQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>如果用现实生活来举例的话就是</p><p>小明 - 客户端 小红 - 服务端</p><ul><li>小明给小红打电话，接通了后，小明说<strong>喂，能听到吗</strong>，这就相当于是连接建立。</li><li>小红给小明回应，<strong>能听到，你能听到我说的话吗</strong>，这就相当于是请求响应。</li><li>小明听到小红的回应后，<strong>好的</strong>，这相当于是连接确认。在这之后小明和小红就可以通话/交换信息了。</li></ul><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>在连接终止阶段使用四次挥手，连接的每一端都会独立的终止。下面我们来描述一下这个过程。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDfa4qx2k7PGicQrGqVPIbqNbIxmbzEicT8F1mtgFbGfmxjGWlricibfgy1Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><ul><li>首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将 FIN 发送到服务器，并进入 <code>FIN_WAIT_1</code> 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的 ACK 响应。</li><li>然后第二步，当服务器收到 FIN 消息时，服务器会立刻向客户端发送 ACK 确认消息。</li><li>当客户端收到服务器发送的 ACK 响应后，客户端就进入 <code>FIN_WAIT_2</code> 状态，然后等待来自服务器的 <code>FIN</code> 消息</li><li>服务器发送 ACK 确认消息后，一段时间（可以进行关闭后）会发送 FIN 消息给客户端，告知客户端可以进行关闭。</li><li>当客户端收到从服务端发送的 FIN 消息时，客户端就会由 FIN_WAIT_2 状态变为 <code>TIME_WAIT</code> 状态。处于 TIME_WAIT 状态的客户端允许重新发送 ACK 到服务器为了防止信息丢失。客户端在 TIME_WAIT 状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源（包括端口号和缓冲区数据）都被释放。</li></ul><p>还是可以用上面那个通话的例子来进行描述</p><ul><li>小明对小红说，我所有的东西都说完了，我要挂电话了。</li><li>小红说，收到，我这边还有一些东西没说。</li><li>经过若干秒后，小红也说完了，小红说，我说完了，现在可以挂断了</li><li>小明收到消息后，又等了若干时间后，挂断了电话。</li></ul><h2 id="简述-HTTP1-0-1-1-2-0-的区别"><a href="#简述-HTTP1-0-1-1-2-0-的区别" class="headerlink" title="简述 HTTP1.0/1.1/2.0 的区别"></a>简述 HTTP1.0/1.1/2.0 的区别</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>HTTP 1.0 是在 1996 年引入的，从那时开始，它的普及率就达到了惊人的效果。</p><ul><li>HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。</li><li>HTTP 1.0 被设计用来使用短链接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。</li><li>HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li><li>HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>HTTP 1.0 认为每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）。</li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 1999 年，它做出了以下方面的变化</p><ul><li>HTTP 1.1 使用了摘要算法来进行身份验证</li><li>HTTP 1.1 默认使用长连接，长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li><li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</li><li>HTTP 1.1 支持断点续传，通过使用请求头中的 <code>Range</code> 来实现。</li><li>HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP 2.0 是 2015 年开发出来的标准，它主要做的改变如下</p><ul><li><code>头部压缩</code>，由于 HTTP 1.1 经常会出现 <strong>User-Agent、Cookie、Accept、Server、Range</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li><li><code>二进制格式</code>，HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，提升了解析效率</li><li><code>强化安全</code>，由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 HTTPS 上。</li><li><code>多路复用</code>，即每一个请求都是是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。</li></ul><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDcfUyocV41Ivn7j8Zk3gj1cMZNzPKCkGjESbHJBAFScJKfY9GkFX1kQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h2 id="请你说一下-HTTP-常见的请求头"><a href="#请你说一下-HTTP-常见的请求头" class="headerlink" title="请你说一下 HTTP 常见的请求头"></a>请你说一下 HTTP 常见的请求头</h2><p>这个问题比较开放，因为 HTTP 请求头有很多，这里只简单举出几个例子。</p><p>HTTP 标头会分为四种，分别是 <code>通用标头</code>、<code>实体标头</code>、<code>请求标头</code>、<code>响应标头</code>。分别介绍一下</p><h3 id="通用标头"><a href="#通用标头" class="headerlink" title="通用标头"></a>通用标头</h3><p>通用标头主要有三个，分别是 <code>Date</code>、<code>Cache-Control</code> 和 <code>Connection</code></p><p><strong>Date</strong></p><p>Date 是一个通用标头，它可以出现在请求标头和响应标头中，它的基本表示如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure></div><p>表示的是格林威治标准时间，这个时间要比北京时间慢八个小时</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDmzuJXYqHrcAxWIRWaLoXrHCGJeABNUeFW79yCDB9WLaFsdZvKwBXxg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p><strong>Cache-Control</strong></p><p>Cache-Control 是一个通用标头，他可以出现在<code>请求标头</code>和<code>响应标头</code>中，Cache-Control 的种类比较多，虽然说这是一个通用标头，但是有一些特性是请求标头具有的，有一些是响应标头才有的。主要大类有 <code>可缓存性</code>、<code>阈值性</code>、 <code>重新验证并重新加载</code> 和<code>其他特性</code></p><p><strong>Connection</strong></p><p>Connection 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。Connection 有两种，一种是<code>持久性连接</code>，即一次事务完成后不关闭网络连接</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></div><p>另一种是<code>非持久性连接</code>，即一次事务完成后关闭网络连接</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure></div><p>HTTP1.1 其他通用标头如下</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDWjX0AWOxGVEib9VQ246ib4fplMDVcFPSSia69fd1HHcj2BpWicXtnInkFQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h3 id="实体标头"><a href="#实体标头" class="headerlink" title="实体标头"></a>实体标头</h3><p>实体标头是描述消息正文内容的 HTTP 标头。实体标头用于 HTTP 请求和响应中。头部<code>Content-Length</code>、 <code>Content-Language</code>、 <code>Content-Encoding</code> 是实体头。</p><ul><li><p>Content-Length 实体报头指示实体主体的大小，以字节为单位，发送到接收方。</p></li><li><p>Content-Language 实体报头描述了客户端或者服务端能够接受的语言。</p></li><li><p>Content-Encoding 这又是一个比较麻烦的属性，这个实体报头用来压缩媒体类型。Content-Encoding 指示对实体应用了何种编码。</p><p>常见的内容编码有这几种： <strong>gzip、compress、deflate、identity</strong> ，这个属性可以应用在请求报文和响应报文中</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate &#x2F;&#x2F;请求头</span><br><span class="line">Content-Encoding: gzip  &#x2F;&#x2F;响应头</span><br></pre></td></tr></table></figure></div><p>下面是一些实体标头字段</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><h3 id="请求标头"><a href="#请求标头" class="headerlink" title="请求标头"></a>请求标头</h3><p><strong>Host</strong></p><p>Host 请求头指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的 TCP 端口号。如果没有给定端口号，会自动使用被请求服务的默认端口（比如请求一个 HTTP 的 URL 会自动使用 80 作为端口）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: developer.mozilla.org</span><br></pre></td></tr></table></figure></div><p>上面的 <code>Accpet</code>、 <code>Accept-Language</code>、<code>Accept-Encoding</code> 都是属于内容协商的请求标头。</p><p><strong>Referer</strong></p><p>HTTP Referer 属性是请求标头的一部分，当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;testpage.html</span><br></pre></td></tr></table></figure></div><p><strong>If-Modified-Since</strong></p><p>If-Modified-Since 通常会与 If-None-Match 搭配使用，If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 <code>Last-Modified</code> 来确定。</p><p>大白话说就是如果在 <code>Last-Modified</code> 之后更新了服务器资源，那么服务器会响应 200，如果在 <code>Last-Modified</code> 之后没有更新过资源，则返回 304。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT</span><br></pre></td></tr></table></figure></div><p><strong>If-None-Match</strong></p><p>If-None-Match HTTP 请求标头使请求成为条件请求。对于 GET 和 HEAD 方法，仅当服务器没有与给定资源匹配的 <code>ETag</code> 时，服务器才会以 200 状态发送回请求的资源。对于其他方法，仅当最终现有资源的<code>ETag</code>与列出的任何值都不匹配时，才会处理请求。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;c561c68d0ba92bbeb8b0fff2a9199f722e3a621a&quot;</span><br></pre></td></tr></table></figure></div><p><strong>Accept</strong></p><p>接受请求 HTTP 标头会通告客户端其能够理解的 MIME 类型</p><p><strong>Accept-Charset</strong></p><p>accept-charset 属性规定服务器处理表单数据所接受的字符集。</p><p>常用的字符集有：UTF-8 - Unicode 字符编码 ；ISO-8859-1 - 拉丁字母表的字符编码</p><p><strong>Accept-Language</strong></p><p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。</p><p>请求标头我们大概就介绍这几种，后面会有一篇文章详细深挖所有的响应头的，下面是一个响应头的汇总，基于 HTTP 1.1</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><h3 id="响应标头"><a href="#响应标头" class="headerlink" title="响应标头"></a>响应标头</h3><p><strong>Access-Control-Allow-Origin</strong></p><p>一个返回的 HTTP 标头可能会具有 Access-Control-Allow-Origin ，<code>Access-Control-Allow-Origin</code> 指定一个来源，它告诉浏览器允许该来源进行资源访问。</p><p><strong>Keep-Alive</strong></p><p>Keep-Alive 表示的是 Connection 非持续连接的存活时间，可以进行指定。</p><p><strong>Server</strong></p><p>服务器标头包含有关原始服务器用来处理请求的软件的信息。</p><p>应该避免使用过于冗长和详细的 Server 值，因为它们可能会泄露内部实施细节，这可能会使攻击者容易地发现并利用已知的安全漏洞。例如下面这种写法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache&#x2F;2.4.1 (Unix)</span><br></pre></td></tr></table></figure></div><p><strong>Set-Cookie</strong></p><p>Set-Cookie 用于服务器向客户端发送 sessionID。</p><p><strong>Transfer-Encoding</strong></p><p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</p><p>HTTP /1.1 的传输编码方式仅对分块传输编码有效。</p><p><strong>X-Frame-Options</strong></p><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。</p><p>首部字段 <code>X-Frame-Options</code> 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p><p>下面是一个响应头的汇总，基于 HTTP 1.1</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><h2 id="地址栏输入-URL-发生了什么"><a href="#地址栏输入-URL-发生了什么" class="headerlink" title="地址栏输入 URL 发生了什么"></a>地址栏输入 URL 发生了什么</h2><p>这道题也是一道经常会考的面试题。那么下面我们就来探讨一下从你输入 URL 后到响应，都经历了哪些过程。</p><ul><li>首先，你需要在浏览器中的 URL 地址上，输入你想访问的地址，如下</li></ul><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>你应该访问不到的，对不对~</p><ul><li>然后，浏览器会根据你输入的 URL 地址，去查找域名是否被本地 DNS 缓存，不同浏览器对 DNS 的设置不同，如果浏览器缓存了你想访问的 URL 地址，那就直接返回 ip。如果没有缓存你的 URL 地址，浏览器就会发起系统调用来查询本机 <code>hosts</code> 文件是否有配置 ip 地址，如果找到，直接返回。如果找不到，就向网络中发起一个 DNS 查询。</li></ul><blockquote><p>首先来看一下 DNS 是啥，互联网中识别主机的方式有两种，通过<code>主机名</code>和 <code>IP 地址</code>。我们人喜欢用名字的方式进行记忆，但是通信链路中的路由却喜欢定长、有层次结构的 IP 地址。</p><p>所以就需要一种能够把主机名到 IP 地址的转换服务，这种服务就是由 DNS 提供的。DNS 的全称是 <code>Domain Name System</code> 域名系统。DNS 是一种由分层的 DNS 服务器实现的分布式数据库。DNS 运行在 UDP 上，使用 53 端口。</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p></blockquote><p>DNS 是一种分层数据库，它的主要层次结构如下</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>一般域名服务器的层次结构主要是以上三种，除此之外，还有另一类重要的 DNS 服务器，它是 <code>本地 DNS 服务器(local DNS server)</code>。</p><p>严格来说，本地 DNS 服务器并不属于上述层次结构，但是本地 DNS 服务器又是至关重要的。每个 <code>ISP(Internet Service Provider)</code> 比如居民区的 ISP 或者一个机构的 ISP 都有一台本地 DNS 服务器。当主机和 ISP 进行连接时，该 ISP 会提供一台主机的 IP 地址，该主机会具有一台或多台其本地 DNS 服务器的 IP地址。</p><p>通过访问网络连接，用户能够容易的确定 DNS 服务器的 IP地址。当主机发出 DNS 请求后，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次系统中。</p><p>首先，查询请求会先找到本地 DNS 服务器来查询是否包含 IP 地址，如果本地 DNS 无法查询到目标 IP 地址，就会向根域名服务器发起一个 DNS 查询。</p><blockquote><p>注意：DNS 涉及两种查询方式：一种是<code>递归查询(Recursive query)</code> ，一种是<code>迭代查询(Iteration query)</code>。《计算机网络：自顶向下方法》竟然没有给出递归查询和迭代查询的区别，找了一下网上的资料大概明白了下。</p><p>如果根域名服务器无法告知本地 DNS 服务器下一步需要访问哪个顶级域名服务器，就会使用递归查询；</p><p>如果根域名服务器能够告知 DNS 服务器下一步需要访问的顶级域名服务器，就会使用迭代查询。</p></blockquote><p>在由根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威 DNS 服务器后，由权威服务器告诉本地服务器目标 IP 地址，再有本地 DNS 服务器告诉用户需要访问的 IP 地址。</p><ul><li>第三步，浏览器需要和目标服务器建立 TCP 连接，需要经过三次握手的过程，具体的握手过程请参考上面的回答。</li><li>在建立连接后，浏览器会向目标服务器发起 <code>HTTP-GET</code> 请求，包括其中的 URL，HTTP 1.1 后默认使用长连接，只需要一次握手即可多次传输数据。</li><li>如果目标服务器只是一个简单的页面，就会直接返回。但是对于某些大型网站的站点，往往不会直接返回主机名所在的页面，而会直接重定向。返回的状态码就不是 200 ，而是 301,302 以 3 开头的重定向码，浏览器在获取了重定向响应后，在响应报文中 Location 项找到重定向地址，浏览器重新第一步访问即可。</li><li>然后浏览器重新发送请求，携带新的 URL，返回状态码 200 OK，表示服务器可以响应请求，返回报文。</li></ul><h2 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h2><p>我们上面描述了一下 HTTP 的工作原理，下面来讲述一下 HTTPS 的工作原理。因为我们知道 HTTPS 不是一种新出现的协议，而是</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>所以，我们探讨 HTTPS 的握手过程，其实就是 SSL/TLS 的握手过程。</p><p>TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 TLS 握手期间，Internet 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。</p><p>每当用户通过 HTTPS 导航到具体的网站并发送请求时，就会进行 TLS 握手。除此之外，每当其他任何通信使用HTTPS（包括 API 调用和在 HTTPS 上查询 DNS）时，也会发生 TLS 握手。</p><p>TLS 具体的握手过程会根据所使用的<code>密钥交换算法的类型</code>和双方支持的<code>密码套件</code>而不同。我们以<code>RSA 非对称加密</code>来讨论这个过程。整个 TLS 通信流程图如下</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><ul><li>在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程</li><li>ClientHello：客户端通过向服务器发送 <code>hello</code> 消息来发起握手过程。这个消息中会夹带着客户端支持的 <code>TLS 版本号(TLS1.0 、TLS1.2、TLS1.3)</code> 、客户端支持的密码套件、以及一串 <code>客户端随机数</code>。</li><li>ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。</li><li>认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 <code>Certificate</code> 报文，报文中包含公开密钥证书。最后服务器发送 <code>ServerHelloDone</code> 作为 <code>hello</code> 请求的响应。第一部分握手阶段结束。</li><li><code>加密阶段</code>：在第一个阶段握手完成后，客户端会发送 <code>ClientKeyExchange</code> 作为响应，这个响应中包含了一种称为 <code>The premaster secret</code> 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 <code>ChangeCipherSpec</code>，告诉服务端使用私钥解密这个 <code>premaster secret</code> 的字符串，然后客户端发送 <code>Finished</code> 告诉服务端自己发送完成了。</li></ul><blockquote><p>Session key 其实就是用公钥证书加密的公钥。</p></blockquote><ul><li><code>实现了安全的非对称加密</code>：然后，服务器再发送 <code>ChangeCipherSpec</code> 和 <code>Finished</code> 告诉客户端解密完成，至此实现了 RSA 的非对称加密。</li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><strong>TCP拥塞控制</strong>是<a href="https://baike.baidu.com/item/传输控制协议" target="_blank" rel="noopener">传输控制协议</a>（英语：Transmission Control Protocol，缩写TCP）避免网络拥塞的算法，是<a href="https://baike.baidu.com/item/互联网" target="_blank" rel="noopener">互联网</a>上主要的一个<a href="https://baike.baidu.com/item/拥塞控制" target="_blank" rel="noopener">拥塞控制</a>措施。它使用一套基于线增积减模式的多样化网络拥塞控制方法（包括慢启动和拥塞窗口等模式）来控制拥塞。在互联网上应用中有相当多的具体实现算法。</p>  <script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'post-content',        blogId: '24566-1604926750091-584',        name: 'BestBear',        qrcode: 'https://s1.ax1x.com/2020/11/09/BbCVyQ.jpg',        keyword: '666',    });</script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis工具类</title>
      <link href="/2020/01/15/3.%20redis/redisUtil/"/>
      <url>/2020/01/15/3.%20redis/redisUtil/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最全的Java操作Redis的工具类，使用StringRedisTemplate实现，封装了对Redis五种基本类型的各种操作，力求符合Redis的原生操作！<br>分为六个部分：<a href="https://gitee.com/nmwork/RedisUtil#一keys相关命令" target="_blank" rel="noopener">keys命令操作</a>、<a href="https://gitee.com/nmwork/RedisUtil#二string数据类型操作" target="_blank" rel="noopener">String数据操作</a>、<a href="https://gitee.com/nmwork/RedisUtil#三hash相关的操作" target="_blank" rel="noopener">Hash数据操作</a>、<a href="https://gitee.com/nmwork/RedisUtil#四list相关的操作" target="_blank" rel="noopener">List数据操作</a>、<a href="https://gitee.com/nmwork/RedisUtil#五set相关的操作" target="_blank" rel="noopener">Set数据操作</a>、<a href="https://gitee.com/nmwork/RedisUtil#六zset数据类型操作" target="_blank" rel="noopener">zSet数据操作</a>。 </p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果你比较关心为什么它没有提供存储Object的方法，请看这里介绍<a href="https://gitee.com/nmwork/RedisUtil#二redistemplate和stringredistemplate" target="_blank" rel="noopener">存Object为什么不好？</a>  </p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="一、keys相关命令"><a href="#一、keys相关命令" class="headerlink" title="一、keys相关命令"></a>一、keys相关命令</h3><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>void delete(String key)</td><td>key 存在时删除 key</td></tr><tr><td>2</td><td>void delete(Collection keys)</td><td>批量删除key</td></tr><tr><td>3</td><td>byte[] dump(String key)</td><td>序列化给定 key ，并返回被序列化的值</td></tr><tr><td>4</td><td>Boolean hasKey(String key)</td><td>检查给定 key 是否存在</td></tr><tr><td>5</td><td>Boolean expire(String key, long timeout, TimeUnit unit)</td><td>设置过期时间</td></tr><tr><td>6</td><td>Boolean expireAt(String key, Date date)</td><td>设置过期时间</td></tr><tr><td>7</td><td>Set keys(String pattern)</td><td>查找所有符合给定模式( pattern)的 key</td></tr><tr><td>8</td><td>Boolean move(String key, int dbIndex)</td><td>将当前数据库的 key 移动到给定的数据库 db 当中</td></tr><tr><td>9</td><td>Boolean persist(String key)</td><td>移除 key 的过期时间，key 将持久保持</td></tr><tr><td>10</td><td>Long getExpire(String key, TimeUnit unit)</td><td>返回 key 的剩余的过期时间</td></tr><tr><td>11</td><td>Long getExpire(String key)</td><td>返回 key 的剩余的过期时间</td></tr><tr><td>12</td><td>String randomKey()</td><td>从当前数据库中随机返回一个 key</td></tr><tr><td>13</td><td>void rename(String oldKey, String newKey)</td><td>修改 key 的名称</td></tr><tr><td>14</td><td>Boolean renameIfAbsent(String oldKey, String newKey)</td><td>仅当 newkey 不存在时，将 oldKey 改名为 newkey</td></tr><tr><td>15</td><td>DataType type(String key)</td><td>返回 key 所储存的值的类型</td></tr></tbody></table><hr><h3 id="二、String数据类型操作"><a href="#二、String数据类型操作" class="headerlink" title="二、String数据类型操作"></a>二、String数据类型操作</h3><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>String get(String key)</td><td>获取指定 key 的值</td></tr><tr><td>2</td><td>String getRange(String key, long start, long end)</td><td>返回 key 中字符串值的子字符</td></tr><tr><td>3</td><td>String getAndSet(String key, String value)</td><td>将给定 key 的值设为 value ，并返回key 的旧值(old value)</td></tr><tr><td>4</td><td>Boolean getBit(String key, long offset)</td><td>对 key 所储存的字符串值，获取指定偏移 量上的位(bit)</td></tr><tr><td>5</td><td>List multiGet(Collection keys)</td><td>批量获取</td></tr><tr><td>6</td><td>void set(String key, String value)</td><td>设置指定 key 的值</td></tr><tr><td>7</td><td>boolean setBit(String key, long offset, boolean value)</td><td>设置ASCII码, 字符串’a’的ASCII码是97, 转 为二进制是’01100001’, 此方法是将 二进制第offset位值变为value</td></tr><tr><td>8</td><td>void setEx(String key, String value, long timeout, TimeUnit unit)</td><td>将值 value 关联到 key ，并将 key 的过期 时间设为 timeout,unit:时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES, 秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS</td></tr><tr><td>9</td><td>boolean setIfAbsent(String key, String value)</td><td>只有在 key 不存在时设置 key 的值</td></tr><tr><td>10</td><td>void setRange(String key, String value, long offset)</td><td>用 value 参数覆写给定 key 所储存的字符串 值，从偏移量 offset 开始</td></tr><tr><td>11</td><td>void multiSet(Map&lt;String,String&gt; maps)</td><td>批量添加</td></tr><tr><td>12</td><td>boolean multiSetIfAbsent(Map&lt;String,String&gt; maps)</td><td>同时设置一个或多个 key-value 对，当且仅 当所有给定 key 都不存在</td></tr><tr><td>13</td><td>Integer append(String key, String value)</td><td>追加到末尾</td></tr><tr><td>14</td><td>Long incrBy(String key, long increment)</td><td>增加(自增长), 负数则为自减</td></tr><tr><td>15</td><td>Double incrByFloat(String key, double increment)</td><td>增加(自增长), 负数则为自减</td></tr><tr><td>16</td><td>Long size(String key)</td><td>获取字符串的长度</td></tr></tbody></table><hr><h3 id="三、Hash相关的操作"><a href="#三、Hash相关的操作" class="headerlink" title="三、Hash相关的操作"></a>三、Hash相关的操作</h3><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Object hGet(String key, String field)</td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td>2</td><td>Map hGetAll(String key)</td><td>获取所有给定字段的值</td></tr><tr><td>3</td><td>List hMultiGet(String key, Collection fields)</td><td>获取所有给定字段的值</td></tr><tr><td>4</td><td>void hPut(String key, String hashKey, String value)</td><td>添加字段</td></tr><tr><td>5</td><td>void hPutAll(String key, Map maps)</td><td>添加多个字段</td></tr><tr><td>6</td><td>Boolean hPutIfAbsent(String key, String hashKey, String value)</td><td>仅当hashKey不存在时才设置</td></tr><tr><td>7</td><td>Long hDelete(String key, Object… fields)</td><td>删除一个或多个哈希表字段</td></tr><tr><td>8</td><td>boolean hExists(String key, String field)</td><td>查看哈希表 key 中，指定的字段是 否存在</td></tr><tr><td>9</td><td>Long hIncrBy(String key, Object field, long increment)</td><td>为哈希表 key 中的指定字段的整数 值加上增量 increment</td></tr><tr><td>10</td><td>Double hIncrByFloat(String key, Object field, double delta)</td><td>为哈希表 key 中的指定字段的整数 值加上增量 increment</td></tr><tr><td>11</td><td>Set hKeys(String key)</td><td>获取所有哈希表中的字段</td></tr><tr><td>12</td><td>Long hSize(String key)</td><td>获取哈希表中字段的数量</td></tr><tr><td>13</td><td>List hValues(String key)</td><td>获取哈希表中所有值</td></tr><tr><td>14</td><td>Cursor hScan(String key, ScanOptions options)</td><td>迭代哈希表中的键值对</td></tr></tbody></table><hr><h3 id="四、List相关的操作"><a href="#四、List相关的操作" class="headerlink" title="四、List相关的操作"></a>四、List相关的操作</h3><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>String lIndex(String key, long index)</td><td>通过索引获取列表中的元素</td></tr><tr><td>2</td><td>List lRange(String key, long start, long end)</td><td>获取列表指定范围内的元素</td></tr><tr><td></td><td></td><td></td></tr><tr><td>3</td><td>Long lLeftPush(String key, String value)</td><td>存储在list头部</td></tr><tr><td>4</td><td>Long lLeftPushAll(String key, String… value)</td><td>存储在list头部</td></tr><tr><td>5</td><td>Long lLeftPushAll(String key, Collection value)</td><td>存储在list头部</td></tr><tr><td>6</td><td>Long lLeftPushIfPresent(String key, String value)</td><td>当list存在的时候才加入</td></tr><tr><td>7</td><td>lLeftPush(String key, String pivot, String value)</td><td>如果pivot存在,再pivot前面添加</td></tr><tr><td></td><td></td><td></td></tr><tr><td>8</td><td>Long lRightPush(String key, String value)</td><td>存储在list尾部</td></tr><tr><td>9</td><td>Long lRightPushAll(String key, String… value)</td><td>存储在list尾部</td></tr><tr><td>10</td><td>Long lRightPushAll(String key, Collection value)</td><td>存储在list尾部</td></tr><tr><td>11</td><td>Long lRightPushIfPresent(String key, String value)</td><td>当list存在的时候才加入</td></tr><tr><td>12</td><td>lRightPush(String key, String pivot, String value)</td><td>在pivot元素的右边添加值</td></tr><tr><td></td><td></td><td></td></tr><tr><td>13</td><td>void lSet(String key, long index, String value)</td><td>通过索引设置列表元素的值</td></tr><tr><td></td><td></td><td></td></tr><tr><td>14</td><td>String lLeftPop(String key)</td><td>移出并获取列表的第一个元素</td></tr><tr><td>15</td><td>String lBLeftPop(String key, long timeout, TimeUnit unit)</td><td>移出并获取列表的第一个元素， 如果列 表没有元素会阻塞列表直到等待超时或 发现可弹出元素为止</td></tr><tr><td></td><td></td><td></td></tr><tr><td>16</td><td>String lRightPop(String key)</td><td>移除并获取列表最后一个元素</td></tr><tr><td>17</td><td>String lBRightPop(String key, long timeout, TimeUnit unit)</td><td>移出并获取列表的最后一个元素， 如 果列表没有元素会阻塞列表直到等待超时 或发现可弹出元素为止</td></tr><tr><td>18</td><td>String lRightPopAndLeftPush(String sourceKey, String destinationKey)</td><td>移除列表的最后一个元素， 并将该元素添加到另一个列表并返回</td></tr><tr><td>19</td><td>String lBRightPopAndLeftPush(String sourceKey, String destinationKey,,long timeout, TimeUnit unit)</td><td>从列表中弹出一个值，将弹出的元素插入到 另外一个列表中并返回它； 如果列表没 有元素会阻塞列表直到等待超时或发现可弹出 元素为止</td></tr><tr><td></td><td></td><td></td></tr><tr><td>20</td><td>Long lRemove(String key, long index, String value)</td><td>删除集合中值等于value得元素</td></tr><tr><td>21</td><td>void lTrim(String key, long start, long end)</td><td>裁剪list</td></tr><tr><td>22</td><td>Long lLen(String key)</td><td>获取列表长度</td></tr></tbody></table><hr><h3 id="五、Set相关的操作"><a href="#五、Set相关的操作" class="headerlink" title="五、Set相关的操作"></a>五、Set相关的操作</h3><h4 id="1-添加操作："><a href="#1-添加操作：" class="headerlink" title="1.添加操作："></a>1.添加操作：</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加</span><br><span class="line">Long sAdd(String key, String... values);</span><br></pre></td></tr></table></figure></div><h4 id="2-获取操作："><a href="#2-获取操作：" class="headerlink" title="2.获取操作："></a>2.获取操作：</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取集合所有元素</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">sMembers</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合大小</span></span><br><span class="line"><span class="function">Long <span class="title">sSize</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断集合是否包含value</span></span><br><span class="line"><span class="function">Boolean <span class="title">sIsMember</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机获取集合中的一个元素</span></span><br><span class="line"><span class="function">String <span class="title">sRandomMember</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机获取集合count个元素</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">sRandomMembers</span><span class="params">(String key, <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机获取集合中count个元素并且去除重复的</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">sDistinctRandomMembers</span><span class="params">(String key, <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器获取元素</span></span><br><span class="line"><span class="function">Cursor&lt;String&gt; <span class="title">sScan</span><span class="params">(String key, ScanOptions options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取两个集合的交集</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">sIntersect</span><span class="params">(String key, String otherKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取key集合与多个集合的交集</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">sIntersect</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key集合与destKey集合的交集存储到destKey集合中</span></span><br><span class="line"><span class="function">Long <span class="title">sIntersectAndStore</span><span class="params">(String key, String otherKey, String destKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key集合与多个集合的交集存储到destKey集合中</span></span><br><span class="line"><span class="function">Long <span class="title">sIntersectAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//--------------------------------------------------------------------------------------</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取两个集合的并集</span></span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">sUnion</span><span class="params">(String key, String otherKeys)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取key集合与多个集合的并集</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">sUnion</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key集合与otherKey集合的并集存储到destKey中</span></span><br><span class="line"><span class="function">Long <span class="title">sUnionAndStore</span><span class="params">(String key, String otherKey, String destKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key集合与多个集合的并集存储到destKey中</span></span><br><span class="line"><span class="function">Long <span class="title">sUnionAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取两个集合的差集</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">sDifference</span><span class="params">(String key, String otherKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取key集合与多个集合的差集</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">sDifference</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key集合与otherKey集合的差集存储到destKey中</span></span><br><span class="line"><span class="function">Long <span class="title">sDifference</span><span class="params">(String key, String otherKey, String destKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key集合与多个集合的差集存储到destKey中</span></span><br><span class="line"><span class="function">Long <span class="title">sDifference</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span></span>;</span><br></pre></td></tr></table></figure></div><h4 id="3-修改操作："><a href="#3-修改操作：" class="headerlink" title="3.修改操作："></a>3.修改操作：</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除</span></span><br><span class="line"><span class="function">Long <span class="title">sRemove</span><span class="params">(String key, Object... values)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机移除一个元素</span></span><br><span class="line"><span class="function">String <span class="title">sPop</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将key集合中value元素移到destKey集合中</span></span><br><span class="line"><span class="function">Boolean <span class="title">sMove</span><span class="params">(String key, String value, String destKey)</span></span>;</span><br></pre></td></tr></table></figure></div><h3 id="六、zset数据类型操作"><a href="#六、zset数据类型操作" class="headerlink" title="六、zset数据类型操作"></a>六、zset数据类型操作</h3><h4 id="1-添加操作：-1"><a href="#1-添加操作：-1" class="headerlink" title="1.添加操作："></a>1.添加操作：</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素,有序集合是按照元素的score值由小到大排列</span></span><br><span class="line"><span class="function">Boolean <span class="title">zAdd</span><span class="params">(String key, String value, <span class="keyword">double</span> score)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量添加</span></span><br><span class="line"><span class="function">Long <span class="title">zAdd</span><span class="params">(String key, Set&lt;TypedTuple&lt;String&gt;&gt; values)</span></span>;</span><br><span class="line"><span class="comment">//TypedTuple使用</span></span><br><span class="line">TypedTuple&lt;String&gt; objectTypedTuple1 = <span class="keyword">new</span> DefaultTypedTuple&lt;String&gt;(value, score);</span><br></pre></td></tr></table></figure></div><h4 id="2-获取操作：-1"><a href="#2-获取操作：-1" class="headerlink" title="2.获取操作："></a>2.获取操作：</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取集合的元素, 从小到大排序, start开始位置, end结束位置</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">zRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合元素, 并且把score值也获取</span></span><br><span class="line">Set&lt;TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Score值查询集合元素的值, 从小到大排序</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">zRangeByScore</span><span class="params">(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Score值查询集合元素, 从小到大排序</span></span><br><span class="line">Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Score值查询集合元素, 从小到大排序</span></span><br><span class="line">Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max, <span class="keyword">long</span> start, <span class="keyword">long</span> end);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合的元素, 从大到小排序</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">zReverseRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合的元素, 从大到小排序, 并返回score值</span></span><br><span class="line">Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Score值查询集合元素, 从大到小排序</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">zReverseRangeByScore</span><span class="params">(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Score值查询集合元素, 从大到小排序</span></span><br><span class="line">Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">zReverseRangeByScore</span><span class="params">(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回元素在集合的排名,有序集合是按照元素的score值由小到大排列</span></span><br><span class="line"><span class="function">Long <span class="title">zRank</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回元素在集合的排名,按元素的score值由大到小排列</span></span><br><span class="line"><span class="function">Long <span class="title">zReverseRank</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据score值获取集合元素数量</span></span><br><span class="line"><span class="function">Long <span class="title">zCount</span><span class="params">(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合大小</span></span><br><span class="line"><span class="function">Long <span class="title">zSize</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合大小</span></span><br><span class="line"><span class="function">Long <span class="title">zZCard</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合中value元素的score值</span></span><br><span class="line"><span class="function">Double <span class="title">zScore</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取key和otherKey的并集并存储在destKey中</span></span><br><span class="line"><span class="function">Long <span class="title">zUnionAndStore</span><span class="params">(String key, String otherKey, String destKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取key和多个集合的并集并存储在destKey中</span></span><br><span class="line"><span class="function">Long <span class="title">zUnionAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//-----------------------------------------------------------------------------------</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取key和otherKey的交集并存储在destKey中</span></span></span><br><span class="line"><span class="function">Long <span class="title">zIntersectAndStore</span><span class="params">(String key, String otherKey, String destKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取key和多个集合的交集并存储在destKey中</span></span><br><span class="line"><span class="function">Long <span class="title">zIntersectAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器获取</span></span><br><span class="line">Cursor&lt;TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options);</span><br></pre></td></tr></table></figure></div><h4 id="3-修改操作：-1"><a href="#3-修改操作：-1" class="headerlink" title="3.修改操作："></a>3.修改操作：</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除</span></span><br><span class="line"><span class="function">Long <span class="title">zRemove</span><span class="params">(String key, Object... values)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加元素的score值，并返回增加后的值</span></span><br><span class="line"><span class="function">Double <span class="title">zIncrementScore</span><span class="params">(String key, String value, <span class="keyword">double</span> delta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除指定索引位置的成员</span></span><br><span class="line"><span class="function">Long <span class="title">zRemoveRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据指定的score值的范围来移除成员</span></span><br><span class="line"><span class="function">Long <span class="title">zRemoveRangeByScore</span><span class="params">(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span></span>;</span><br></pre></td></tr></table></figure></div><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><h3 id="Redis知识补充"><a href="#Redis知识补充" class="headerlink" title="Redis知识补充"></a>Redis知识补充</h3><p>Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为：String（字符串）、List（列表）、Set（集合）、Hash（散列）和 Zset（有序集合）。   </p><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>String</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)或者自减(decrement)</td></tr><tr><td>List</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值来查找或者移除元素</td></tr><tr><td>Set</td><td>包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同</td><td>添加、获取、移除单个元素；检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素</td></tr><tr><td>Hash</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对</td></tr><tr><td>ZSet</td><td>字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素</td></tr></tbody></table><h3 id="RedisTemplate和StringRedisTemplate"><a href="#RedisTemplate和StringRedisTemplate" class="headerlink" title="RedisTemplate和StringRedisTemplate"></a>RedisTemplate和StringRedisTemplate</h3><p>二者主要区别是他们使用的序列化类不一样，RedisTemplate使用的是JdkSerializationRedisSerializer， StringRedisTemplate使用的是StringRedisSerializer，两者的数据是不共通的。</p><h4 id="RedisTemplate："><a href="#RedisTemplate：" class="headerlink" title="RedisTemplate："></a>RedisTemplate：</h4><p> RedisTemplate使用的是JDK的序列化策略，向Redis存入数据会将数据先序列化成字节数组然后在存入Redis数据库，这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式展现的，而是以字节数组显示，类似下面：\xAC\xED\x00\x05t\x05sr\x00。  所以使用RedisTemplate可以直接把一个java对象直接存储在redis里面，但是存进去的数据是不易直观的读的，不通用的，建议最好不要直接存一个Object对象，可以变成Hash来存储，也可以转成json格式的数据来存储，在实际应用中也是很多都采用json格式来存储的。</p><h4 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate:"></a>StringRedisTemplate:</h4><p> StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。StringRedisTemplate是继承RedisTemplate的，这种对redis的操方式更优雅，因为RedisTemplate以字节数组的形式存储不利于管理，也不通用。  </p><h3 id="三、Redis与Spring的集成"><a href="#三、Redis与Spring的集成" class="headerlink" title="三、Redis与Spring的集成"></a>三、Redis与Spring的集成</h3><p>1.集成配置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"600"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"127.0.0.1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"WangFan01!"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"poolConfig"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.core.StringRedisTemplate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jedisConnectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这里可以配置多个redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisUtil"</span> <span class="attr">class</span>=<span class="string">"com.wf.ew.core.utils.RedisUtil"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>2.使用RedisUtil工具类方法如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisUtil redisUtil;</span><br></pre></td></tr></table></figure></div><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wf.ew.core.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.DataType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.Cursor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ScanOptions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ZSetOperations.TypedTuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis工具类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WangFan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-02-24 下午03:09:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.1 (GitHub文档: https://github.com/whvcse/RedisUtil )</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisTemplate</span><span class="params">(StringRedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">getRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.redisTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** -------------------key相关操作--------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">redisTemplate.delete(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Collection&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">redisTemplate.delete(keys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] dump(String key) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.dump(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否存在key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过期时间</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.expire(key, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过期时间</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">expireAt</span><span class="params">(String key, Date date)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.expireAt(key, date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找匹配的key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">keys</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前数据库的 key 移动到给定的数据库 db 当中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dbIndex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">move</span><span class="params">(String key, <span class="keyword">int</span> dbIndex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.move(key, dbIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除 key 的过期时间，key 将持久保持</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">persist</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.persist(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 key 的剩余的过期时间</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getExpire</span><span class="params">(String key, TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.getExpire(key, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 key 的剩余的过期时间</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.getExpire(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前数据库中随机返回一个 key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">randomKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.randomKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改 key 的名称</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newKey</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rename</span><span class="params">(String oldKey, String newKey)</span> </span>&#123;</span><br><span class="line">redisTemplate.rename(oldKey, newKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅当 newkey 不存在时，将 oldKey 改名为 newkey</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">renameIfAbsent</span><span class="params">(String oldKey, String newKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.renameIfAbsent(oldKey, newKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 key 所储存的值的类型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataType <span class="title">type</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.type(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** -------------------string相关操作--------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置指定 key 的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">redisTemplate.opsForValue().set(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定 key 的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 key 中字符串值的子字符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().get(key, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定 key 的值设为 value ，并返回 key 的旧值(old value)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAndSet</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对 key 所储存的字符串值，获取指定偏移量上的位(bit)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">getBit</span><span class="params">(String key, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().getBit(key, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量获取</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">multiGet</span><span class="params">(Collection&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().multiGet(keys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置ASCII码, 字符串'a'的ASCII码是97, 转为二进制是'01100001', 此方法是将二进制第offset位值变为value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postion</span></span><br><span class="line"><span class="comment"> *            位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> *            值,true为1, false为0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setBit</span><span class="params">(String key, <span class="keyword">long</span> offset, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().setBit(key, offset, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment"> *            过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment"> *            时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES</span></span><br><span class="line"><span class="comment"> *            秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEx</span><span class="params">(String key, String value, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">redisTemplate.opsForValue().set(key, value, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在 key 不存在时设置 key 的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 之前已经存在返回false,不存在返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIfAbsent</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset</span></span><br><span class="line"><span class="comment"> *            从指定位置开始覆写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRange</span><span class="params">(String key, String value, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">redisTemplate.opsForValue().set(key, value, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字符串的长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">size</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().size(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiSet</span><span class="params">(Map&lt;String, String&gt; maps)</span> </span>&#123;</span><br><span class="line">redisTemplate.opsForValue().multiSet(maps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maps</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 之前已经存在返回false,不存在返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">multiSetIfAbsent</span><span class="params">(Map&lt;String, String&gt; maps)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().multiSetIfAbsent(maps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加(自增长), 负数则为自减</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">incrBy</span><span class="params">(String key, <span class="keyword">long</span> increment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">incrByFloat</span><span class="params">(String key, <span class="keyword">double</span> increment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 追加到末尾</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">append</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForValue().append(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** -------------------hash相关操作------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取存储在哈希表中指定字段的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">hGet</span><span class="params">(String key, String field)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().get(key, field);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有给定字段的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hGetAll</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有给定字段的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fields</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">hMultiGet</span><span class="params">(String key, Collection&lt;Object&gt; fields)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().multiGet(key, fields);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hPut</span><span class="params">(String key, String hashKey, String value)</span> </span>&#123;</span><br><span class="line">redisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hPutAll</span><span class="params">(String key, Map&lt;String, String&gt; maps)</span> </span>&#123;</span><br><span class="line">redisTemplate.opsForHash().putAll(key, maps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 仅当hashKey不存在时才设置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">hPutIfAbsent</span><span class="params">(String key, String hashKey, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().putIfAbsent(key, hashKey, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一个或多个哈希表字段</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fields</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">hDelete</span><span class="params">(String key, Object... fields)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().delete(key, fields);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看哈希表 key 中，指定的字段是否存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hExists</span><span class="params">(String key, String field)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, field);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为哈希表 key 中的指定字段的整数值加上增量 increment</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> increment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">hIncrBy</span><span class="params">(String key, Object field, <span class="keyword">long</span> increment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().increment(key, field, increment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为哈希表 key 中的指定字段的整数值加上增量 increment</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">hIncrByFloat</span><span class="params">(String key, Object field, <span class="keyword">double</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().increment(key, field, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有哈希表中的字段</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">hKeys</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().keys(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表中字段的数量</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">hSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().size(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表中所有值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">hValues</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().values(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代哈希表中的键值对</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Cursor&lt;Entry&lt;Object, Object&gt;&gt; hScan(String key, ScanOptions options) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForHash().scan(key, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ------------------------list相关操作---------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过索引获取列表中的元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取列表指定范围内的元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> *            开始位置, 0是开始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> *            结束位置, -1返回所有</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">lRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储在list头部</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lLeftPush</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().leftPush(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lLeftPushAll</span><span class="params">(String key, String... value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lLeftPushAll</span><span class="params">(String key, Collection&lt;String&gt; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当list存在的时候才加入</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lLeftPushIfPresent</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().leftPushIfPresent(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果pivot存在,再pivot前面添加</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pivot</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lLeftPush</span><span class="params">(String key, String pivot, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().leftPush(key, pivot, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lRightPush</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lRightPushAll</span><span class="params">(String key, String... value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lRightPushAll</span><span class="params">(String key, Collection&lt;String&gt; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为已存在的列表添加值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lRightPushIfPresent</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPushIfPresent(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在pivot元素的右边添加值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pivot</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lRightPush</span><span class="params">(String key, String pivot, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPush(key, pivot, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过索引设置列表元素的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> *            位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lSet</span><span class="params">(String key, <span class="keyword">long</span> index, String value)</span> </span>&#123;</span><br><span class="line">redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移出并获取列表的第一个元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lLeftPop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().leftPop(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment"> *            等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment"> *            时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lBLeftPop</span><span class="params">(String key, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().leftPop(key, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除并获取列表最后一个元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lRightPop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPop(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment"> *            等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment"> *            时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lBRightPop</span><span class="params">(String key, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPop(key, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destinationKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lRightPopAndLeftPush</span><span class="params">(String sourceKey, String destinationKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPopAndLeftPush(sourceKey,</span><br><span class="line">destinationKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destinationKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lBRightPopAndLeftPush</span><span class="params">(String sourceKey, String destinationKey,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().rightPopAndLeftPush(sourceKey,</span><br><span class="line">destinationKey, timeout, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除集合中值等于value得元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> *            index=0, 删除所有值等于value的元素; index&gt;0, 从头部开始删除第一个值等于value的元素;</span></span><br><span class="line"><span class="comment"> *            index&lt;0, 从尾部开始删除第一个值等于value的元素;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> index, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().remove(key, index, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 裁剪list</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lTrim</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">redisTemplate.opsForList().trim(key, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取列表长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lLen</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** --------------------set相关操作-------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set添加元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sAdd</span><span class="params">(String key, String... values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set移除元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除并返回集合的一个随机元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sPop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().pop(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将元素value从一个集合移到另一个集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">sMove</span><span class="params">(String key, String value, String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().move(key, value, destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合的大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断集合是否包含value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">sIsMember</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取两个集合的交集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sIntersect</span><span class="params">(String key, String otherKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().intersect(key, otherKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取key集合与多个集合的交集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sIntersect</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().intersect(key, otherKeys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key集合与otherKey集合的交集存储到destKey集合中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sIntersectAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().intersectAndStore(key, otherKey,</span><br><span class="line">destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key集合与多个集合的交集存储到destKey集合中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sIntersectAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().intersectAndStore(key, otherKeys,</span><br><span class="line">destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取两个集合的并集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sUnion</span><span class="params">(String key, String otherKeys)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取key集合与多个集合的并集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sUnion</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key集合与otherKey集合的并集存储到destKey中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sUnionAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key集合与多个集合的并集存储到destKey中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sUnionAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取两个集合的差集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sDifference</span><span class="params">(String key, String otherKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().difference(key, otherKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取key集合与多个集合的差集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sDifference</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().difference(key, otherKeys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key集合与otherKey集合的差集存储到destKey中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sDifference</span><span class="params">(String key, String otherKey, String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().differenceAndStore(key, otherKey,</span><br><span class="line">destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key集合与多个集合的差集存储到destKey中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">sDifference</span><span class="params">(String key, Collection&lt;String&gt; otherKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().differenceAndStore(key, otherKeys,</span><br><span class="line">destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合所有元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">setMembers</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机获取集合中的一个元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sRandomMember</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().randomMember(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机获取集合中count个元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">sRandomMembers</span><span class="params">(String key, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().randomMembers(key, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机获取集合中count个元素并且去除重复的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sDistinctRandomMembers</span><span class="params">(String key, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().distinctRandomMembers(key, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor&lt;String&gt; <span class="title">sScan</span><span class="params">(String key, ScanOptions options)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForSet().scan(key, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**------------------zSet相关操作--------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素,有序集合是按照元素的score值由小到大排列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> score</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">zAdd</span><span class="params">(String key, String value, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().add(key, value, score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zAdd</span><span class="params">(String key, Set&lt;TypedTuple&lt;String&gt;&gt; values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().add(key, values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().remove(key, values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加元素的score值，并返回增加后的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">zIncrementScore</span><span class="params">(String key, String value, <span class="keyword">double</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().incrementScore(key, value, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 0表示第一位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zRank</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().rank(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回元素在集合的排名,按元素的score值由大到小排列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zReverseRank</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().reverseRank(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合的元素, 从小到大排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> *            开始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> *            结束位置, -1查询所有</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">zRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().range(key, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合元素, 并且把score值也获取</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;TypedTuple&lt;String&gt;&gt; zRangeWithScores(String key, <span class="keyword">long</span> start,</span><br><span class="line"><span class="keyword">long</span> end) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().rangeWithScores(key, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据Score值查询集合元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> *            最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment"> *            最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">zRangeByScore</span><span class="params">(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScore(key, min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据Score值查询集合元素, 从小到大排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> *            最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment"> *            最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,</span><br><span class="line"><span class="keyword">double</span> min, <span class="keyword">double</span> max) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;TypedTuple&lt;String&gt;&gt; zRangeByScoreWithScores(String key,</span><br><span class="line"><span class="keyword">double</span> min, <span class="keyword">double</span> max, <span class="keyword">long</span> start, <span class="keyword">long</span> end) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max,</span><br><span class="line">start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合的元素, 从大到小排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">zReverseRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().reverseRange(key, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合的元素, 从大到小排序, 并返回score值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeWithScores(String key,</span><br><span class="line"><span class="keyword">long</span> start, <span class="keyword">long</span> end) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeWithScores(key, start,</span><br><span class="line">end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据Score值查询集合元素, 从大到小排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">zReverseRangeByScore</span><span class="params">(String key, <span class="keyword">double</span> min,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据Score值查询集合元素, 从大到小排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;TypedTuple&lt;String&gt;&gt; zReverseRangeByScoreWithScores(</span><br><span class="line">String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScoreWithScores(key,</span><br><span class="line">min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">zReverseRangeByScore</span><span class="params">(String key, <span class="keyword">double</span> min,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">double</span> max, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScore(key, min, max,</span><br><span class="line">start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据score值获取集合元素数量</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zCount</span><span class="params">(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().count(key, min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().size(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zZCard</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().zCard(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取集合中value元素的score值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">zScore</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().score(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定索引位置的成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zRemoveRange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().removeRange(key, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定的score值的范围来移除成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zRemoveRangeByScore</span><span class="params">(String key, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().removeRangeByScore(key, min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取key和otherKey的并集并存储在destKey中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zUnionAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zUnionAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet()</span><br><span class="line">.unionAndStore(key, otherKeys, destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zIntersectAndStore</span><span class="params">(String key, String otherKey,</span></span></span><br><span class="line"><span class="function"><span class="params">String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().intersectAndStore(key, otherKey,</span><br><span class="line">destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> otherKeys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">zIntersectAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">String destKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().intersectAndStore(key, otherKeys,</span><br><span class="line">destKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Cursor&lt;TypedTuple&lt;String&gt;&gt; zScan(String key, ScanOptions options) &#123;</span><br><span class="line"><span class="keyword">return</span> redisTemplate.opsForZSet().scan(key, options);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 入门</title>
      <link href="/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%85%A5%E9%97%A8/"/>
      <url>/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMQ-入门全攻略"><a href="#RabbitMQ-入门全攻略" class="headerlink" title="RabbitMQ 入门全攻略"></a>RabbitMQ 入门全攻略</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p><h2 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h2><p>这部分参考了 《RabbitMQ实战指南》这本书的第 1 章和第 2 章。</p><h3 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h3><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p><p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p><ul><li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li><li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们将 RabbitMQ 核心概念的时候详细介绍到。</li><li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li><li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li><li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li><li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li><li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li><li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li></ul><h3 id="RabbitMQ-核心概念"><a href="#RabbitMQ-核心概念" class="headerlink" title="RabbitMQ 核心概念"></a>RabbitMQ 核心概念</h3><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p><p>下面再来看看图1—— RabbitMQ 的整体模型架构。</p><p><a href="https://camo.githubusercontent.com/e4dfa61a9297b9a679fe5f66ad1543787c759770/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f39363338383534362e6a7067" target="_blank" rel="noopener"><img alt="图1-RabbitMQ 的整体模型架构" data-src="https://camo.githubusercontent.com/e4dfa61a9297b9a679fe5f66ad1543787c759770/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f39363338383534362e6a7067" class="lazyload"></a></p><p>下面我会一一介绍上图中的一些概念。</p><h4 id="Producer-和-Consumer"><a href="#Producer-和-Consumer" class="headerlink" title="Producer 和 Consumer"></a>Producer 和 Consumer</h4><ul><li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li><li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li></ul><p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p><h4 id="Exchange-交换器"><a href="#Exchange-交换器" class="headerlink" title="Exchange(交换器)"></a>Exchange(交换器)</h4><p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p><p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。</p><p><strong>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)</strong>，<strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的Exchange转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p><p>Exchange(交换器) 示意图如下：</p><p><a href="https://camo.githubusercontent.com/f8c9661d91d632c2744bea0649333a5d0f2ce898/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f32343030373839392e6a7067" target="_blank" rel="noopener"><img alt="Exchange(交换器) 示意图" data-src="https://camo.githubusercontent.com/f8c9661d91d632c2744bea0649333a5d0f2ce898/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f32343030373839392e6a7067" class="lazyload"></a></p><p>生产者将消息发给交换器的时候，一般会指定一个 <code>RoutingKey(路由键)</code>*<em>，用来指定这个消息的路由规则，而这个 *</em>RoutingKey 需要与交换器类型和绑定键(<code>BindingKey</code>)联合使用才能最终生效。</p><p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p><p>Binding(绑定) 示意图：</p><p><a href="https://camo.githubusercontent.com/effb1066045c449b5439ef94412bef331e912644/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37303535333133342e6a7067" target="_blank" rel="noopener"><img alt="Binding(绑定) 示意图" data-src="https://camo.githubusercontent.com/effb1066045c449b5439ef94412bef331e912644/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37303535333133342e6a7067" class="lazyload"></a></p><p>生产者将消息发送给交换器时，==需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中==。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>简单理解：==信道是connection基于NIO的优化升级，实现连接复用==。</p><p>一个应用程序中有很多个线程需要从RabbitMQ 中消费消息，或者生产消息，那么必然需要建立很多个Connection ，也就是许多个TCP 连接。然而对于操作系统而言，建立和销毁TCP 连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。RabbitMQ 采用类似NIO’ (Non-blocking 1/0) 的做法，选择TCP 连接复用，不仅可以减少性能开销，同时也便于管理。</p><p>每个线程把持一个信道，所以信道复用了Connection 的TCP 连接。同时RabbitMQ 可以确保每个线程的私密性，就像拥有独立的连接一样。当每个信道的流量不是很大时，复用单一的Connection 可以在产生性能瓶颈的情况下有效地节省TCP 连接资源。但是当信道本身的流量很大时，这时候多个信道复用一个Connection 就会产生性能瓶颈，进而使整体的流量被限制了。此时就需要开辟多个Connection ，将这些信道均摊到这些Connection 中， 至于这些相关的调优策略需要根据业务自身的实际情况进行调节。</p><p><strong>RabbitMQ 为什么需要信道？为什么不是TCP直接通信？</strong></p><ol><li><p>TCP的创建和销毁，开销大，创建需要三次握手，销毁需要四次分手</p></li><li><p>如果不使用信道，那么引用程序就会使用TCP的方式连接到rabbitmq，高峰时每秒成千上万条连接会造成资源的巨大浪费(一条tcp消耗资源，成千上万的tcp会非常消耗资源)，而且操作系统每秒处理TCP连接数量也是有限的，必定会造成性能瓶颈</p></li><li><p>信道的原理是一条线程一条信道，多条线程多条信道共同使用一条TCP连接。一条TCP连接可以容纳无限的信道，及时每秒造成成千上万的请求也不会造成性能瓶颈</p></li></ol><h4 id="Queue-消息队列"><a href="#Queue-消息队列" class="headerlink" title="Queue(消息队列)"></a>Queue(消息队列)</h4><p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p><p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。</p><p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p><h4 id="Broker（消息中间件的服务节点）"><a href="#Broker（消息中间件的服务节点）" class="headerlink" title="Broker（消息中间件的服务节点）"></a>Broker（消息中间件的服务节点）</h4><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p><p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p><p><a href="https://camo.githubusercontent.com/6f3125fb04c98886209d26d4e904ce4c4c7343ad/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f36373935323932322e6a7067" target="_blank" rel="noopener"><img alt="消息队列的运转过程" data-src="https://camo.githubusercontent.com/6f3125fb04c98886209d26d4e904ce4c4c7343ad/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f36373935323932322e6a7067" class="lazyload"></a></p><p>这样图1中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p><h4 id="vhost-虚拟主机"><a href="#vhost-虚拟主机" class="headerlink" title="vhost(虚拟主机)"></a>vhost(虚拟主机)</h4><p>虚拟主机，一个消息代理（Broker）里可以开设多个虚拟主机（vhost），用作不同用户的权限分离。可以理解为一个子数据库</p><h4 id="Exchange-Types-交换器类型"><a href="#Exchange-Types-交换器类型" class="headerlink" title="Exchange Types(交换器类型)"></a>Exchange Types(交换器类型)</h4><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p><h5 id="①-fanout（广播）"><a href="#①-fanout（广播）" class="headerlink" title="① fanout（广播）"></a>① fanout（广播）</h5><p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来<code>广播</code>消息。</p><h5 id="②-direct（精准定向）"><a href="#②-direct（精准定向）" class="headerlink" title="② direct（精准定向）"></a>② direct（精准定向）</h5><p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p><p><a href="https://camo.githubusercontent.com/7177328efe9e95372a9b7fb8b51022312d2e601b/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f33373030383032312e6a7067" target="_blank" rel="noopener"><img alt="direct 类型交换器" data-src="https://camo.githubusercontent.com/7177328efe9e95372a9b7fb8b51022312d2e601b/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f33373030383032312e6a7067" class="lazyload"></a></p><p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为”Info”或者”debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p><p>direct 类型常用在<code>处理有优先级的任务</code>，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p><h5 id="③-topic（模糊类型）"><a href="#③-topic（模糊类型）" class="headerlink" title="③ topic（模糊类型）"></a>③ topic（模糊类型）</h5><p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p><ul><li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li><li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li><li>BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li></ul><p><a href="https://camo.githubusercontent.com/ad72829eb75cde62383a48361e3a77708a80f955/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37333834332e6a7067" target="_blank" rel="noopener"><img alt="topic 类型交换器" data-src="https://camo.githubusercontent.com/ad72829eb75cde62383a48361e3a77708a80f955/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37333834332e6a7067" class="lazyload"></a></p><p>以上图为例：</p><ul><li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queuel 和 Queue2;</li><li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li><li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li><li>路由键为 “java.rabbitmq.demo” 的消息只会路由到Queuel中；</li><li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li></ul><h5 id="④-headers-不推荐"><a href="#④-headers-不推荐" class="headerlink" title="④ headers(不推荐)"></a>④ headers(不推荐)</h5><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)’对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、信道才是rabbit通信本质，生产者和消费者都是通过信道完成消息生产消费的。</p><p>2、交换器本质是一张路由查询表（名称和队列id，类似于hash表），这是一个虚拟出来的东西，并不存在真实的交换器。</p><p>3、消息的生命周期：生产者生产消息A 交由信道，信道通过消息（消息由载体和标签）的标签（路由键）放到交换器发送到队列上（其实就是查询匹配，一旦匹配到了规则，信道就直接和队列产生连接，然后将消息发送过去）</p><p>4、Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。</p><h2 id="安装-RabbitMq"><a href="#安装-RabbitMq" class="headerlink" title="安装 RabbitMq"></a>安装 RabbitMq</h2><p>通过 Docker 安装非常方便，只需要几条命令就好了，我这里是只说一下常规安装方法。</p><p>前面提到了 RabbitMQ 是由 Erlang语言编写的，也正因如此，在安装RabbitMQ 之前需要安装 Erlang。</p><p>注意：在安装 RabbitMQ 的时候需要注意 RabbitMQ 和 Erlang 的版本关系，如果不注意的话会导致出错，两者对应关系如下:</p><p><a href="https://camo.githubusercontent.com/4c0efb8ab3642847c70512cdd91e3aac49c4ef52/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f5261626269744d512d45726c616e672e706e67" target="_blank" rel="noopener"><img alt="RabbitMQ 和 Erlang 的版本关系" data-src="https://camo.githubusercontent.com/4c0efb8ab3642847c70512cdd91e3aac49c4ef52/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f5261626269744d512d45726c616e672e706e67" class="lazyload"></a></p><h3 id="安装-erlang"><a href="#安装-erlang" class="headerlink" title="安装 erlang"></a>安装 erlang</h3><p><strong>1 下载 erlang 安装包</strong></p><p>在官网下载然后上传到 Linux 上或者直接使用下面的命令下载对应的版本。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">powershell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">SnailClimb</span> <span class="type">local</span>]<span class="comment">#wget http://erlang.org/download/otp_src_19.3.tar.gz</span></span><br></pre></td></tr></table></figure></div><p>erlang 官网下载：<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">http://www.erlang.org/downloads</a></p><p><strong>2 解压 erlang 安装包</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#tar -xvzf otp_src_19.3.tar.gz</span><br></pre></td></tr></table></figure></div><p><strong>3 删除 erlang 安装包</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#rm -rf otp_src_19.3.tar.gz</span><br></pre></td></tr></table></figure></div><p><strong>4 安装 erlang 的依赖工具</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel</span><br></pre></td></tr></table></figure></div><p><strong>5 进入erlang 安装包解压文件对 erlang 进行安装环境的配置</strong></p><p>新建一个文件夹</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]# mkdir /usr/local/erlang</span><br></pre></td></tr></table></figure></div><p>对 erlang 进行安装环境的配置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# </span><br><span class="line">./configure --prefix=/usr/local/erlang --without-javac</span><br></pre></td></tr></table></figure></div><p><strong>6 编译安装</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></div><p><strong>7 验证一下 erlang 是否安装成功了</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# .&#x2F;bin&#x2F;erl</span><br></pre></td></tr></table></figure></div><p>运行下面的语句输出“hello world”</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io:format(&quot;hello world~n&quot;, []).</span><br></pre></td></tr></table></figure></div><p><a href="https://camo.githubusercontent.com/30edcba9ad0d03b29f5e35991f758378d18a4a73/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f34393537303534312e6a7067" target="_blank" rel="noopener"><img alt="输出“hello world”" data-src="https://camo.githubusercontent.com/30edcba9ad0d03b29f5e35991f758378d18a4a73/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f34393537303534312e6a7067" class="lazyload"></a></p><p>大功告成，我们的 erlang 已经安装完成。</p><p><strong>8 配置 erlang 环境变量</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# vim profile</span><br></pre></td></tr></table></figure></div><p>追加下列环境变量到文件末尾</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#erlang</span><br><span class="line">ERL_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;erlang</span><br><span class="line">PATH&#x3D;$ERL_HOME&#x2F;bin:$PATH</span><br><span class="line">export ERL_HOME PATH</span><br></pre></td></tr></table></figure></div><p>运行下列命令使配置文件<code>profile</code>生效</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></div><p>输入 erl 查看 erlang 环境变量是否配置正确</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# erl</span><br></pre></td></tr></table></figure></div><p><a href="https://camo.githubusercontent.com/6762285cc92cf37942eaa086269654106518e087/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f36323530343234362e6a7067" target="_blank" rel="noopener"><img alt="输入 erl 查看 erlang 环境变量是否配置正确" data-src="https://camo.githubusercontent.com/6762285cc92cf37942eaa086269654106518e087/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f36323530343234362e6a7067" class="lazyload"></a></p><h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><p><strong>1. 下载rpm</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;releases&#x2F;rabbitmq-server&#x2F;v3.6.8&#x2F;rabbitmq-server-3.6.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></div><p>或者直接在官网下载</p><p><a href="https://www.rabbitmq.com/install-rpm.html" target="_blank" rel="noopener">https://www.rabbitmq.com/install-rpm.html</a></p><p><strong>2. 安装rpm</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;rabbitmq-release-signing-key.asc</span><br><span class="line"># 安装socat</span><br><span class="line">yum -y install socat </span><br><span class="line">##此时会报错没有socat包或是找不到socat包，解决方法安装centos的epel的扩展源</span><br><span class="line">yum -y install epel-release  </span><br><span class="line">##之后重新安装socat</span><br><span class="line">yum -y install socat</span><br></pre></td></tr></table></figure></div><p>紧接着执行：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rabbitmq-server-3.6.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></div><p>中途需要你输入”y”才能继续安装。</p><p><strong>3 开启 web 管理插件</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure></div><p>可能会遇到如下错误：</p><p><img alt="image-20200523105232373" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf271s1sjsj317m0bc42d.jpg" class="lazyload"></p><p>重启解决</p><p>service rabbitmq-server restart </p><p>4 设置开机启动</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure></div><p>5 启动服务</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure></div><p>6 查看服务状态</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server status</span><br></pre></td></tr></table></figure></div><p><strong>7. 访问 RabbitMQ 控制台</strong></p><p>浏览器访问：<a href="http://xn--ip-0p3ck01akcu41v:15672/" target="_blank" rel="noopener">http://你的ip地址:15672/</a></p><p>默认用户名和密码： guest/guest;但是需要注意的是：guestuest用户只是被容许从localhost访问。官网文档描述如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“guest” user can only connect via localhost</span><br></pre></td></tr></table></figure></div><p><strong>解决远程访问 RabbitMQ 远程访问密码错误</strong></p><p>新建用户并授权</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb rabbitmq]# rabbitmqctl add_user root root</span><br><span class="line">Creating user &quot;root&quot; ...</span><br><span class="line">[root@SnailClimb rabbitmq]# rabbitmqctl set_user_tags root administrator</span><br><span class="line"></span><br><span class="line">Setting tags for user &quot;root&quot; to [administrator] ...</span><br><span class="line">[root@SnailClimb rabbitmq]# </span><br><span class="line">[root@SnailClimb rabbitmq]# rabbitmqctl set_permissions -p &#x2F; root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">Setting permissions for user &quot;root&quot; in vhost &quot;&#x2F;&quot; ...</span><br></pre></td></tr></table></figure></div><p>再次访问:<a href="http://xn--ip-0p3ck01akcu41v:15672/" target="_blank" rel="noopener">http://你的ip地址:15672/</a> ,输入用户名和密码：root root</p><p><a href="https://camo.githubusercontent.com/7baff40cce00e7196515229aed0cfada49e186bb/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f34353833353333322e6a7067" target="_blank" rel="noopener"><img alt="RabbitMQ控制台" data-src="https://camo.githubusercontent.com/7baff40cce00e7196515229aed0cfada49e186bb/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f34353833353333322e6a7067" class="lazyload"></a></p><h3 id="创建Virtual-Hosts"><a href="#创建Virtual-Hosts" class="headerlink" title="创建Virtual Hosts"></a>创建Virtual Hosts</h3><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2gws378yj31gt0hxdh0.jpg" class="lazyload"></p><p>选中Admin用户，设置权限：</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2gwxsgi1j31fy0mvgmh.jpg" class="lazyload">看到权限已加：</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2gx47a7ij31f70m1q46.jpg" class="lazyload"></p><h3 id="管理界面中的功能"><a href="#管理界面中的功能" class="headerlink" title="管理界面中的功能"></a>管理界面中的功能</h3><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2gx9cfevj30nq0da0th.jpg" class="lazyload"></p><h2 id="学习五种队列"><a href="#学习五种队列" class="headerlink" title="学习五种队列"></a>学习五种队列</h2><h3 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h3><p><img alt="image-20200523163811355" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2h1cyledj30j806g3yy.jpg" class="lazyload"></p><p>P：消息的生产者<br>C：消息的消费者<br>红色：队列</p><p>生产者将消息发送到队列，消费者从队列中获取消息。</p><p>生产者一一对应消费者</p><h4 id="导入RabbitMQ的客户端依赖"><a href="#导入RabbitMQ的客户端依赖" class="headerlink" title="导入RabbitMQ的客户端依赖"></a>导入RabbitMQ的客户端依赖</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="获取MQ的连接"><a href="#获取MQ的连接" class="headerlink" title="获取MQ的连接"></a>获取MQ的连接</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zpc.rabbitmq.util;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"testhost"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        <span class="comment">// 通过工程获取连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="生产者发送消息到队列"><a href="#生产者发送消息到队列" class="headerlink" title="生产者发送消息到队列"></a>生产者发送消息到队列</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"q_test_01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>管理工具中查看消息</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2p37jt4aj30ro0dmwf3.jpg" class="lazyload"></p><p>点击上面的队列名称，查询具体的队列中的信息：</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2p3ehzytj30n10h7mxl.jpg" class="lazyload"></p><p>消费者从队列中获取消息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"q_test_01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列（队列连接到信道上）</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明consumer</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  启动消费者监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="WorkQueue-轮询分发"><a href="#WorkQueue-轮询分发" class="headerlink" title="WorkQueue(轮询分发)"></a>WorkQueue(轮询分发)</h3><p><img alt="image-20200524085511793" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf399wtve5j30js08agn8.jpg" class="lazyload"></p><p>一个生产者、2个消费者。一个消息只能被一个消费者获取。</p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>向队列中发送50条消息。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkSend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_work"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String message = <span class="string">""</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(i * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkRecv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_work"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个消费者</span></span><br><span class="line">        Consumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">"[1] Recv msg : "</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟处理消息，花费2S</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[1] done!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  启动消费者监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkRecv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_work"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个消费者</span></span><br><span class="line">        Consumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">"[2] Recv msg : "</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟处理消息，花费1S</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[2] done!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  启动消费者监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="测试及结果分析"><a href="#测试及结果分析" class="headerlink" title="测试及结果分析"></a>测试及结果分析</h4><p>测试结果：<br>    1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。<br>    2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。</p><p>其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。<br>RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即<code>轮询（round-robin）分发</code>消息。</p><p>怎样才能做到按照每个消费者的能力分配消息呢？</p><p>​        联合使用 Qos 和 Acknowledge 就可以做到。<br>​        <code>basicQos方法</code>设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 <code>prefetchCount</code> 参数就是用来限制这批未确认消息数量的。设为1时，<strong>队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息</strong>。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。</p><p>2个概念</p><p><code>轮询分发</code> ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。</p><p><code>公平分发</code> ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。</p><p>为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。<br>还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。</p><h3 id="Work模式的“能者多劳”"><a href="#Work模式的“能者多劳”" class="headerlink" title="Work模式的“能者多劳”"></a>Work模式的“能者多劳”</h3><p>打开上述代码的注释：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一时刻服务器只会发一条消息给消费者</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启这行 表示使用手动确认模式</span></span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听队列，false表示手动返回完成状态，true表示自动</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br></pre></td></tr></table></figure></div><p>测试：<br>消费者1比消费者2获取的消息更多。</p><h4 id="消息的确认模式"><a href="#消息的确认模式" class="headerlink" title="消息的确认模式"></a>消息的确认模式</h4><p>消费者从队列中获取消息，服务端如何知道消息已经被消费呢？</p><p>模式1：自动确认<br>只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。<br>模式2：手动确认<br>消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。</p><p>手动模式：</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4glg31ixj30o50bfgma.jpg" class="lazyload"></p><p>自动模式：</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4glk5mlrj30nk088wev.jpg" class="lazyload"></p><h3 id="订阅模式-fanout-Exchange"><a href="#订阅模式-fanout-Exchange" class="headerlink" title="订阅模式(fanout Exchange)"></a>订阅模式(fanout Exchange)</h3><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4glwdnkjj30da05ajrh.jpg" class="lazyload"></p><p>解读：<br>1、1个生产者，多个消费者<br>2、每一个消费者都有自己的一个队列<br>3、生产者没有将消息直接发送到队列，而是发送到了交换机<br>4、每个队列都要绑定到交换机<br>5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的<br>注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4ngyyrtdj30cl08m0t2.jpg" class="lazyload"></p><p>5.6.2.消息的生产者（看作是后台系统）<br>向交换机中发送消息。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zpc.rabbitmq.subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zpc.rabbitmq.util.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明exchange</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。<br>5.6.3.消费者1（看作是前台系统）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zpc.rabbitmq.subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zpc.rabbitmq.util.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_work1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一时刻服务器只会发一条消息给消费者</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">// 监听队列，手动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">" [Recv] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>5.6.4.消费者2（看作是搜索系统）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zpc.rabbitmq.subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zpc.rabbitmq.util.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_work2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一时刻服务器只会发一条消息给消费者</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">// 监听队列，手动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">" [Recv2] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>测试<br>测试结果：<br>同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</p><p>在管理工具中查看队列和交换机的绑定关系：</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nmbp25lj30t90lk0tg.jpg" class="lazyload"></p><h3 id="路由模式-diect-Exchange"><a href="#路由模式-diect-Exchange" class="headerlink" title="路由模式(diect Exchange)"></a>路由模式(diect Exchange)</h3><p>交换机根据匹配规则路由到指定符合的队列中</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4noqkxcsj30cl07ijrn.jpg" class="lazyload"></p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4np44hdjj30ut093taa.jpg" class="lazyload"></p><p>生产者</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nq1mleij30q60cjgmg.jpg" class="lazyload"></p><p>消费者1(假设是前台系统)</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nq89ipmj30p40emdgt.jpg" class="lazyload"></p><p>消费2（假设是搜索系统）</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nr21netj30oi0eojse.jpg" class="lazyload"></p><h3 id="Topic-主题-通配符模式"><a href="#Topic-主题-通配符模式" class="headerlink" title="Topic(主题\通配符模式)"></a>Topic(主题\通配符模式)</h3><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nshrcitj30u702zdfq.jpg" class="lazyload"></p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nsp7itfj30f9087t9w.jpg" class="lazyload"></p><p>同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</p><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nsy77jbj30sw07f75m.jpg" class="lazyload"></p><p>生产者</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明exchange</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello World!!"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"routekey.1"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>消费者1（前台系统）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_topic_work_1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"routekey.*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一时刻服务器只会发一条消息给消费者</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">// 监听队列，手动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">" [Recv_x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>消费者2（搜索系统）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_topic_work_2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"*.*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一时刻服务器只会发一条消息给消费者</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        <span class="comment">// 监听队列，手动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">" [Recv2_x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Spring集成RabbitMQ"><a href="#Spring集成RabbitMQ" class="headerlink" title="Spring集成RabbitMQ"></a>Spring集成RabbitMQ</h2><p>参考链接,这里不做演示:</p><p><a href="https://blog.csdn.net/hellozpc/article/details/81436980" target="_blank" rel="noopener">https://blog.csdn.net/hellozpc/article/details/81436980</a></p><h2 id="SpringBoot集成RabbitMQ"><a href="#SpringBoot集成RabbitMQ" class="headerlink" title="SpringBoot集成RabbitMQ"></a>SpringBoot集成RabbitMQ</h2><h3 id="引入rabbitmq"><a href="#引入rabbitmq" class="headerlink" title="引入rabbitmq"></a>引入rabbitmq</h3><p>1、配置pom文件，主要是添加spring-boot-starter-amqp的支持</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>2、配置application.properties文件,配置rabbitmq的安装地址、端口以及账户信息,数据库信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">properties</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">spirng-boot-rabbitmq</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">172.16.219.215</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">testhost</span></span><br></pre></td></tr></table></figure></div><h3 id="简单队列-1"><a href="#简单队列-1" class="headerlink" title="简单队列"></a>简单队列</h3><p>1、配置队列</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">helloQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">neoQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"neo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">objectQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>2、发送者</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.rabbit.hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line"><span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"hello3"</span>, context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>3、消费者</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.rabbit.hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello3"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver  : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>4、测试</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.neo.rabbit.hello.HelloSender;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloSender helloSender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">helloSender.send();</span><br><span class="line"><span class="comment">// 等待三秒，使消费者确定可以消费到数据</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">System.out.println(<span class="string">"exit"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>其他见自己的工程spring-boot-rabbitmq</strong></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h2><p>常用队列形式:</p><p>1、1对1</p><ul><li>简单队列: sender –&gt; queue –&gt; consumer</li><li>exchange的diect模式:sender –&gt; exchange –&gt; queue –&gt; consumer</li></ul><p>2、1对多</p><ul><li>简单队列: sender –&gt; queue –&gt; 多个consumer(默认轮询)</li><li>简单队列: sender –&gt; queue –&gt; 多个consumer(能者多劳,关闭自动ack)</li><li>exchange的订阅模式(fanout Exchange)</li><li>exchange的Topic(主题\通配符模式)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM问题排查</title>
      <link href="/2020/01/15/6.%20JVM/JVM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2020/01/15/6.%20JVM/JVM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-应用线上问题排查思路、工具小结"><a href="#Java-应用线上问题排查思路、工具小结" class="headerlink" title="Java 应用线上问题排查思路、工具小结"></a>Java 应用线上问题排查思路、工具小结</h2><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h2 id="一、CPU-利用率高-飙升"><a href="#一、CPU-利用率高-飙升" class="headerlink" title="一、CPU 利用率高/飙升"></a>一、CPU 利用率高/飙升</h2><blockquote><p>❝</p><p>注：CPU使用率是衡量系统繁忙程度的重要指标。但是「CPU使用率的安全阈值是相对的，取决于你的系统的IO密集型还是计算密集型」。一般计算密集型应用CPU使用率偏高load偏低，IO密集型相反。</p><p>❞</p></blockquote><p><strong>「常见原因：」</strong></p><ul><li>频繁 gc</li><li>死循环、线程阻塞、io wait…etc</li></ul><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>这里为了演示，用一个最简单的死循环来模拟CPU飙升的场景，下面是模拟代码，</p><p>在一个最简单的SpringBoot Web 项目中增加<code>CpuReaper</code>这个类，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 模拟 cpu 飙升场景</span><br><span class="line"> * @author Richard_yyf</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class CpuReaper &#123;</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void cpuReaper() &#123;</span><br><span class="line">        int num &#x3D; 0;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis() &#x2F; 1000;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            num &#x3D; num + 1;</span><br><span class="line">            if (num &#x3D;&#x3D; Integer.MAX_VALUE) &#123;</span><br><span class="line">                System.out.println(&quot;reset&quot;);</span><br><span class="line">                num &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((System.currentTimeMillis() &#x2F; 1000) - start &gt; 1000) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打包成jar之后，在服务器上运行。<code>java -jar cpu-reaper.jar &amp;</code></p><h3 id="第一步：定位出问题的线程"><a href="#第一步：定位出问题的线程" class="headerlink" title="第一步：定位出问题的线程"></a>第一步：定位出问题的线程</h3><h4 id="方法-a-传统的方法"><a href="#方法-a-传统的方法" class="headerlink" title="方法 a: 传统的方法"></a>方法 a: 传统的方法</h4><ol><li><code>top</code> 定位CPU 最高的进程<br>执行<code>top</code>命令，查看所有进程占系统CPU的排序，定位是哪个进程搞的鬼。在本例中就是咱们的java进程。PID那一列就是进程号。(对指示符含义不清楚的见【附录】)</li></ol><p><img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735359-fdd23910-83f0-4ca8-a375-78448ec5175d.jpeg" class="lazyload"></p><ol><li><code>top -Hp pid</code> 定位使用 CPU 最高的线程</li></ol><p><img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735358-b1c929e5-adaf-490a-8bcc-4035129a0a3b.jpeg" class="lazyload"></p><ol><li><code>printf &#39;0x%x&#39; tid</code> 线程 id 转化 16 进制</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; printf &#39;0x%x&#39; 12817</span><br><span class="line">   &gt; 0x3211</span><br></pre></td></tr></table></figure></div><ol><li><code>jstack pid | grep tid</code> 找到线程堆栈</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; jstack 12816 | grep 0x3211 -A 30</span><br></pre></td></tr></table></figure></div><p><img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735377-cab7fdab-fcec-4bcf-a1bb-3441989c2568.jpeg" class="lazyload"></p><h4 id="方法-b-show-busy-java-threads"><a href="#方法-b-show-busy-java-threads" class="headerlink" title="方法 b: show-busy-java-threads"></a>方法 b: show-busy-java-threads</h4><p>这个脚本来自于github上一个开源项目，项目提供了很多有用的脚本，<code>show-busy-java-threads</code>就是其中的一个。使用这个脚本，可以直接简化方法A中的繁琐步骤。如下，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget --no-check-certificate https:&#x2F;&#x2F;raw.github.com&#x2F;oldratlee&#x2F;useful-scripts&#x2F;release-2.x&#x2F;bin&#x2F;show-busy-java-threads</span><br><span class="line">&gt; chmod +x show-busy-java-threads</span><br><span class="line">&gt; .&#x2F;show-busy-java-threads</span><br></pre></td></tr></table></figure></div><p><img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735395-15f42225-a5d7-4539-9ec3-3628f8557bd1.jpeg" class="lazyload">image.png</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show-busy-java-threads</span><br><span class="line"># 从所有运行的Java进程中找出最消耗CPU的线程（缺省5个），打印出其线程栈</span><br><span class="line"># 缺省会自动从所有的Java进程中找出最消耗CPU的线程，这样用更方便</span><br><span class="line"># 当然你可以手动指定要分析的Java进程Id，以保证只会显示你关心的那个Java进程的信息</span><br><span class="line">show-busy-java-threads -p &lt;指定的Java进程Id&gt;</span><br><span class="line">show-busy-java-threads -c &lt;要显示的线程栈数&gt;</span><br></pre></td></tr></table></figure></div><h4 id="方法-c-arthas-thread"><a href="#方法-c-arthas-thread" class="headerlink" title="方法 c: arthas thread"></a>方法 c: arthas <code>thread</code></h4><p>阿里开源的arthas现在已经几乎包揽了我们线上排查问题的工作，提供了一个很完整的工具集。在这个场景中，也只需要一个<code>thread -n</code>命令即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -O https:&#x2F;&#x2F;arthas.gitee.io&#x2F;arthas-boot.jar # 下载</span><br></pre></td></tr></table></figure></div><p><img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735374-b6c7f168-c904-4bcc-a541-b92c7e614160.jpeg" class="lazyload">image.png</p><blockquote><p>❝</p><p>要注意的是，arthas的cpu占比，和前面两种cpu占比统计方式不同。前面两种针对的是Java进程启动开始到现在的cpu占比情况，arthas这种是一段采样间隔内，当前JVM里各个线程所占用的cpu时间占总cpu时间的百分比。</p><p>具体见官网：<a href="https://alibaba.github.io/arthas/thread.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/thread.html</a></p><p>❞</p></blockquote><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>通过第一步，找出有问题的代码之后，观察到线程栈之后。我们「就要根据具体问题来具体分析」。这里举几个例子。</p><h4 id="情况一：发现使用CPU最高的都是GC-线程。"><a href="#情况一：发现使用CPU最高的都是GC-线程。" class="headerlink" title="情况一：发现使用CPU最高的都是GC 线程。"></a>情况一：发现使用CPU最高的都是GC 线程。</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GC task thread#0 (ParallelGC)&quot; os_prio&#x3D;0 tid&#x3D;0x00007fd99001f800 nid&#x3D;0x779 runnable</span><br><span class="line">GC task thread#1 (ParallelGC)&quot; os_prio&#x3D;0 tid&#x3D;0x00007fd990021800 nid&#x3D;0x77a runnable</span><br><span class="line">GC task thread#2 (ParallelGC)&quot; os_prio&#x3D;0 tid&#x3D;0x00007fd990023000 nid&#x3D;0x77b runnable</span><br><span class="line">GC task thread#3 (ParallelGC)&quot; os_prio&#x3D;0 tid&#x3D;0x00007fd990025000 nid&#x3D;0x77c runnabl</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></div><p>gc 排查的内容较多，所以我决定在后面单独列一节讲述。</p><h4 id="情况二：发现使用CPU最高的是业务线程"><a href="#情况二：发现使用CPU最高的是业务线程" class="headerlink" title="情况二：发现使用CPU最高的是业务线程"></a>情况二：发现使用CPU最高的是业务线程</h4><ul><li><p>io wait</p></li><li><ul><li>比如此例中，就是因为磁盘空间不够导致的io阻塞</li></ul></li><li><p>等待内核态锁，如 synchronized</p></li><li><ul><li><code>jstack -l pid | grep BLOCKED</code> 查看阻塞态线程堆栈</li><li>dump 线程栈，分析线程持锁情况。</li><li>arthas提供了<code>thread -b</code>，可以找出当前阻塞其他线程的线程。针对 synchronized 情况</li></ul></li></ul><h2 id="二、频繁-GC"><a href="#二、频繁-GC" class="headerlink" title="二、频繁 GC"></a>二、频繁 GC</h2><h3 id="1-回顾GC流程"><a href="#1-回顾GC流程" class="headerlink" title="1. 回顾GC流程"></a>1. 回顾GC流程</h3><p>在了解下面内容之前，请先花点时间回顾一下GC的整个流程。</p><p><img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735415-ccfa296f-6a89-483d-80a0-b62ec7ab5774.jpeg" class="lazyload">image.png</p><p>接前面的内容，这个情况下，我们自然而然想到去查看gc 的具体情况。</p><ul><li>方法a : 查看gc 日志</li><li>方法b : <code>jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计</code></li><li>方法c : 如果所在公司有对应用进行监控的组件当然更方便（比如Prometheus + Grafana）</li></ul><p>这里对开启 gc log 进行补充说明。一个常常被讨论的问题（惯性思维）是在生产环境中GC日志是否应该开启。因为它所产生的开销通常都非常有限，因此我的答案是需要<strong>「开启」</strong>。但并不一定在启动JVM时就必须指定GC日志参数。</p><blockquote><p>❝</p><p>HotSpot JVM有一类特别的参数叫做可管理的参数。对于这些参数，可以在运行时修改他们的值。我们这里所讨论的所有参数以及以“PrintGC”开头的参数都是可管理的参数。这样在任何时候我们都可以开启或是关闭GC日志。比如我们可以使用JDK自带的jinfo工具来设置这些参数，或者是通过JMX客户端调用<code>HotSpotDiagnostic MXBean的</code>setVMOption方法来设置这些参数。</p><p>这里再次大赞arthas❤️，它提供的<code>vmoption</code>命令可以直接查看，更新VM诊断相关的参数。</p><p>❞</p></blockquote><p>获取到gc日志之后，可以上传到GC easy帮助分析，得到可视化的图表分析结果。</p><p><img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735400-1bb857d8-ef45-4c66-9584-07f6b6e626c0.jpeg" class="lazyload">)image.png<img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735428-988e30ff-7e86-4eda-9c20-94c9bde82175.jpeg" class="lazyload">image.png</p><h3 id="2-GC-原因及定位"><a href="#2-GC-原因及定位" class="headerlink" title="2. GC 原因及定位"></a>2. GC 原因及定位</h3><p><strong>「prommotion failed」</strong></p><p>从S区晋升的对象在老年代也放不下导致 FullGC（fgc 回收无效则抛 OOM）。</p><p>可能原因：</p><ul><li><strong>「survivor 区太小，对象过早进入老年代」</strong><br>查看 SurvivorRatio 参数</li><li><strong>「大对象分配，没有足够的内存」</strong><br>dump 堆，profiler/MAT 分析对象占用情况</li><li><strong>「old 区存在大量对象」</strong><br>dump 堆，profiler/MAT 分析对象占用情况</li></ul><p>你也可以从full GC 的效果来推断问题，正常情况下，一次full GC应该会回收大量内存，所以 <strong>「正常的堆内存曲线应该是呈锯齿形」</strong>。如果你发现full gc 之后堆内存几乎没有下降，那么可以推断：<strong>「堆中有大量不能回收的对象且在不停膨胀，使堆的使用占比超过full GC的触发阈值，但又回收不掉，导致full GC一直执行。</strong>「换句话来说，可能是」<strong>内存泄露」</strong>了。</p><p>一般来说，GC相关的异常推断都需要涉及到<strong>「内存分析」</strong>，使用<code>jmap</code>之类的工具dump出内存快照（或者 Arthas的<code>heapdump</code>）命令，然后使用MAT、JProfiler、JVisualVM等可视化内存分析工具。</p><p>至于内存分析之后的步骤，就需要小伙伴们根据具体问题具体分析啦。</p><h2 id="三、线程池异常"><a href="#三、线程池异常" class="headerlink" title="三、线程池异常"></a>三、线程池异常</h2><p>Java 线程池以有界队列的线程池为例，当新任务提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求。如果正在运行的线程数等于 corePoolSize 时，则新任务被添加到队列中，直到队列满。当队列满了后，会继续开辟新线程来处理任务，但不超过 maximumPoolSize。当任务队列满了并且已开辟了最大线程数，此时又来了新任务，ThreadPoolExecutor 会拒绝服务。</p><h3 id="常见问题和原因"><a href="#常见问题和原因" class="headerlink" title="常见问题和原因"></a>常见问题和原因</h3><p>这种线程池异常，一般有以下几种原因：</p><ol><li><strong>「下游服务 响应时间（RT）过长」</strong><br>这种情况有可能是因为下游服务异常导致的，作为消费者我们要设置合适的超时时间和熔断降级机制。<br>另外针对这种情况，一般都要有对应的监控机制：比如日志监控、metrics监控告警等，不要等到目标用户感觉到异常，从外部反映进来问题才去看日志查。</li><li><strong>「数据库慢 sql 或者数据库死锁」</strong></li></ol><p>查看日志关键词</p><ol><li><strong>「Java 代码死锁」</strong><br><code>jstack –l pid | grep -i –E &#39;BLOCKED | deadlock&#39;</code></li></ol><p>上述前两种问题的排查办法，一般都是通过查看日志或者一些监控组件。</p><h2 id="四、常见问题恢复"><a href="#四、常见问题恢复" class="headerlink" title="四、常见问题恢复"></a>四、常见问题恢复</h2><blockquote><p>❝</p><p>这一部分内容参考自此篇文章</p><p>❞</p></blockquote><p><img alt="img" data-src="https://cdn.nlark.com/yuque/0/2020/jpeg/1729662/1594799735404-55b9d465-ad5f-4e08-aafb-793b511922ea.jpeg" class="lazyload">image.png</p><h2 id="五、Arthas"><a href="#五、Arthas" class="headerlink" title="五、Arthas"></a>五、Arthas</h2><p>这里还是想单独用一节安利一下Arthas这个工具。</p><p>Arthas 是阿里巴巴开源的Java 诊断工具，基于 Java Agent 方式，使用 Instrumentation 方式修改字节码方式进行 Java 应用诊断。</p><ul><li>dashboard ：系统实时数据面板, 可查看线程，内存，gc 等信息</li><li>thread ：查看当前线程信息，查看线程的堆栈，如查看最繁忙的前 n 线程</li><li>getstatic：获取静态属性值，如 <code>getstatic className attrName</code> 可用于查看线上开关真实值</li><li>sc：查看 jvm 已加载类信息，可用于排查 jar 包冲突</li><li>sm：查看 jvm 已加载类的方法信息</li><li>jad：反编译 jvm 加载类信息,排查代码逻辑没执行原因</li><li>logger：查看logger信息，更新logger level</li><li>watch：观测方法执行数据，包含出参、入参、异常等</li><li>trace：方法内部调用时长，并输出每个节点的耗时，用于性能分析</li><li>tt：用于记录方法，并做回放</li></ul><blockquote><p>❝</p><p>以上内容节选自Arthas官方文档。</p><p>❞</p></blockquote><p>另外，<em>Arthas*里的 还集成了 *ognl</em> 这个轻量级的表达式引擎，通过ognl，你可以用arthas 实现很多的“骚”操作。</p><p>其他的这里就不多说了，感兴趣的可以去看看arthas的官方文档、github issue。</p><h2 id="六、涉及工具"><a href="#六、涉及工具" class="headerlink" title="六、涉及工具"></a>六、涉及工具</h2><p>再说下一些工具。</p><ul><li>Arthas（超级推荐❤️❤️）</li><li>useful-scripts</li><li>GC easy</li><li>Smart Java thread dump analyzer - thread dump analysis in seconds</li><li>PerfMa - Java虚拟机参数/线程dump/内存dump分析</li><li>Linux 命令</li><li>Java N 板斧</li><li>MAT、JProfiler…等可视化内存分析工具</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我知道我这篇文章对于线上异常的归纳并不全面，还有<strong>「网络（超时、TCP队列溢出…）」</strong>、堆外内存等很多的异常场景没有涉及。主要是因为自己接触很少，没有深刻体会研究过，强行写出来免不得会差点意思，更怕的是误了别人😅。</p><p>还有想说的就是，Java 应用线上排查实际非常考究一个人基础是否扎实、解决问题能力是否过关。比如线程池运行机制、gc分析、Java 内存分析等等，如果基础不扎实，看了更多的是一头雾水。另外就是，多看看网上一些好的关于异常排查的经验文章，这样即使自己暂时遇不到，但是会在脑海里面慢慢总结出一套解决类似问题的结构框架，到时候真的遇到了，也就是触类旁通的事情罢了。</p><blockquote><p>❝</p><p>如果本文有帮助到你，希望能点个赞，这是对我的最大动力🤝🤝🤗🤗。</p><p>❞</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.aliyun.com/article/757655" target="_blank" rel="noopener">https://developer.aliyun.com/article/757655</a></li><li>Arthas 3.2.0 文档</li><li>《分布式服务架构：原理、设计与实战》</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="top-命令显示的指示符的含义"><a href="#top-命令显示的指示符的含义" class="headerlink" title="top 命令显示的指示符的含义"></a>top 命令显示的指示符的含义</h3><table><thead><tr><th>指示符</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程id</td></tr><tr><td>USER</td><td>进程所有者</td></tr><tr><td>PR</td><td>进程优先级</td></tr><tr><td>NI</td><td>nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>VIRT</td><td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr><tr><td>RES</td><td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td></tr><tr><td>SHR</td><td>共享内存大小，单位kb</td></tr><tr><td>S</td><td>进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</td></tr><tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr><tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr><tr><td>TIME+</td><td>进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td>COMMAND</td><td>进程名称（命令名/命令行）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局异常处理</title>
      <link href="/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h1><p>软件开发过程中，不可避免的是需要处理各种异常，就我自己来说，至少有一半以上的时间都是在处理各种异常情况，所以代码中就会出现大量的<code>try {...} catch {...} finally {...}</code> 代码块，不仅有大量的冗余代码，而且还影响代码的可读性。比较下面两张图，看看您现在编写的代码属于哪一种风格？然后哪种编码风格您更喜欢？</p><p>丑陋的 try catch 代码块</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsgqduDKIAmIibeDmTvPssaDQS6AZagVnNseg1OUbsiadgRwGdicoicmYys49ZiadT47nGLj6wVTvDpibFWQ/640?wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload">优雅的Controller</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/oTKHc6F8tsgqduDKIAmIibeDmTvPssaDQxcuGb3IjKB8loibofWf6GDAmKox1Vl6REOQfLHjlHia22NWic0XQJ5Vvw/640?wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload">上面的示例，还只是在<code>Controller</code>层，如果是在<code>Service</code>层，可能会有更多的<code>try catch</code>代码块。这将会严重影响代码的可读性、“美观性”。</p><p>所以如果是我的话，我肯定偏向于第二种，我可以把更多的精力放在业务代码的开发，同时代码也会变得更加简洁。</p><p>既然业务代码不显式地对异常进行捕获、处理，而异常肯定还是处理的，不然系统岂不是动不动就崩溃了，所以必须得有其他地方捕获并处理这些异常。公众号（Java后端）还发布过很多编程技巧文章，关注「Java后端」回复 666 下载。</p><p>那么问题来了，如何优雅的处理各种异常？</p><h2 id="什么是统一异常处理"><a href="#什么是统一异常处理" class="headerlink" title="什么是统一异常处理"></a><strong>什么是统一异常处理</strong></h2><p><code>Spring</code>在3.2版本增加了一个注解<code>@ControllerAdvice</code>，可以与<code>@ExceptionHandler</code>、<code>@InitBinder</code>、<code>@ModelAttribute</code> 等注解注解配套使用，对于这几个注解的作用，这里不做过多赘述，若有不了解的，可以参考Spring3.2新注解@ControllerAdvice，先大概有个了解。</p><p>不过跟异常处理相关的只有注解<code>@ExceptionHandler</code>，从字面上看，就是 <strong>异常处理器</strong> 的意思，其实际作用也是：若在某个<code>Controller</code>类定义一个异常处理方法，并在方法上添加该注解，那么当出现指定的异常时，会执行该处理异常的方法，其可以使用springmvc提供的数据绑定，比如注入HttpServletRequest等，还可以接受一个当前抛出的Throwable对象。</p><p>但是，这样一来，就必须在每一个<code>Controller</code>类都定义一套这样的异常处理方法，因为异常可以是各种各样。这样一来，就会造成大量的冗余代码，而且若需要新增一种异常的处理逻辑，就必须修改所有<code>Controller</code>类了，很不优雅。</p><p>当然你可能会说，那就定义个类似<code>BaseController</code>的基类，这样总行了吧。</p><p>这种做法虽然没错，但仍不尽善尽美，因为这样的代码有一定的侵入性和耦合性。简简单单的<code>Controller</code>，我为啥非得继承这样一个类呢，万一已经继承其他基类了呢。大家都知道<code>Java</code>只能继承一个类。</p><p>那有没有一种方案，既不需要跟<code>Controller</code>耦合，也可以将定义的 <strong>异常处理器</strong> 应用到所有控制器呢？所以注解<code>@ControllerAdvice</code>出现了，简单的说，该注解可以把异常处理器应用到所有控制器，而不是单个控制器。借助该注解，我们可以实现：在独立的某个地方，比如单独一个类，定义一套对各种异常的处理机制，然后在类的签名加上注解<code>@ControllerAdvice</code>，统一对 <code>不同阶段的</code>、<code>不同异常</code> 进行处理。这就是统一异常处理的原理。</p><p>注意到上面对异常按阶段进行分类，大体可以分成：进入<code>Controller</code>前的异常 和 <code>Service</code> 层异常，具体可以参考下图：</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>不同阶段的异常</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h2><p>消灭95%以上的 <code>try catch</code> 代码块，以优雅的 <code>Assert</code>(断言) 方式来校验业务的异常情况，只关注业务逻辑，而不用花费大量精力写冗余的 <code>try catch</code> 代码块。</p><h2 id="统一异常处理实战"><a href="#统一异常处理实战" class="headerlink" title="统一异常处理实战"></a><strong>统一异常处理实战</strong></h2><p>在定义统一异常处理类之前，先来介绍一下如何优雅的判定异常情况并抛异常。</p><h3 id="用-Assert-断言-替换-throw-exception"><a href="#用-Assert-断言-替换-throw-exception" class="headerlink" title="用 Assert(断言) 替换 throw exception"></a><strong>用 Assert(断言) 替换 throw exception</strong></h3><p>想必 <code>Assert(断言)</code> 大家都很熟悉，比如 <code>Spring</code> 家族的 <code>org.springframework.util.Assert</code>，在我们写测试用例的时候经常会用到，使用断言能让我们编码的时候有一种非一般丝滑的感觉，比如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        User user = userDao.selectById(userId);</span><br><span class="line">        Assert.notNull(user, <span class="string">"用户不存在."</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 另一种写法</span></span><br><span class="line">        User user = userDao.selectById(userId);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"用户不存在."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>有没有感觉第一种判定非空的写法很优雅，第二种写法则是相对丑陋的 <code>if {...}</code> 代码块。那么<br>神奇的 <code>Assert.notNull()</code> 背后到底做了什么呢？下面是 <code>Assert</code> 的部分源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Assert &#123;</span><br><span class="line">    public Assert() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void notNull(@Nullable Object object, String message) &#123;</span><br><span class="line">        if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>可以看到，<code>Assert</code> 其实就是帮我们把 <code>if {...}</code> 封装了一下，是不是很神奇。虽然很简单，但不可否认的是编码体验至少提升了一个档次。那么我们能不能模仿<code>org.springframework.util.Assert</code>，也写一个断言类，不过断言失败后抛出的异常不是<code>IllegalArgumentException</code> 这些内置异常，而是我们自己定义的异常。下面让我们来尝试一下。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Assert</span><br><span class="line">public interface Assert &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建异常</span><br><span class="line">     * @param args</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BaseException newException(Object... args);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建异常</span><br><span class="line">     * @param t</span><br><span class="line">     * @param args</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BaseException newException(Throwable t, Object... args);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &lt;p&gt;断言对象&lt;code&gt;obj&lt;&#x2F;code&gt;非空。如果对象&lt;code&gt;obj&lt;&#x2F;code&gt;为空，则抛出异常</span><br><span class="line">     *</span><br><span class="line">     * @param obj 待判断对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default void assertNotNull(Object obj) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw newException(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &lt;p&gt;断言对象&lt;code&gt;obj&lt;&#x2F;code&gt;非空。如果对象&lt;code&gt;obj&lt;&#x2F;code&gt;为空，则抛出异常</span><br><span class="line">     * &lt;p&gt;异常信息&lt;code&gt;message&lt;&#x2F;code&gt;支持传递参数方式，避免在判断之前进行字符串拼接操作</span><br><span class="line">     *</span><br><span class="line">     * @param obj 待判断对象</span><br><span class="line">     * @param args message占位符对应的参数列表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default void assertNotNull(Object obj, Object... args) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw newException(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面的<code>Assert</code>断言方法是使用接口的默认方法定义的，然后有没有发现当断言失败后，抛出的异常不是具体的某个异常，而是交由2个<code>newException</code>接口方法提供。因为业务逻辑中出现的异常基本都是对应特定的场景，比如根据用户id获取用户信息，查询结果为<code>null</code>，此时抛出的异常可能为<code>UserNotFoundException</code>，并且有特定的异常码（比如7001）和异常信息“用户不存在”。所以具体抛出什么异常，有<code>Assert</code>的实现类决定。（此处推荐一下前日的文章 去掉烦人的 !=null）</p><p>看到这里，您可能会有这样的疑问，按照上面的说法，那岂不是有多少异常情况，就得有定义等量的断言类和异常类，这显然是反人类的，这也没想象中高明嘛。别急，且听我细细道来。</p><h4 id="善解人意的Enum"><a href="#善解人意的Enum" class="headerlink" title="善解人意的Enum"></a><strong>善解人意的Enum</strong></h4><p>自定义异常<code>BaseException</code>有2个属性，即<code>code</code>、<code>message</code>，这样一对属性，有没有想到什么类一般也会定义这2个属性？没错，就是枚举类。且看我如何将 <code>Enum</code> 和 <code>Assert</code> 结合起来，相信我一定会让你眼前一亮。如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public interface IResponseEnum &#123;</span><br><span class="line">    int getCode();</span><br><span class="line">    String getMessage();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * &lt;p&gt;业务异常&lt;&#x2F;p&gt;</span><br><span class="line"> * &lt;p&gt;业务处理时，出现异常，可以抛出该异常&lt;&#x2F;p&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BusinessException extends  BaseException &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">    public BusinessException(IResponseEnum responseEnum, Object[] args, String message) &#123;</span><br><span class="line">        super(responseEnum, args, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(IResponseEnum responseEnum, Object[] args, String message, Throwable cause) &#123;</span><br><span class="line">        super(responseEnum, args, message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface BusinessExceptionAssert extends IResponseEnum, Assert &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default BaseException newException(Object... args) &#123;</span><br><span class="line">        String msg &#x3D; MessageFormat.format(this.getMessage(), args);</span><br><span class="line"></span><br><span class="line">        return new BusinessException(this, args, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default BaseException newException(Throwable t, Object... args) &#123;</span><br><span class="line">        String msg &#x3D; MessageFormat.format(this.getMessage(), args);</span><br><span class="line"></span><br><span class="line">        return new BusinessException(this, args, msg, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@Getter</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public enum ResponseEnum implements BusinessExceptionAssert &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Bad licence type</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BAD_LICENCE_TYPE(7001, &quot;Bad licence type.&quot;),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Licence not found</span><br><span class="line">     *&#x2F;</span><br><span class="line">    LICENCE_NOT_FOUND(7002, &quot;Licence not found.&quot;)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int code;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回消息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>看到这里，有没有眼前一亮的感觉，代码示例中定义了两个枚举实例：<code>BAD_LICENCE_TYPE</code>、<code>LICENCE_NOT_FOUND</code>，分别对应了<code>BadLicenceTypeException</code>、<code>LicenceNotFoundException</code>两种异常。以后每增加一种异常情况，只需增加一个枚举实例即可，再也不用每一种异常都定义一个异常类了。然后再来看下如何使用，假设<code>LicenceService</code>有校验<code>Licence</code>是否存在的方法，如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 校验&#123;@link Licence&#125;存在</span><br><span class="line">     * @param licence</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void checkNotNull(Licence licence) &#123;</span><br><span class="line">        ResponseEnum.LICENCE_NOT_FOUND.assertNotNull(licence);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>若不使用断言，代码可能如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void checkNotNull(Licence licence) &#123;</span><br><span class="line">        if (licence &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new LicenceNotFoundException();</span><br><span class="line">            &#x2F;&#x2F; 或者这样</span><br><span class="line">            throw new BusinessException(7001, &quot;Bad licence type.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>使用枚举类结合(继承)<code>Assert</code>，只需根据特定的异常情况定义不同的枚举实例，如上面的<code>BAD_LICENCE_TYPE</code>、<code>LICENCE_NOT_FOUND</code>，就能够针对不同情况抛出特定的异常（这里指携带特定的异常码和异常消息），这样既不用定义大量的异常类，同时还具备了断言的良好可读性，当然这种方案的好处远不止这些，请继续阅读后文，慢慢体会。</p><blockquote><p>注：上面举的例子是针对特定的业务，而有部分异常情况是通用的，比如：服务器繁忙、网络异常、服务器异常、参数校验异常、404等，所以有<code>CommonResponseEnum</code>、<code>ArgumentResponseEnum</code>、<code>ServletResponseEnum</code>，其中 <code>ServletResponseEnum</code> 会在后文详细说明。</p></blockquote><h3 id="定义统一异常处理器类"><a href="#定义统一异常处理器类" class="headerlink" title="定义统一异常处理器类"></a>定义统一异常处理器类</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">@ControllerAdvice</span><br><span class="line">@ConditionalOnWebApplication</span><br><span class="line">@ConditionalOnMissingBean(UnifiedExceptionHandler.class)</span><br><span class="line">public class UnifiedExceptionHandler &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生产环境</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static String ENV_PROD &#x3D; &quot;prod&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UnifiedMessageSource unifiedMessageSource;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前环境</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span><br><span class="line">    private String profile;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取国际化消息</span><br><span class="line">     *</span><br><span class="line">     * @param e 异常</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getMessage(BaseException e) &#123;</span><br><span class="line">        String code &#x3D; &quot;response.&quot; + e.getResponseEnum().toString();</span><br><span class="line">        String message &#x3D; unifiedMessageSource.getMessage(code, e.getArgs());</span><br><span class="line"></span><br><span class="line">        if (message &#x3D;&#x3D; null || message.isEmpty()) &#123;</span><br><span class="line">            return e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 业务异常</span><br><span class="line">     *</span><br><span class="line">     * @param e 异常</span><br><span class="line">     * @return 异常结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D; BusinessException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ErrorResponse handleBusinessException(BaseException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line"></span><br><span class="line">        return new ErrorResponse(e.getResponseEnum().getCode(), getMessage(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义异常</span><br><span class="line">     *</span><br><span class="line">     * @param e 异常</span><br><span class="line">     * @return 异常结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D; BaseException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ErrorResponse handleBaseException(BaseException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line"></span><br><span class="line">        return new ErrorResponse(e.getResponseEnum().getCode(), getMessage(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Controller上一层相关异常</span><br><span class="line">     *</span><br><span class="line">     * @param e 异常</span><br><span class="line">     * @return 异常结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(&#123;</span><br><span class="line">            NoHandlerFoundException.class,</span><br><span class="line">            HttpRequestMethodNotSupportedException.class,</span><br><span class="line">            HttpMediaTypeNotSupportedException.class,</span><br><span class="line">            MissingPathVariableException.class,</span><br><span class="line">            MissingServletRequestParameterException.class,</span><br><span class="line">            TypeMismatchException.class,</span><br><span class="line">            HttpMessageNotReadableException.class,</span><br><span class="line">            HttpMessageNotWritableException.class,</span><br><span class="line">            &#x2F;&#x2F; BindException.class,</span><br><span class="line">            &#x2F;&#x2F; MethodArgumentNotValidException.class</span><br><span class="line">            HttpMediaTypeNotAcceptableException.class,</span><br><span class="line">            ServletRequestBindingException.class,</span><br><span class="line">            ConversionNotSupportedException.class,</span><br><span class="line">            MissingServletRequestPartException.class,</span><br><span class="line">            AsyncRequestTimeoutException.class</span><br><span class="line">    &#125;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ErrorResponse handleServletException(Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        int code &#x3D; CommonResponseEnum.SERVER_ERROR.getCode();</span><br><span class="line">        try &#123;</span><br><span class="line">            ServletResponseEnum servletExceptionEnum &#x3D; ServletResponseEnum.valueOf(e.getClass().getSimpleName());</span><br><span class="line">            code &#x3D; servletExceptionEnum.getCode();</span><br><span class="line">        &#125; catch (IllegalArgumentException e1) &#123;</span><br><span class="line">            log.error(&quot;class [&#123;&#125;] not defined in enum &#123;&#125;&quot;, e.getClass().getName(), ServletResponseEnum.class.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ENV_PROD.equals(profile)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当为生产环境, 不适合把具体的异常信息展示给用户, 比如404.</span><br><span class="line">            code &#x3D; CommonResponseEnum.SERVER_ERROR.getCode();</span><br><span class="line">            BaseException baseException &#x3D; new BaseException(CommonResponseEnum.SERVER_ERROR);</span><br><span class="line">            String message &#x3D; getMessage(baseException);</span><br><span class="line">            return new ErrorResponse(code, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ErrorResponse(code, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 参数绑定异常</span><br><span class="line">     *</span><br><span class="line">     * @param e 异常</span><br><span class="line">     * @return 异常结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D; BindException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ErrorResponse handleBindException(BindException e) &#123;</span><br><span class="line">        log.error(&quot;参数绑定校验异常&quot;, e);</span><br><span class="line"></span><br><span class="line">        return wrapperBindingResult(e.getBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 参数校验异常，将校验失败的所有异常组合成一条错误信息</span><br><span class="line">     *</span><br><span class="line">     * @param e 异常</span><br><span class="line">     * @return 异常结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D; MethodArgumentNotValidException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ErrorResponse handleValidException(MethodArgumentNotValidException e) &#123;</span><br><span class="line">        log.error(&quot;参数绑定校验异常&quot;, e);</span><br><span class="line"></span><br><span class="line">        return wrapperBindingResult(e.getBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 包装绑定异常结果</span><br><span class="line">     *</span><br><span class="line">     * @param bindingResult 绑定结果</span><br><span class="line">     * @return 异常结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private ErrorResponse wrapperBindingResult(BindingResult bindingResult) &#123;</span><br><span class="line">        StringBuilder msg &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">        for (ObjectError error : bindingResult.getAllErrors()) &#123;</span><br><span class="line">            msg.append(&quot;, &quot;);</span><br><span class="line">            if (error instanceof FieldError) &#123;</span><br><span class="line">                msg.append(((FieldError) error).getField()).append(&quot;: &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            msg.append(error.getDefaultMessage() &#x3D;&#x3D; null ? &quot;&quot; : error.getDefaultMessage());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ErrorResponse(ArgumentResponseEnum.VALID_ERROR.getCode(), msg.substring(2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 未定义异常</span><br><span class="line">     *</span><br><span class="line">     * @param e 异常</span><br><span class="line">     * @return 异常结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D; Exception.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ErrorResponse handleException(Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line"></span><br><span class="line">        if (ENV_PROD.equals(profile)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当为生产环境, 不适合把具体的异常信息展示给用户, 比如数据库异常信息.</span><br><span class="line">            int code &#x3D; CommonResponseEnum.SERVER_ERROR.getCode();</span><br><span class="line">            BaseException baseException &#x3D; new BaseException(CommonResponseEnum.SERVER_ERROR);</span><br><span class="line">            String message &#x3D; getMessage(baseException);</span><br><span class="line">            return new ErrorResponse(code, message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ErrorResponse(CommonResponseEnum.SERVER_ERROR.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>可以看到，上面将异常分成几类，实际上只有两大类，一类是<code>ServletException</code>、<code>ServiceException</code>，还记得上文提到的 <strong>按阶段分类</strong> 吗，即对应 进入<code>Controller</code>前的异常 和 <code>Service</code> 层异常；然后 <code>ServiceException</code> 再分成自定义异常、未知异常。对应关系如下：</p><ul><li>进入<code>Controller</code>前的异常: handleServletException、handleBindException、handleValidException</li><li>自定义异常: handleBusinessException、handleBaseException</li><li>未知异常: handleException</li></ul><p>接下来分别对这几种异常处理器做详细说明。</p><h4 id="异常处理器说明"><a href="#异常处理器说明" class="headerlink" title="异常处理器说明"></a><strong>异常处理器说明</strong></h4><h5 id="handleServletException"><a href="#handleServletException" class="headerlink" title="handleServletException"></a><strong>handleServletException</strong></h5><p>一个<code>http</code>请求，在到达<code>Controller</code>前，会对该请求的请求信息与目标控制器信息做一系列校验。这里简单说一下：</p><p>NoHandlerFoundException：首先根据请求<code>Url</code>查找有没有对应的控制器，若没有则会抛该异常，也就是大家非常熟悉的<code>404</code>异常；</p><p>HttpRequestMethodNotSupportedException：若匹配到了（匹配结果是一个列表，不同的是<code>http</code>方法不同，如：Get、Post等），则尝试将请求的<code>http</code>方法与列表的控制器做匹配，若没有对应<code>http</code>方法的控制器，则抛该异常；</p><p>HttpMediaTypeNotSupportedException：然后再对请求头与控制器支持的做比较，比如<code>content-type</code>请求头，若控制器的参数签名包含注解<code>@RequestBody</code>，但是请求的<code>content-type</code>请求头的值没有包含<code>application/json</code>，那么会抛该异常（当然，不止这种情况会抛这个异常）；</p><p>MissingPathVariableException：未检测到路径参数。比如url为：<code>/licence/{licenceId}</code>，参数签名包含<code>@PathVariable(&quot;licenceId&quot;)</code>，当请求的url为<code>/licence</code>，在没有明确定义url为<code>/licence</code>的情况下，会被判定为：缺少路径参数；</p><p>MissingServletRequestParameterException：缺少请求参数。比如定义了参数@RequestParam(“licenceId”) String licenceId，但发起请求时，未携带该参数，则会抛该异常；</p><p>TypeMismatchException: 参数类型匹配失败。比如：接收参数为Long型，但传入的值确是一个字符串，那么将会出现类型转换失败的情况，这时会抛该异常；</p><p>HttpMessageNotReadableException：与上面的<code>HttpMediaTypeNotSupportedException</code>举的例子完全相反，即请求头携带了<code>&quot;content-type: application/json;charset=UTF-8&quot;</code>，但接收参数却没有添加注解<code>@RequestBody</code>，或者请求体携带的 json 串反序列化成 pojo 的过程中失败了，也会抛该异常；</p><p>HttpMessageNotWritableException：返回的 pojo 在序列化成 json 过程失败了，那么抛该异常；</p><h5 id="handleBindException"><a href="#handleBindException" class="headerlink" title="handleBindException"></a><strong>handleBindException</strong></h5><p>参数校验异常，后文详细说明。</p><h5 id="handleValidException"><a href="#handleValidException" class="headerlink" title="handleValidException"></a><strong>handleValidException</strong></h5><p>参数校验异常，后文详细说明。</p><h5 id="handleBusinessException、handleBaseException"><a href="#handleBusinessException、handleBaseException" class="headerlink" title="handleBusinessException、handleBaseException"></a><strong>handleBusinessException、handleBaseException</strong></h5><p>处理自定义的业务异常，只是<code>handleBaseException</code>处理的是除了 <code>BusinessException</code> 意外的所有业务异常。就目前来看，这2个是可以合并成一个的。</p><h5 id="handleException"><a href="#handleException" class="headerlink" title="handleException"></a><strong>handleException</strong></h5><p>处理所有未知的异常，比如操作数据库失败的异常。</p><blockquote><p>注：上面的<code>handleServletException</code>、<code>handleException</code> 这两个处理器，返回的异常信息，不同环境返回的可能不一样，以为这些异常信息都是框架自带的异常信息，一般都是英文的，不太好直接展示给用户看，所以统一返回<code>SERVER_ERROR</code>代表的异常信息。</p></blockquote><h4 id="异于常人的404"><a href="#异于常人的404" class="headerlink" title="异于常人的404"></a><strong>异于常人的404</strong></h4><p>上文提到，当请求没有匹配到控制器的情况下，会抛出<code>NoHandlerFoundException</code>异常，但其实默认情况下不是这样，默认情况下会出现类似如下页面：</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>Whitelabel Error Page</p><p>这个页面是如何出现的呢？实际上，当出现404的时候，默认是不抛异常的，而是 <code>forward</code>跳转到<code>/error</code>控制器，<code>spring</code>也提供了默认的<code>error</code>控制器，如下：</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>那么，如何让404也抛出异常呢，只需在<code>properties</code>文件中加入如下配置即可：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.throw-exception-if-no-handler-found&#x3D;true</span><br><span class="line">spring.resources.add-mappings&#x3D;false</span><br></pre></td></tr></table></figure></div><p>如此，就可以异常处理器中捕获它了，然后前端只要捕获到特定的状态码，立即跳转到404页面即可</p><p><strong>捕获404对应的异常</strong></p><h4 id="统一返回结果"><a href="#统一返回结果" class="headerlink" title="统一返回结果"></a><strong>统一返回结果</strong></h4><p>在验证统一异常处理器之前，顺便说一下统一返回结果。说白了，其实是统一一下返回结果的数据结构。<code>code</code>、<code>message</code> 是所有返回结果中必有的字段，而当需要返回数据时，则需要另一个字段 <code>data</code> 来表示。</p><p>所以首先定义一个 <code>BaseResponse</code> 来作为所有返回结果的基类；</p><p>然后定义一个通用返回结果类<code>CommonResponse</code>，继承 <code>BaseResponse</code>，而且多了字段 <code>data</code>；</p><p>为了区分成功和失败返回结果，于是再定义一个 <code>ErrorResponse</code></p><p>最后还有一种常见的返回结果，即返回的数据带有分页信息，因为这种接口比较常见，所以有必要单独定义一个返回结果类 <code>QueryDataResponse</code>，该类继承自 <code>CommonResponse</code>，只是把 <code>data</code>字段的类型限制为 <code>QueryDdata</code>，<code>QueryDdata</code>中定义了分页信息相应的字段，即<code>totalCount</code>、<code>pageNo</code>、 <code>pageSize</code>、<code>records</code>。</p><p>其中比较常用的只有 <code>CommonResponse</code> 和 <code>QueryDataResponse</code>，但是名字又贼鬼死长，何不定义2个名字超简单的类来替代呢？于是 <code>R</code> 和 <code>QR</code> 诞生了，以后返回结果的时候只需这样写：<code>new R&lt;&gt;(data)</code>、<code>new QR&lt;&gt;(queryData)</code>。</p><p>所有的返回结果类的定义这里就不贴出来了</p><h4 id="验证统一异常处理"><a href="#验证统一异常处理" class="headerlink" title="验证统一异常处理"></a><strong>验证统一异常处理</strong></h4><p>因为这一套统一异常处理可以说是通用的，所有可以设计成一个 <code>common</code>包，以后每一个新项目/模块只需引入该包即可。所以为了验证，需要新建一个项目，并引入该 <code>common</code>包。</p><h5 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h5><p>下面是用于验证的主要源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class LicenceService extends ServiceImpl&lt;LicenceMapper, Licence&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrganizationClient organizationClient;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询&#123;@link Licence&#125; 详情</span><br><span class="line">     * @param licenceId</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public LicenceDTO queryDetail(Long licenceId) &#123;</span><br><span class="line">        Licence licence &#x3D; this.getById(licenceId);</span><br><span class="line">        checkNotNull(licence);</span><br><span class="line"></span><br><span class="line">        OrganizationDTO org &#x3D; ClientUtil.execute(() -&gt; organizationClient.getOrganization(licence.getOrganizationId()));</span><br><span class="line">        return toLicenceDTO(licence, org);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 分页获取</span><br><span class="line">     * @param licenceParam 分页查询参数</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public QueryData&lt;SimpleLicenceDTO&gt; getLicences(LicenceParam licenceParam) &#123;</span><br><span class="line">        String licenceType &#x3D; licenceParam.getLicenceType();</span><br><span class="line">        LicenceTypeEnum licenceTypeEnum &#x3D; LicenceTypeEnum.parseOfNullable(licenceType);</span><br><span class="line">        &#x2F;&#x2F; 断言, 非空</span><br><span class="line">        ResponseEnum.BAD_LICENCE_TYPE.assertNotNull(licenceTypeEnum);</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;Licence&gt; wrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        wrapper.eq(Licence::getLicenceType, licenceType);</span><br><span class="line">        IPage&lt;Licence&gt; page &#x3D; this.page(new QueryPage&lt;&gt;(licenceParam), wrapper);</span><br><span class="line">        return new QueryData&lt;&gt;(page, this::toSimpleLicenceDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 新增&#123;@link Licence&#125;</span><br><span class="line">     * @param request 请求体</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Transactional(rollbackFor &#x3D; Throwable.class)</span><br><span class="line">    public LicenceAddRespData addLicence(LicenceAddRequest request) &#123;</span><br><span class="line">        Licence licence &#x3D; new Licence();</span><br><span class="line">        licence.setOrganizationId(request.getOrganizationId());</span><br><span class="line">        licence.setLicenceType(request.getLicenceType());</span><br><span class="line">        licence.setProductName(request.getProductName());</span><br><span class="line">        licence.setLicenceMax(request.getLicenceMax());</span><br><span class="line">        licence.setLicenceAllocated(request.getLicenceAllocated());</span><br><span class="line">        licence.setComment(request.getComment());</span><br><span class="line">        this.save(licence);</span><br><span class="line"></span><br><span class="line">        return new LicenceAddRespData(licence.getLicenceId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * entity -&gt; simple dto</span><br><span class="line">     * @param licence &#123;@link Licence&#125; entity</span><br><span class="line">     * @return &#123;@link SimpleLicenceDTO&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private SimpleLicenceDTO toSimpleLicenceDTO(Licence licence) &#123;</span><br><span class="line">        &#x2F;&#x2F; 省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * entity -&gt; dto</span><br><span class="line">     * @param licence &#123;@link Licence&#125; entity</span><br><span class="line">     * @param org &#123;@link OrganizationDTO&#125;</span><br><span class="line">     * @return &#123;@link LicenceDTO&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LicenceDTO toLicenceDTO(Licence licence, OrganizationDTO org) &#123;</span><br><span class="line">        &#x2F;&#x2F; 省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 校验&#123;@link Licence&#125;存在</span><br><span class="line">     * @param licence</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void checkNotNull(Licence licence) &#123;</span><br><span class="line">        ResponseEnum.LICENCE_NOT_FOUND.assertNotNull(licence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>PS: 这里使用的DAO框架是<code>mybatis-plus</code>。<br>启动时，自动插入的数据为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- licence</span><br><span class="line">INSERT INTO licence (licence_id, organization_id, licence_type, product_name, licence_max, licence_allocated)</span><br><span class="line">VALUES (1, 1, &#39;user&#39;,&#39;CustomerPro&#39;, 100,5);</span><br><span class="line">INSERT INTO licence (licence_id, organization_id, licence_type, product_name, licence_max, licence_allocated)</span><br><span class="line">VALUES (2, 1, &#39;user&#39;,&#39;suitability-plus&#39;, 200,189);</span><br><span class="line">INSERT INTO licence (licence_id, organization_id, licence_type, product_name, licence_max, licence_allocated)</span><br><span class="line">VALUES (3, 2, &#39;user&#39;,&#39;HR-PowerSuite&#39;, 100,4);</span><br><span class="line">INSERT INTO licence (licence_id, organization_id, licence_type, product_name, licence_max, licence_allocated)</span><br><span class="line">VALUES (4, 2, &#39;core-prod&#39;,&#39;WildCat Application Gateway&#39;, 16,16);</span><br><span class="line"></span><br><span class="line">-- organizations</span><br><span class="line">INSERT INTO organization (id, name, contact_name, contact_email, contact_phone)</span><br><span class="line">VALUES (1, &#39;customer-crm-co&#39;, &#39;Mark Balster&#39;, &#39;mark.balster@custcrmco.com&#39;, &#39;823-555-1212&#39;);</span><br><span class="line">INSERT INTO organization (id, name, contact_name, contact_email, contact_phone)</span><br><span class="line">VALUES (2, &#39;HR-PowerSuite&#39;, &#39;Doug Drewry&#39;,&#39;doug.drewry@hr.com&#39;, &#39;920-555-1212&#39;);</span><br></pre></td></tr></table></figure></div><h5 id="开始验证"><a href="#开始验证" class="headerlink" title="开始验证"></a><strong>开始验证</strong></h5><h6 id="捕获自定义异常"><a href="#捕获自定义异常" class="headerlink" title="捕获自定义异常"></a><strong>捕获自定义异常</strong></h6><p>\1. 获取不存在的 <code>licence</code> 详情：<a href="http://localhost:10000/licence/5。成功响应的请求：licenceId=1" target="_blank" rel="noopener">http://localhost:10000/licence/5。成功响应的请求：licenceId=1</a></p><p>检验非空</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>捕获 Licence not found 异常<img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>Licence not found</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload">2. 根据不存在的 <code>licence type</code> 获取 <code>licence</code> 列表：<a href="http://localhost:10000/licence/list?licenceType=ddd。可选的" target="_blank" rel="noopener">http://localhost:10000/licence/list?licenceType=ddd。可选的</a> <code>licence type</code> 为：user、core-prod 。</p><p>校验非空</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>捕获 Bad licence type 异常<img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>Bad licence type</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"><strong>捕获进入 Controller 前的异常</strong></p><p>\1. 访问不存在的接口：<a href="http://localhost:10000/licence/list/ddd" target="_blank" rel="noopener">http://localhost:10000/licence/list/ddd</a></p><p>捕获404异常</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>\2. http 方法不支持：<a href="http://localhost:10000/licence" target="_blank" rel="noopener">http://localhost:10000/licence</a></p><p>PostMapping</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>捕获 Request method not supported 异常</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>Request method not supported</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>\3. 校验异常1：<a href="http://localhost:10000/licence/list?licenceType=" target="_blank" rel="noopener">http://localhost:10000/licence/list?licenceType=</a></p><p>getLicences</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>LicenceParam</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>捕获参数绑定校验异常</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>licence type cannot be empty</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload">4. 校验异常2：post 请求，这里使用postman模拟。</p><p>addLicence</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>LicenceAddRequest</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>请求url即结果</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>捕获参数绑定校验异常<img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>注：因为参数绑定校验异常的异常信息的获取方式与其它异常不一样，所以才把这2种情况的异常从 <strong>进入 Controller 前的异常</strong> 单独拆出来，下面是异常信息的收集逻辑：</p><p>异常信息的收集</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><h6 id="捕获未知异常"><a href="#捕获未知异常" class="headerlink" title="捕获未知异常"></a><strong>捕获未知异常</strong></h6><p>假设我们现在随便对 <code>Licence</code> 新增一个字段 <code>test</code>，但不修改数据库表结构，然后访问：<a href="http://localhost:10000/licence/1。" target="_blank" rel="noopener">http://localhost:10000/licence/1。</a></p><p>增加test字段</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>捕获数据库异常</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>Error querying database</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><p>可以看到，测试的异常都能够被捕获，然后以 <code>code</code>、<code>message</code> 的形式返回。每一个项目/模块，在定义业务异常的时候，只需定义一个枚举类，然后实现接口 <code>BusinessExceptionAssert</code>，最后为每一种业务异常定义对应的枚举实例即可，而不用定义许多异常类。使用的时候也很方便，用法类似断言。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a><strong>扩展</strong></h3><p>在生产环境，若捕获到 <strong>未知异常</strong> 或者 <code>ServletException</code>，因为都是一长串的异常信息，若直接展示给用户看，显得不够专业，于是，我们可以这样做：当检测到当前环境是生产环境，那么直接返回 “网络异常”。</p><p>生产环境返回“网络异常”</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>可以通过以下方式修改当前环境：</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>修改当前环境为生产环境</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>使用 <strong>断言</strong> 和 <strong>枚举类</strong> 相结合的方式，再配合统一异常处理，基本大部分的异常都能够被捕获。为什么说大部分异常，因为当引入 <code>spring cloud security</code> 后，还会有认证/授权异常，网关的服务降级异常、跨模块调用异常、远程调用第三方服务异常等，这些异常的捕获方式与本文介绍的不太一样，不过限于篇幅，这里不做详细说明，以后会有单独的文章介绍。</p><p>另外，当需要考虑国际化的时候，捕获异常后的异常信息一般不能直接返回，需要转换成对应的语言，不过本文已考虑到了这个，获取消息的时候已经做了国际化映射，逻辑如下：</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p><strong>获取国际化消息</strong></p><p>最后总结，全局异常属于老生长谈的话题，希望这次通过手机的项目对大家有点指导性的学习。大家根据实际情况自行修改。</p><p>也可以采用以下的jsonResult对象的方式进行处理，也贴出来代码.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 没有登录</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(NoLoginException.class)</span><br><span class="line">    public Object noLoginExceptionHandler(HttpServletRequest request,HttpServletResponse response,Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        log.error(&quot;[GlobalExceptionHandler][noLoginExceptionHandler] exception&quot;,e);</span><br><span class="line">        JsonResult jsonResult &#x3D; new JsonResult();</span><br><span class="line">        jsonResult.setCode(JsonResultCode.NO_LOGIN);</span><br><span class="line">        jsonResult.setMessage(&quot;用户登录失效或者登录超时,请先登录&quot;);</span><br><span class="line">        return jsonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 业务异常</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(ServiceException.class)</span><br><span class="line">    public Object businessExceptionHandler(HttpServletRequest request,HttpServletResponse response,Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        log.error(&quot;[GlobalExceptionHandler][businessExceptionHandler] exception&quot;,e);</span><br><span class="line">        JsonResult jsonResult &#x3D; new JsonResult();</span><br><span class="line">        jsonResult.setCode(JsonResultCode.FAILURE);</span><br><span class="line">        jsonResult.setMessage(&quot;业务异常,请联系管理员&quot;);</span><br><span class="line">        return jsonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 全局异常处理</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Object exceptionHandler(HttpServletRequest request,HttpServletResponse response,Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        log.error(&quot;[GlobalExceptionHandler][exceptionHandler] exception&quot;,e);</span><br><span class="line">        JsonResult jsonResult &#x3D; new JsonResult();</span><br><span class="line">        jsonResult.setCode(JsonResultCode.FAILURE);</span><br><span class="line">        jsonResult.setMessage(&quot;系统错误,请联系管理员&quot;);</span><br><span class="line">        return jsonResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p> 原文链接：cnblogs.com/jurendage/p/11255197.html</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络相关基础</title>
      <link href="/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Synchronized底层实现"><a href="#Synchronized底层实现" class="headerlink" title="Synchronized底层实现"></a>Synchronized底层实现</h2><h2 id="JAVA线程阻塞的代价"><a href="#JAVA线程阻塞的代价" class="headerlink" title="JAVA线程阻塞的代价"></a>JAVA线程阻塞的代价</h2><p>java 的线程是映射到原生操作系统线程上的，阻塞和唤醒操作系统都需要操作系统介入的，需要在用户态和核心态之间转换。这种切换会耗费大量操作系统资源，因为用户态和核心态都有各自专用的内存空间、寄存器等。用户态切换到内核态需要传递许多变量、参数给内核，内核也需要保存好用户态在切换时的寄存器值和变量。</p><h2 id="markword对象头标识"><a href="#markword对象头标识" class="headerlink" title="markword对象头标识"></a>markword对象头标识</h2><p>markword是java对象数据结构中的一部分，他的最后2bit是锁状态标识，用来标记当前对象所处的状态。</p><ul><li>01：未锁定（对象的hash值、对象年龄分代）</li><li>00：轻量级锁（指向锁记录的指针）</li><li>10：重量级锁（指向重量级锁的指针）</li><li>01：偏向锁（偏向线程ID、偏向时间、对象年龄代）</li></ul><h2 id="Synchronized-实现原理"><a href="#Synchronized-实现原理" class="headerlink" title="Synchronized 实现原理"></a>Synchronized 实现原理</h2><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁的状态：无锁状态、偏向锁、轻量级锁状态、重量级锁状态（级别由低到高）</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁他会偏向第一次访问的线程，当线程获取锁对象时，会在java对象头markword中记录偏向锁的threadID，并不会主动释放偏向锁。当同一个线程再次获取锁时会比较当前的threadID与对象头中的threadID是否一致。如果一致则不需要通过CAS来加锁、解锁。如果不一致并且线程还需要持续持有锁，则暂停当前线程撤销偏向锁，升级为轻量级锁。如果不在需要持续持有锁则锁对象头设为无锁状态，重新设置偏向锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁由偏向锁升级而来，偏向锁运行在一个线程同步块时，第二个线程加入锁竞争的时候，偏向锁就会升级为轻量级锁。</p><p>轻量级锁过程：</p><ol><li>线程由偏向锁升级为轻量级锁时，会先把锁的对象头MarkWord复制一份到线程的栈帧中，建立一个名为锁记录空间（Lock Record），用于存储当前Mark Word的拷贝。</li><li>虚拟机使用cas操作尝试将对象的Mark Word指向Lock Record的指针，并将Lock record里的owner指针指对象的Mark Word。</li><li>如果cas操作成功，则该线程拥有了对象的轻量级锁。第二个线程cas自选锁等待锁线程释放锁。</li><li>如果多个线程竞争锁，轻量级锁要膨胀为重量级锁，Mark Word中存储的就是指向重量级锁（互斥量）的指针。其他等待线程进入阻塞状态。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>synchronized的执行过程：</p><ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>在线程的栈帧生成一条锁记录，当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁（也就是那个对象指向锁记录，哪个对象持有锁，没持有就CAS自旋，自旋失败就升级为重量级锁）</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li><li>如果自旋成功则依然处于轻量级状态。</li><li>如果自旋失败，则升级为重量级锁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库优化</title>
      <link href="/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E9%87%8F%E5%BE%88%E5%A4%A7%EF%BC%8C%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%EF%BC%9F/"/>
      <url>/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E9%87%8F%E5%BE%88%E5%A4%A7%EF%BC%8C%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>准备工作</li><li>一般分页查询</li><li>使用子查询优化</li><li>使用 id 限定优化</li><li>使用临时表优化</li><li>关于数据表的id说明</li></ul><hr><p>当需要从数据库查询的表有上万条记录的时候，一次性查询所有结果会变得很慢，特别是随着数据量的增加特别明显，这时需要使用分页查询。对于数据库分页查询，也有很多种方法和优化的点。下面简单说一下我知道的一些方法。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>为了对下面列举的一些优化进行测试，下面针对已有的一张表进行说明。</p><ul><li>表名：order_history</li><li>描述：某个业务的订单历史表</li><li>主要字段：unsigned int id，tinyint(4) int type</li><li>字段情况：该表一共37个字段，不包含text等大型数据，最大为varchar(500)，id字段为索引，且为递增。</li><li>数据量：5709294</li><li>MySQL版本：5.7.16 线下找一张百万级的测试表可不容易，如果需要自己测试的话，可以写shell脚本什么的插入数据进行测试。以下的 sql 所有语句执行的环境没有发生改变，下面是基本测试结果：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from orders_history;</span><br></pre></td></tr></table></figure></div><p>返回结果：5709294</p><p>三次查询时间分别为：</p><ul><li>8903 ms</li><li>8323 ms</li><li>8401 ms</li></ul><h1 id="一般分页查询"><a href="#一般分页查询" class="headerlink" title="一般分页查询"></a>一般分页查询</h1><p>一般的分页查询使用简单的 limit 子句就可以实现。limit 子句声明如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure></div><p>LIMIT 子句可以被用于指定 SELECT 语句返回的记录数。需注意以下几点：</p><ul><li>第一个参数指定第一个返回记录行的偏移量，注意从<code>0</code>开始</li><li>第二个参数指定返回记录行的最大数目</li><li>如果只给定一个参数：它表示返回最大的记录行数目</li><li>第二个参数为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行</li><li>初始记录行的偏移量是 0(而不是 1)</li></ul><p>下面是一个应用实例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type&#x3D;8 limit 1000,10;</span><br></pre></td></tr></table></figure></div><p>该条语句将会从表 orders_history 中查询<code>offset: 1000</code>开始之后的10条数据，也就是第1001条到第1010条数据（<code>1001 &lt;= id &lt;= 1010</code>）。</p><p>数据表中的记录默认使用主键（一般为id）排序，上面的结果相当于：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type&#x3D;8 order by id limit 10000,10;</span><br></pre></td></tr></table></figure></div><p>三次查询时间分别为：</p><ul><li>3040 ms</li><li>3063 ms</li><li>3018 ms</li></ul><p>针对这种查询方式，下面测试查询记录量对时间的影响：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type&#x3D;8 limit 10000,1;</span><br><span class="line">select * from orders_history where type&#x3D;8 limit 10000,10;</span><br><span class="line">select * from orders_history where type&#x3D;8 limit 10000,100;</span><br><span class="line">select * from orders_history where type&#x3D;8 limit 10000,1000;</span><br><span class="line">select * from orders_history where type&#x3D;8 limit 10000,10000;</span><br></pre></td></tr></table></figure></div><p>三次查询时间如下：</p><ul><li>查询1条记录：3072ms 3092ms 3002ms</li><li>查询10条记录：3081ms 3077ms 3032ms</li><li>查询100条记录：3118ms 3200ms 3128ms</li><li>查询1000条记录：3412ms 3468ms 3394ms</li><li>查询10000条记录：3749ms 3802ms 3696ms</li></ul><p>另外我还做了十来次查询，从查询时间来看，基本可以确定，在查询记录量低于100时，查询时间基本没有差距，随着查询记录量越来越大，所花费的时间也会越来越多。</p><p>针对查询偏移量的测试：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type&#x3D;8 limit 100,100;</span><br><span class="line">select * from orders_history where type&#x3D;8 limit 1000,100;</span><br><span class="line">select * from orders_history where type&#x3D;8 limit 10000,100;</span><br><span class="line">select * from orders_history where type&#x3D;8 limit 100000,100;</span><br><span class="line">select * from orders_history where type&#x3D;8 limit 1000000,100;</span><br></pre></td></tr></table></figure></div><p>三次查询时间如下：</p><ul><li>查询100偏移：25ms 24ms 24ms</li><li>查询1000偏移：78ms 76ms 77ms</li><li>查询10000偏移：3092ms 3212ms 3128ms</li><li>查询100000偏移：3878ms 3812ms 3798ms</li><li>查询1000000偏移：14608ms 14062ms 14700ms</li></ul><p>随着查询偏移的增大，尤其查询偏移大于10万以后，查询时间急剧增加。</p><p><strong>这种分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。</strong></p><h1 id="使用子查询优化"><a href="#使用子查询优化" class="headerlink" title="使用子查询优化"></a>使用子查询优化</h1><p>这种方式先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type&#x3D;8 limit 100000,1;</span><br><span class="line"></span><br><span class="line">select id from orders_history where type&#x3D;8 limit 100000,1;</span><br><span class="line"></span><br><span class="line">select * from orders_history where type&#x3D;8 and</span><br><span class="line">id&gt;&#x3D;(select id from orders_history where type&#x3D;8 limit 100000,1)</span><br><span class="line">limit 100;</span><br><span class="line"></span><br><span class="line">select * from orders_history where type&#x3D;8 limit 100000,100;</span><br></pre></td></tr></table></figure></div><p>4条语句的查询时间如下：</p><ul><li>第1条语句：3674ms</li><li>第2条语句：1315ms</li><li>第3条语句：1327ms</li><li>第4条语句：3710ms</li></ul><p>针对上面的查询需要注意：</p><ul><li>比较第1条语句和第2条语句：使用 select id 代替 select * 速度增加了3倍</li><li>比较第2条语句和第3条语句：速度相差几十毫秒</li><li>比较第3条语句和第4条语句：得益于 select id 速度增加，第3条语句查询速度增加了3倍</li></ul><p>这种方式相较于原始一般的查询方法，将会增快数倍。</p><h1 id="使用-id-限定优化"><a href="#使用-id-限定优化" class="headerlink" title="使用 id 限定优化"></a>使用 id 限定优化</h1><p>这种方式假设数据表的id是<strong>连续递增</strong>的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type&#x3D;2</span><br><span class="line">and id between 1000000 and 1000100 limit 100;</span><br></pre></td></tr></table></figure></div><p>查询时间：15ms 12ms 9ms</p><p>这种查询方式能够极大地优化查询速度，基本能够在几十毫秒之内完成。限制是只能使用于明确知道id的情况，不过一般建立表的时候，都会添加基本的id字段，这为分页查询带来很多便利。</p><p>还可以有另外一种写法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where id &gt;&#x3D; 1000001 limit 100;</span><br></pre></td></tr></table></figure></div><p>当然还可以使用 in 的方式来进行查询，这种方式经常用在多表关联的时候进行查询，使用其他表查询的id集合，来进行查询：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where id in</span><br><span class="line">(select order_id from trade_2 where goods &#x3D; &#39;pen&#39;)</span><br><span class="line">limit 100;</span><br></pre></td></tr></table></figure></div><p>这种 in 查询的方式要注意：某些 mysql 版本不支持在 in 子句中使用 limit。</p><h1 id="使用临时表优化"><a href="#使用临时表优化" class="headerlink" title="使用临时表优化"></a>使用临时表优化</h1><p>这种方式已经不属于查询优化，这儿附带提一下。</p><p>对于使用 id 限定优化中的问题，需要 id 是连续递增的，但是在一些场景下，比如使用历史表的时候，或者出现过数据缺失问题时，可以考虑使用临时存储的表来记录分页的id，使用分页的id来进行 in 查询。这样能够极大的提高传统的分页查询速度，尤其是数据量上千万的时候。</p><h1 id="关于数据表的id说明"><a href="#关于数据表的id说明" class="headerlink" title="关于数据表的id说明"></a>关于数据表的id说明</h1><p>一般情况下，在数据库中建立表的时候，强制为每一张表添加 id 递增字段，这样方便查询。</p><p>如果像是订单库等数据量非常庞大，一般会进行分库分表。这个时候不建议使用数据库的 id 作为唯一标识，而应该使用分布式的高并发唯一 id 生成器来生成，并在数据表中使用另外的字段来存储这个唯一标识。</p><p>使用先使用范围查询定位 id （或者索引），然后再使用索引进行定位数据，能够提高好几倍查询速度。即先 select id，然后再 select *；</p><p>本人才疏学浅，难免犯错，若发现文中有错误遗漏，望不吝赐教。</p><p>END</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">程序汪往期精彩文章包含答案</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">程序汪最近整理的BAT大小厂面试题(面试题目录推荐)</span><br><span class="line">目录：我把精华文章都整理出来了</span><br><span class="line">程序员新人刚进公司很懵逼，程序汪给5个建议程序汪粉丝拿下腾讯视频字节跳动offer22K面经分享</span><br><span class="line">程序汪本科应届粉丝22K拿下字节跳动和顺丰offer源码分享 一个基于spring boot的JAVA开源商城系统</span><br><span class="line">推荐3个快速开发平台 项目经验又有着落了Github上10个超好看 可视化面板，后台管理页面有着落了真实案例:6年18K的android开发转8K的Java竟然没找到工作铁粉：汪哥春招我上岸的公司有字节腾讯shappeedd等工资都不低于30W</span><br><span class="line">推荐3个开源电商系统，应该比花2万培训的电商有技术含量多了 有源码提供招聘信息上是8-13KJava研发岗,面试通过后 HR：7K能接受的话可以来这里锻炼一下</span><br></pre></td></tr></table></figure></div><p>阅读 2008</p><p>赞5在看7</p><p><img alt="img" data-src="http://wx.qlogo.cn/mmopen/TTQibyKjrickz94hTichQZM8ToKxp28icWD6rkNjRPmrdNIibjHJy6dQgVUoDEGx3O6WwckZL4oY5Sn3O9kFSjQAbnakZxEGR1aWE/132" class="lazyload"></p><p>写下你的留言</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式Id</title>
      <link href="/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FId/"/>
      <url>/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FId/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。下面来分析各个生成分布式ID的机制。</p><h2 id="常见分布式ID方案"><a href="#常见分布式ID方案" class="headerlink" title="常见分布式ID方案"></a>常见分布式ID方案</h2><p><img alt="常用分布式id方案" data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" class="lazyload"></p><h2 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h2><p>第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表：</p><p>表结构如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`SEQID`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment, </span><br><span class="line">stub <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> stub (stub)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure></div><p>可以使用下面的语句生成并获取到一个自增ID</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">replace</span> <span class="keyword">into</span> SEQUENCE_ID (stub) <span class="keyword">VALUES</span> (<span class="string">'anyword'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">last_insert_id</span>();</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></div><p>stub字段在这里并没有什么特殊的意义，只是为了方便的去插入数据，只有能插入数据才能产生自增id。而对于插入我们用的是replace，replace会先看是否存在stub指定值一样的数据，如果存在则先delete再insert，如果不存在则直接insert。</p><p>这种生成分布式ID的机制，需要一个单独的Mysql实例，虽然可行，但是基于性能与可靠性来考虑的话都不够，<strong>业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统。</strong></p><p>为了解决数据库可靠性问题，我们可以使用第二种分布式ID生成方案。</p><h2 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h2><p>如果我们两个数据库组成一个<strong>主从模式</strong>集群，正常情况下可以解决数据库可靠性问题，但是如果主库挂掉后，数据没有及时同步到从库，这个时候会出现ID重复的现象。我们可以使用<strong>双主模式</strong>集群，也就是两个Mysql实例都能单独的生产自增ID，这样能够提高效率，但是如果不经过其他改造的话，这两个Mysql实例很可能会生成同样的ID。需要单独给每个Mysql实例配置不同的起始值和自增步长。</p><p>第一台Mysql实例配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure></div><p>第二台Mysql实例配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure></div><p>经过上面的配置后，这两个Mysql实例生成的id序列如下： mysql1,起始值为1,步长为2,ID生成的序列为：1,3,5,7,9,… mysql2,起始值为2,步长为2,ID生成的序列为：2,4,6,8,10,…</p><p>对于这种生成分布式ID的方案，需要单独新增一个生成分布式ID应用，比如DistributIdService，该应用提供一个接口供业务应用获取ID，业务应用需要一个ID时，通过rpc的方式请求DistributIdService，DistributIdService随机去上面的两个Mysql实例中去获取ID。</p><p>实行这种方案后，就算其中某一台Mysql实例下线了，也不会影响DistributIdService，DistributIdService仍然可以利用另外一台Mysql来生成ID。</p><p>但是这种方案的扩展性不太好，如果两台Mysql实例不够用，需要新增Mysql实例来提高性能时，这时就会比较麻烦。</p><p>现在如果要新增一个实例mysql3，要怎么操作呢？ 第一，mysql1、mysql2的步长肯定都要修改为3，而且只能是人工去修改，这是需要时间的。 第二，因为mysql1和mysql2是不停在自增的，对于mysql3的起始值我们可能要定得大一点，以给充分的时间去修改mysql1，mysql2的步长。 第三，在修改步长的时候很可能会出现重复ID，要解决这个问题，可能需要停机才行。</p><p>为了解决上面的问题，以及能够进一步提高DistributIdService的性能，如果使用第三种生成分布式ID机制。</p><h2 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h2><p>总结:</p><p>维护一张id表,增加一个服务DistributIdService每次可以取1000个id,然后放到本地去用.若是双主模式, mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7…. mysql2将生成号段（2,1002]，自增的时候序列为2，4，6，8，10…</p><p>我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。</p><p>比如DistributIdService每次从数据库获取ID时，就获取一个号段，比如(1,1000]，这个范围表示了1000个ID，业务应用在请求DistributIdService提供ID时，DistributIdService只需要在本地从1开始自增并返回即可，而不需要每次都请求数据库，一直到本地自增到1000时，也就是当前号段已经被用完时，才去数据库重新获取下一号段。</p><p>所以，我们需要对数据库表进行改动，如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> id_generator (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  current_max_id <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'当前最大id'</span>,</span><br><span class="line">  increment_step <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'号段的长度'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></div><p>这个数据库表用来记录自增步长以及当前自增ID的最大值（也就是当前已经被申请的号段的最后一个值），因为自增逻辑被移到DistributIdService中去了，所以数据库不需要这部分逻辑了。</p><p>这种方案不再强依赖数据库，就算数据库不可用，那么DistributIdService也能继续支撑一段时间。但是如果DistributIdService重启，会丢失一段ID，导致ID空洞。</p><p>为了提高DistributIdService的高可用，需要做一个集群，业务在请求DistributIdService集群获取ID时，会随机的选择某一个DistributIdService节点进行获取，对每一个DistributIdService节点来说，数据库连接的是同一个数据库，那么可能会产生多个DistributIdService节点同时请求数据库获取号段，那么这个时候需要利用乐观锁来进行控制，比如在数据库表中增加一个version字段，在获取号段时使用如下SQL：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> id_generator <span class="keyword">set</span> current_max_id=<span class="comment">#&#123;newMaxId&#125;, version=version+1 where version = #&#123;version&#125;</span></span><br></pre></td></tr></table></figure></div><p>因为newMaxId是DistributIdService中根据oldMaxId+步长算出来的，只要上面的update更新成功了就表示号段获取成功了。</p><p>为了提供数据库层的高可用，需要对数据库使用多主模式进行部署，对于每个数据库来说要保证生成的号段不重复，这就需要利用最开始的思路，再在刚刚的数据库表中增加起始值和步长，比如如果现在是两台Mysql，那么 mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7…. mysql2将生成号段（2,1002]，自增的时候序列为2，4，6，8，10…</p><p>更详细的可以参考滴滴开源的TinyId：<a href="https://github.com/didi/tinyid/wiki/tinyid原理介绍" target="_blank" rel="noopener">github.com/didi/tinyid…</a></p><p>在TinyId中还增加了一步来提高效率，在上面的实现中，ID自增的逻辑是在DistributIdService中实现的，而实际上可以把自增的逻辑转移到业务应用本地，这样对于业务应用来说只需要获取号段，每次自增时不再需要请求调用DistributIdService了。</p><h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>上面的三种方法总的来说是基于自增思想的，而接下来就介绍比较著名的雪花算法-snowflake。</p><p>我们可以换个角度来对分布式ID进行思考，只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。</p><p>snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。</p><p>核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图：</p><p><img alt="雪花算法" data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.png" class="lazyload"></p><ul><li>第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。</li><li>时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li><li>工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。</li><li>序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID</li></ul><p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p><p>snowflake算法实现起来并不难，提供一个github上用java实现的：<a href="https://github.com/beyondfengyu/SnowFlake" target="_blank" rel="noopener">github.com/beyondfengy…</a></p><p><code>在大厂里，其实并没有直接使用snowflake，而是进行了改造</code>，因为snowflake算法中最难实践的就是工作机器id，原始的snowflake算法需要人工去为每台机器去指定一个机器id，并配置在某个地方从而让snowflake从此处获取机器id。</p><p>但是在大厂里，机器是很多的，人力成本太大且容易出错，所以大厂对snowflake进行了改造。</p><h3 id="百度（uid-generator）"><a href="#百度（uid-generator）" class="headerlink" title="百度（uid-generator）"></a>百度（uid-generator）</h3><p>github地址：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener">uid-generator</a></p><p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p><p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p><p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p><p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">github.com/baidu/uid-g…</a></p><h3 id="美团（Leaf）"><a href="#美团（Leaf）" class="headerlink" title="美团（Leaf）"></a>美团（Leaf）</h3><p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">Leaf</a></p><p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p><p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总得来说，上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这里额外再介绍一下使用Redis来生成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回，比如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></div><p>使用redis的效率是非常高的，但是要考虑持久化的问题。Redis支持RDB和AOF两种持久化的方式。</p><p>RDB持久化相当于定时打一个快照进行持久化，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，这个时候Redis挂掉了，重启Redis后会出现ID重复。</p><p>AOF持久化相当于对每条写命令进行持久化，如果Redis挂掉了，不会出现ID重复的现象，但是会由于incr命令过多，导致重启恢复数据时间过长。</p><h2 id="封装一个流水号ID生成器：id-spring-boot-starter"><a href="#封装一个流水号ID生成器：id-spring-boot-starter" class="headerlink" title="封装一个流水号ID生成器：id-spring-boot-starter"></a>封装一个流水号ID生成器：id-spring-boot-starter</h2><p><a href="https://www.codesheep.cn/2019/09/04/id-springbt-starter/" target="_blank" rel="noopener">https://www.codesheep.cn/2019/09/04/id-springbt-starter/</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="面试官问：你讲讲分布式事务问题的几种方案？"><a href="#面试官问：你讲讲分布式事务问题的几种方案？" class="headerlink" title="面试官问：你讲讲分布式事务问题的几种方案？"></a>面试官问：你讲讲分布式事务问题的几种方案？</h2><ul><li>两阶段提交方案/XA方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li><li>你们公司是如何处理分布式事务的？</li></ul><h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h2><p>众所周知，数据库能实现本地事务，也就是在同一个数据库中，你可以允许一组操作要么全都正确执行，要么全都不执行。</p><p><strong>本地事务</strong>：也就是目前的数据库只能支持同一个数据库中的事务。</p><p><strong>分布式事务：</strong>但现在的系统往往采用微服务架构，业务系统拥有独立的数据库，因此就出现了<strong><code>跨多个数据库</code>的事务需求</strong>，这种事务即为“分布式事务”。那么在目前数据库不支持跨库事务的情况下，我们应该如何实现分布式事务呢？</p><p>比如用户下单过程。当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：</p><ul><li>用户通过商品系统浏览商品，他看中了某一项商品，便点击下单</li><li>此时订单系统会生成一条订单</li><li>订单创建成功后，支付系统提供支付功能</li><li>当支付完成后，由积分系统为该用户增加积分</li></ul><p>上述步骤2、3、4需要在一个事务中完成。对于传统单体应用而言，实现事务非常简单，只需将这三个步骤放在一个方法A中，再用Spring的<code>@Transactional</code>注解标识该方法即可。Spring通过数据库的事务支持，保证这些步骤要么全都执行完成，要么全都不执行。但在这个微服务架构中，这三个步骤涉及三个系统，涉及三个数据库，此时我们必须在数据库和应用系统之间，通过某项黑科技，实现分布式事务的支持。</p><p>​        还有一种,分布式项目中,例如使用Dubbo实现的分布式项目,每一个微服务调用数据库时,单独占用一条数据库连接Connection(里面包含commit、rollback等方法),数据库的事务就是基于Connection实现的.所以也会出现分布式事务问题.</p><h2 id="5种实现方案："><a href="#5种实现方案：" class="headerlink" title="5种实现方案："></a>5种实现方案：</h2><ul><li>2PC/XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="2PC-XA"><a href="#2PC-XA" class="headerlink" title="2PC/XA"></a>2PC/XA</h3><p>XA 就是 X/Open DTP 定义的<code>交易中间件与数据库之间的接口规范</code>（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。 </p><p><strong>二阶提交协议</strong>和<strong>三阶提交协议</strong>就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现<strong>XA分布式事务</strong>的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)</p><p><img alt="image-20200529144413095" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9bgnzcztj30x50i7n5d.jpg" class="lazyload"></p><h4 id="两阶段"><a href="#两阶段" class="headerlink" title="两阶段"></a>两阶段</h4><p>第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</p><p>第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><ul><li>单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li><li>同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li><li>数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li></ul><p>总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。</p><h3 id="AT模式（无侵入）"><a href="#AT模式（无侵入）" class="headerlink" title="AT模式（无侵入）"></a>AT模式（无侵入）</h3><p>有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。。它规定了要实现分布式事务，需要三种角色：</p><ul><li><p>AP：Application 应用系统 它就是我们开发的业务系统，在我们开发的过程中，可以使用资源管理器提供的事务接口来实现分布式事务。</p></li><li><p>TM：Transaction Manager 事务管理器</p><ul><li>分布式事务的实现由事务管理器来完成，它会提供分布式事务的操作接口供我们的业务系统调用。这些接口称为TX接口。</li><li>事务管理器还管理着所有的资源管理器，通过它们提供的XA接口来同一调度这些资源管理器，以实现分布式事务。</li><li>DTP只是一套实现分布式事务的规范，并没有定义具体如何实现分布式事务，TM可以采用2PC、3PC、Paxos等协议实现分布式事务。</li></ul></li><li><p>RM：Resource Manager 资源管理器</p><ul><li>能够提供数据服务的对象都可以是资源管理器，比如：数据库、消息中间件、缓存等。大部分场景下，数据库即为分布式事务中的资源管理器。</li><li>资源管理器能够提供单数据库的事务能力，它们通过XA接口，将本数据库的提交、回滚等能力提供给事务管理器调用，以帮助事务管理器实现分布式的事务管理。</li><li>XA是DTP模型定义的接口，用于向事务管理器提供该资源管理器(该数据库)的提交、回滚等能力。</li><li>DTP只是一套实现分布式事务的规范，RM具体的实现是由数据库厂商来完成的。</li></ul></li></ul><p>典型实现就是Seate中的AT方案</p><h4 id="AT-模式如何做到对业务的无侵入-："><a href="#AT-模式如何做到对业务的无侵入-：" class="headerlink" title="AT 模式如何做到对业务的无侵入 ："></a>AT 模式如何做到对业务的无侵入 ：</h4><ul><li>一阶段：</li></ul><p>在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</p><p><img alt="image-20200529164409862" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9exhkt2jj30je08qn0p.jpg" class="lazyload"></p><ul><li>二阶段提交：</li></ul><p>二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p><p><img alt="image-20200529164527232" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9eytr45jj30v80h30xl.jpg" class="lazyload"></p><ul><li>二阶段回滚：</li></ul><p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。</p><p><img alt="image-20200529164543181" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9ez31qn4j30zb0fxad8.jpg" class="lazyload"></p><p>AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写“业务 SQL”，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。</p><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>（<strong>业务模型分 2 阶段设计</strong>）</p><p>用户接入 TCC ，最重要的是考虑如何将自己的业务模型拆成两阶段来实现。</p><p>以“扣钱”场景为例，在接入 TCC 前，对 A 账户的扣钱，只需一条更新账户余额的 SQL 便能完成；但是在接入 TCC 之后，用户就需要考虑如何将原来一步就能完成的扣钱操作，拆成两阶段，实现成三个方法，并且保证一阶段 Try 成功的话 二阶段 Confirm 一定能成功。</p><p><img alt="image-20200529180821216" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9hd0u26lj30ic08ot9z.jpg" class="lazyload"></p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>如上图所示，Try 方法作为一阶段准备方法，需要做资源的检查和预留。在扣钱场景下，Try 要做的事情是就是检查账户余额是否充足，预留转账资金，预留的方式就是冻结 A 账户的 转账资金。Try 方法执行之后，账号 A 余额虽然还是 100，但是其中 30 元已经被冻结了，不能被其他事务使用。</p><p>二阶段 Confirm 方法执行真正的扣钱操作。Confirm 会使用 Try 阶段冻结的资金，执行账号扣款。Confirm 方法执行之后，账号 A 在一阶段中冻结的 30 元已经被扣除，账号 A 余额变成 70 元 。</p><p>如果二阶段是回滚的话，就需要在 Cancel 方法内释放一阶段 Try 冻结的 30 元，使账号 A 的回到初始状态，100 元全部可用。</p><p>用户接入 TCC 模式，最重要的事情就是考虑如何将业务模型拆成 2 阶段，实现成 TCC 的 3 个方法，并且保证 Try 成功 Confirm 一定能成功。相对于 AT 模式，TCC 模式对业务代码有一定的侵入性，但是 TCC 模式无 AT 模式的全局行锁，TCC 性能会比 AT 模式高很多。</p><p><strong>2 TCC 设计 - 允许空回滚：</strong></p><p><img alt="image-20200529180726482" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9hc2vfeej310j0k211t.jpg" class="lazyload"></p><p>Cancel 接口设计时需要允许空回滚。在 Try 接口因为丢包时没有收到，事务管理器会触发回滚，这时会触发 Cancel 接口，这时 ==Cancel 执行时发现没有对应的事务 xid 或主键时，需要返回回滚成功==。让事务服务管理器认为已回滚，否则会不断重试，而 Cancel 又没有对应的业务数据可以进行回滚。</p><p><strong>3 TCC 设计 - 防悬挂控制：</strong></p><p><img alt="image-20200529180647874" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9hbe8aolj310l0k47do.jpg" class="lazyload"></p><p>悬挂的意思是：Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 ==Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。==</p><p>b+多少层</p><p><strong>4 TCC 设计 - 幂等控制：</strong></p><p><img alt="image-20200529180631756" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9hb56oq8j310f0k8ahf.jpg" class="lazyload"></p><p>幂等性的意思是：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常我们可以用事务 xid 或业务主键判重来控制。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>对比与前面提到的两阶段提交法, 有两大优势:</p><p>​        TCC 能够对分布式事务中的各个资源进行分别锁定, 分别提交与释放, 例如, 假设有AB 两个操作, 假设A操作耗时短, 那么A就能较快的完成自身的try-confirm-cancel 流程, 释放资源.无需等待 B 操作. 如果事后出现问题, 追加执行补偿性事务即可.</p><p>TCC 是绑定在各个子业务上的(除了 cancel 中的全局回滚操作), 也就是各服务之间可以在一定程度上”异步并行”执行。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>• 严格一致性</p><p>• 执行时间短</p><p>• 实时性要求高</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><a href="https://github.com/liuyangming/ByteTCC" target="_blank" rel="noopener">https://github.com/liuyangming/ByteTCC</a></p><h3 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h3><p><img alt="image-20200529163254714" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9elpmficj30ym0j8483.jpg" class="lazyload"></p><p>Saga 是一种补偿协议，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p><p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p><h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><p><code>特点</code>：参与者只能成功，不能失败</p><h4 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h4><p>可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能 够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致.</p><p><img alt="image-20200527135027605" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf6yox0gxfj30ai0cygmj.jpg" class="lazyload"></p><h5 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h5><ol><li>在系统A处理任务A前，首先向消息中间件发送一条消息,消息中间件收到后将该条消息持久化，但并不投递。</li><li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li><li>系统A收到确认应答后，则可以开始处理任务A；</li><li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。<br> 但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li><li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li><li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，那么MQ将此条事务移除</li><li>如果任务B执行失败，MQ需要对消息重新投递, 直至消费成功。</li></ol><p>上述过程中，如果任务A处理失败，那么需要进入回滚流程:</p><ul><li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li><li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li></ul><p>上面所介绍的<code>Commit</code>和<code>Rollback</code>都属于理想情况，但在实际系统中，<code>Commit</code>和<code>Rollback</code>指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是==超时询问机制==。</p><p>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的<code>Commit</code>或<code>Rollback</code>指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p><ul><li>提交 ，则将该消息投递给系统B。</li><li>回滚，则直接将条消息丢弃。</li><li>处理中，则继续等待。</li></ul><p>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p><p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。</p><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><p>• 执行周期较长</p><p>• 实时性要求不高</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>注意，这个方案需要消息队列具有事务消息的能力，阿里的<code>RocketMQ</code>可以实现这个目标。其他的MQ还不行。</p><hr><h4 id="最大努力通知（定期校对）"><a href="#最大努力通知（定期校对）" class="headerlink" title="最大努力通知（定期校对）"></a>最大努力通知（定期校对）</h4><p><img alt="image-20200527135941812" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf6yxpoyxfj30hi075jsh.jpg" class="lazyload"></p><h5 id="实现过程-2"><a href="#实现过程-2" class="headerlink" title="实现过程"></a>实现过程</h5><p>​    1、系统 A 本地事务（处理任务并插入到本地消息表）执行完之后，发送个消息到MQ；<br>​    2、消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；<br>​    3、当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</p><p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p><ul><li>上游系统向消息中间件发送消息失败</li><li>消息中间件向下游系统投递消息失败</li></ul><p><code>对于第一种情况</code>，需要在上游系统中建立消息重发机制。<strong>可以在上游系统建立一张本地消息表，并将任务处理过程和向本地消息表中插入消息 这两个步骤放在一个本地事务中完成</strong>。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。<strong>接下来会有一个专门的消息发送者不断地发送本地消息表中的消息</strong>，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p><p><code>对于第二种情况</code>，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，<strong>如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“<code>定期校对</code>”</strong>。</p><p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><p>交易结果消息的通知等</p><h5 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a>使用分析</h5><p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过重试机制+定期校对实现分布式事务，但相比于第一种方案，它达到<strong>数据一致性的周期较长</strong>，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p><p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。还有其他的一些解决思路，这里就暂时只描述这些。后续再学习。</p><h2 id="Seate底层原理"><a href="#Seate底层原理" class="headerlink" title="Seate底层原理"></a>Seate底层原理</h2><p>1、实现一个TM（Transaction Manager 全局事务管理器）和一个RM（Resource Manager 分支事务管理器），基于Netty用于协调分支的本地事务。</p><p>2、利用SpringAop实现Datasource类中Connection切面，在commit时通过新启一个子线程完成锁，其他事务commit由RM进行解锁。</p><p>3、由发起者开启一个事务组，并进行注册，由RM通知参与者完成注册。</p><h2 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h2><p>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><p>你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p><p>seate实现可参考：mall（<a href="https://github.com/macrozheng/mall）" target="_blank" rel="noopener">https://github.com/macrozheng/mall）</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aop实现读写分离</title>
      <link href="/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/aop%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AE%9E%E6%88%98/"/>
      <url>/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/aop%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="读写分离很难吗？SpringBoot结合aop简单就实现了"><a href="#读写分离很难吗？SpringBoot结合aop简单就实现了" class="headerlink" title="读写分离很难吗？SpringBoot结合aop简单就实现了"></a>读写分离很难吗？SpringBoot结合aop简单就实现了</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>入职新公司到现在也有一个月了，完成了手头的工作，前几天终于有时间研究下公司旧项目的代码。在研究代码的过程中，发现项目里用到了Spring Aop来实现数据库的读写分离，本着自己爱学习(我自己都不信…)的性格，决定写个实例工程来实现spring aop读写分离的效果。</p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><ul><li>数据库：MySql</li><li>库数量：2个，一主一从</li></ul><p>关于mysql的主从环境部署，可以参考：</p><blockquote><p><a href="https://juejin.im/post/5dd13778e51d453da86c0e6f" target="_blank" rel="noopener">https://juejin.im/post/5dd13778e51d453da86c0e6f</a></p></blockquote><h2 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h2><p>首先，毫无疑问，先开始搭建一个SpringBoot工程，然后在pom文件中引入如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.16&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 动态数据源 所需依赖 ### start--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 动态数据源 所需依赖 ### end--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></div><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>引入基本的依赖后，整理一下目录结构，完成后的项目骨架大致如下：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbufnsEwkXGcz440NmMSSxL4ticvssaN6jwJrIPOdMMpdgCF7Sw9tQKEnjhQFxnZm6FCwEPYXzcD4b9Q/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>创建一张表user，在主库执行sql语句同时在从库生成对应的表数据</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;user&#96;;</span><br><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;user_id&#96; bigint(20) NOT NULL COMMENT &#39;用户id&#39;,</span><br><span class="line">  &#96;user_name&#96; varchar(255) DEFAULT &#39;&#39; COMMENT &#39;用户名称&#39;,</span><br><span class="line">  &#96;user_phone&#96; varchar(50) DEFAULT &#39;&#39; COMMENT &#39;用户手机&#39;,</span><br><span class="line">  &#96;address&#96; varchar(255) DEFAULT &#39;&#39; COMMENT &#39;住址&#39;,</span><br><span class="line">  &#96;weight&#96; int(3) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;权重，大者优先&#39;,</span><br><span class="line">  &#96;created_at&#96; datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;updated_at&#96; datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;user_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;user&#96; VALUES (&#39;1196978513958141952&#39;, &#39;测试1&#39;, &#39;18826334748&#39;, &#39;广州市海珠区&#39;, &#39;1&#39;, &#39;2019-11-20 10:28:51&#39;, &#39;2019-11-22 14:28:26&#39;);</span><br><span class="line">INSERT INTO &#96;user&#96; VALUES (&#39;1196978513958141953&#39;, &#39;测试2&#39;, &#39;18826274230&#39;, &#39;广州市天河区&#39;, &#39;2&#39;, &#39;2019-11-20 10:29:37&#39;, &#39;2019-11-22 14:28:14&#39;);</span><br><span class="line">INSERT INTO &#96;user&#96; VALUES (&#39;1196978513958141954&#39;, &#39;测试3&#39;, &#39;18826273900&#39;, &#39;广州市天河区&#39;, &#39;1&#39;, &#39;2019-11-20 10:30:19&#39;, &#39;2019-11-22 14:28:30&#39;);</span><br></pre></td></tr></table></figure></div><h3 id="主从数据源配置"><a href="#主从数据源配置" class="headerlink" title="主从数据源配置"></a>主从数据源配置</h3><p>application.yml，主要信息是主从库的数据源配置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line">spring:</span><br><span class="line">  jackson:</span><br><span class="line">      date-format: yyyy-MM-dd HH:mm:ss</span><br><span class="line">      time-zone: GMT+8</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    master:</span><br><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3307&#x2F;user?serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;useSSL&#x3D;false&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;allowMultiQueries&#x3D;true</span><br><span class="line">      username: root</span><br><span class="line">      password:</span><br><span class="line">    slave:</span><br><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3308&#x2F;user?serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;useSSL&#x3D;false&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;allowMultiQueries&#x3D;true</span><br><span class="line">      username: root</span><br><span class="line">      password:</span><br></pre></td></tr></table></figure></div><p>因为有一主一从两个数据源，我们用枚举类来代替，方便我们使用时能对应</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">public enum DynamicDataSourceEnum &#123;</span><br><span class="line">    MASTER(&quot;master&quot;),</span><br><span class="line">    SLAVE(&quot;slave&quot;);</span><br><span class="line">    private String dataSourceName;</span><br><span class="line">    DynamicDataSourceEnum(String dataSourceName) &#123;</span><br><span class="line">        this.dataSourceName &#x3D; dataSourceName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>数据源配置信息类 DataSourceConfig，这里配置了两个数据源，masterDb和slaveDb</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;com.xjt.proxy.mapper&quot;, sqlSessionTemplateRef &#x3D; &quot;sqlTemplate&quot;)</span><br><span class="line">public class DataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 主库</span><br><span class="line">      @Bean</span><br><span class="line">      @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.master&quot;)</span><br><span class="line">      public DataSource masterDb() &#123;</span><br><span class="line">  return DruidDataSourceBuilder.create().build();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从库</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnProperty(prefix &#x3D; &quot;spring.datasource&quot;, name &#x3D; &quot;slave&quot;, matchIfMissing &#x3D; true)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.slave&quot;)</span><br><span class="line">    public DataSource slaveDb() &#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 主从动态配置</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public DynamicDataSource dynamicDb(@Qualifier(&quot;masterDb&quot;) DataSource masterDataSource,</span><br><span class="line">        @Autowired(required &#x3D; false) @Qualifier(&quot;slaveDb&quot;) DataSource slaveDataSource) &#123;</span><br><span class="line">        DynamicDataSource dynamicDataSource &#x3D; new DynamicDataSource();</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        targetDataSources.put(DynamicDataSourceEnum.MASTER.getDataSourceName(), masterDataSource);</span><br><span class="line">        if (slaveDataSource !&#x3D; null) &#123;</span><br><span class="line">            targetDataSources.put(DynamicDataSourceEnum.SLAVE.getDataSourceName(), slaveDataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        dynamicDataSource.setTargetDataSources(targetDataSources);</span><br><span class="line">        dynamicDataSource.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        return dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory sessionFactory(@Qualifier(&quot;dynamicDb&quot;) DataSource dynamicDataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setMapperLocations(</span><br><span class="line">            new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper&#x2F;*Mapper.xml&quot;));</span><br><span class="line">        bean.setDataSource(dynamicDataSource);</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionTemplate sqlTemplate(@Qualifier(&quot;sessionFactory&quot;) SqlSessionFactory sqlSessionFactory) &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean(name &#x3D; &quot;dataSourceTx&quot;)</span><br><span class="line">    public DataSourceTransactionManager dataSourceTx(@Qualifier(&quot;dynamicDb&quot;) DataSource dynamicDataSource) &#123;</span><br><span class="line">        DataSourceTransactionManager dataSourceTransactionManager &#x3D; new DataSourceTransactionManager();</span><br><span class="line">        dataSourceTransactionManager.setDataSource(dynamicDataSource);</span><br><span class="line">        return dataSourceTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="设置路由"><a href="#设置路由" class="headerlink" title="设置路由"></a>设置路由</h3><p>设置路由的目的为了方便查找对应的数据源，我们可以用ThreadLocal保存数据源的信息到每个线程中，方便我们需要时获取</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DataSourceContextHolder &#123;</span><br><span class="line">    private static final ThreadLocal&lt;String&gt; DYNAMIC_DATASOURCE_CONTEXT &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">    public static void set(String datasourceType) &#123;</span><br><span class="line">        DYNAMIC_DATASOURCE_CONTEXT.set(datasourceType);</span><br><span class="line">    &#125;</span><br><span class="line">    public static String get() &#123;</span><br><span class="line">        return DYNAMIC_DATASOURCE_CONTEXT.get();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void clear() &#123;</span><br><span class="line">        DYNAMIC_DATASOURCE_CONTEXT.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>获取路由</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDataSource extends AbstractRoutingDataSource &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">        return DataSourceContextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>AbstractRoutingDataSource的作用是基于查找key路由到对应的数据源，它内部维护了一组目标数据源，并且做了路由key与目标数据源之间的映射，提供基于key查找数据源的方法。更多springboot文章</p><h3 id="数据源的注解"><a href="#数据源的注解" class="headerlink" title="数据源的注解"></a>数据源的注解</h3><p>为了可以方便切换数据源，我们可以写一个注解，注解中包含数据源对应的枚举值，默认是主库，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Documented</span><br><span class="line">public @interface DataSourceSelector &#123;</span><br><span class="line"></span><br><span class="line">    DynamicDataSourceEnum value() default DynamicDataSourceEnum.MASTER;</span><br><span class="line">    boolean clear() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="aop切换数据源"><a href="#aop切换数据源" class="headerlink" title="aop切换数据源"></a>aop切换数据源</h3><p>到这里，aop终于可以现身出场了，这里我们定义一个aop类，对有注解的方法做切换数据源的操作，具体代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Aspect</span><br><span class="line">@Order(value &#x3D; 1)</span><br><span class="line">@Component</span><br><span class="line">public class DataSourceContextAop &#123;</span><br><span class="line"></span><br><span class="line"> @Around(&quot;@annotation(com.xjt.proxy.dynamicdatasource.DataSourceSelector)&quot;)</span><br><span class="line">    public Object setDynamicDataSource(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        boolean clear &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method &#x3D; this.getMethod(pjp);</span><br><span class="line">            DataSourceSelector dataSourceImport &#x3D; method.getAnnotation(DataSourceSelector.class);</span><br><span class="line">            clear &#x3D; dataSourceImport.clear();</span><br><span class="line">            DataSourceContextHolder.set(dataSourceImport.value().getDataSourceName());</span><br><span class="line">            log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数据源切换至：&#123;&#125;&quot;, dataSourceImport.value().getDataSourceName());</span><br><span class="line">            return pjp.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (clear) &#123;</span><br><span class="line">                DataSourceContextHolder.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Method getMethod(JoinPoint pjp) &#123;</span><br><span class="line">        MethodSignature signature &#x3D; (MethodSignature)pjp.getSignature();</span><br><span class="line">        return signature.getMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>到这一步，我们的准备配置工作就完成了，下面开始测试效果。</p><p>先写好Service文件，包含读取和更新两个方法，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @DataSourceSelector(value &#x3D; DynamicDataSourceEnum.SLAVE)</span><br><span class="line">    public List&lt;User&gt; listUser() &#123;</span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectAll();</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DataSourceSelector(value &#x3D; DynamicDataSourceEnum.MASTER)</span><br><span class="line">    public int update() &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUserId(Long.parseLong(&quot;1196978513958141952&quot;));</span><br><span class="line">        user.setUserName(&quot;修改后的名字2&quot;);</span><br><span class="line">        return userMapper.updateByPrimaryKeySelective(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DataSourceSelector(value &#x3D; DynamicDataSourceEnum.SLAVE)</span><br><span class="line">    public User find() &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">        user.setUserId(Long.parseLong(&quot;1196978513958141952&quot;));</span><br><span class="line">        return userMapper.selectByPrimaryKey(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>根据方法上的注解可以看出，读的方法走从库，更新的方法走主库，更新的对象是userId为1196978513958141953 的数据，</p><p>然后我们写个测试类测试下是否能达到效果，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void listUser() &#123;</span><br><span class="line">        List&lt;User&gt; users &#x3D; userService.listUser();</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            System.out.println(user.getUserId());</span><br><span class="line">            System.out.println(user.getUserName());</span><br><span class="line">            System.out.println(user.getUserPhone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    void update() &#123;</span><br><span class="line">        userService.update();</span><br><span class="line">        User user &#x3D; userService.find();</span><br><span class="line">        System.out.println(user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h3><p>1、读取方法</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbufnsEwkXGcz440NmMSSxL4teDwguTvMEY7BKHMickI2PPoO856CibdLp9kQRR2JHdFaEJugr28IMICg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>2、更新方法</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/eQPyBffYbufnsEwkXGcz440NmMSSxL4tkEl81S9ncE0fuhz4wBGTtibM62u6oGib9MRnpTmUlcoblB7qQrzeQQfQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>执行之后，比对数据库就可以发现主从库都修改了数据，说明我们的读写分离是成功的。当然，更新方法可以指向从库，这样一来就只会修改到从库的数据，而不会涉及到主库。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>上面测试的例子虽然比较简单，但也符合常规的读写分离配置。值得说明的是，读写分离的作用是为了缓解写库，也就是主库的压力，但一定要基于数据一致性的原则，就是保证主从库之间的数据一定要一致。如果一个方法涉及到写的逻辑，那么该方法里所有的数据库操作都要走主库。</p><p>假设写的操作执行完后数据有可能还没同步到从库，然后读的操作也开始执行了，如果这个读取的程序走的依然是从库的话，那么就会出现数据不一致的现象了，这是我们不允许的。<br>最后发一下项目的github地址，有兴趣的同学可以看下：</p><blockquote><p><a href="https://github.com/Taoxj/mysql-proxy" target="_blank" rel="noopener">https://github.com/Taoxj/mysql-proxy</a></p></blockquote><h3 id="參考："><a href="#參考：" class="headerlink" title="參考："></a>參考：</h3><blockquote><p><a href="https://www.cnblogs.com/cjsblog/p/9712457.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjsblog/p/9712457.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式限流</title>
      <link href="/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/"/>
      <url>/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><p><strong>固定窗口</strong></p><p>（1）划分时间为多个窗口：固定一个时间周期，如10秒或者30秒</p><p>（2）在每个窗口期内，每有一个请求，计数器加一</p><p>（3）如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃</p><p>（4）下一个时间窗口时，计数器重置</p><p><strong>滑动窗口</strong></p><p>滑动窗口其实就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如1分钟的固定窗口切分为60个1秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdb0rlYFa5SMHMlIvQHsKa1dTd6zEqfY056zWdQIEUz33TMDNZF6YlvOFtdHian8N6ib3eoJRtAa1XXg/640?wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>同时，我们还可以得出一个结论是：如果固定窗口的「固定周期」已经很小了，那么使用滑动窗口的意义也就没有了。举个例子，现在的固定窗口周期已经是1秒了，再切分到毫秒级别能反而得不偿失，会带来巨大的性能和资源损耗。</p><p><strong>漏桶</strong></p><p>（1）将每个请求视为“水滴”放入漏桶进行存储</p><p>（2）漏桶以固定速率漏出水滴（处理请求）</p><p>（3）漏桶满了，多余的水滴就丢弃</p><p><img alt="img" data-src="https://pics6.baidu.com/feed/5d6034a85edf8db1b7a7ce16ef076852574e74e6.jpeg?token=2ca827fd79b590587b7e58fa9d0e6f6f" class="lazyload"></p><p>简单说来就是：如果当前速率小于阈值则直接处理请求，否则不直接处理请求，进入缓冲区，并增加当前水位</p><p>漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。</p><p><code>漏桶算法的缺陷</code>也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。</p><p><strong>令牌桶</strong></p><p>（1）令牌以固定速率生成</p><p>（2）生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌直接丢弃，当请求到达时，会尝试从令牌桶中取令牌，得到令牌的请求可以执行</p><p>（3）如果桶空了，则丢弃取令牌的请求</p><p><img alt="img" data-src="https://pics6.baidu.com/feed/ac4bd11373f082024f829b1baddf4eebab641ba8.jpeg?token=d12e747d4133b6b97c99dbdf8b35def9" class="lazyload"></p><p>令牌桶的容量大小理论上就是程序需要支撑的最大并发数。令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求，因此是目前使用较为广泛的一种限流算法。</p><p>对于令牌桶的代码实现，可以直接使用Guava包中的RateLimiter</p><p><strong>分布式场景</strong></p><p>单节点模式下，使用RateLimiter进行限流一点问题都没有。但线上是分布式系统，布署了多个节点，而且多个节点最终调用的是同一个API/服务商接口。虽然我们对单个节点能做到将QPS限制在N/s，但是多节点条件下，如果每个节点均是N/s，那么到服务商那边的总请求就是<strong>节点数乘以N/s</strong>，于是限流效果失效。使用该方案对单节点的阈值控制是难以适应分布式环境的。</p><p>我们来看一下最简单的流量模型：</p><p><img alt="img" data-src="https://pics0.baidu.com/feed/242dd42a2834349beb938ae92fcea0c837d3bef5.jpeg?token=14431143680ac0280ac8006d485f1ef6" class="lazyload"></p><p>用户的请求从网关转发到后台服务，后台服务承接流量，调用缓存获取数据，缓存中的数据和数据库交互。这个模型就像一个漏斗一样，流量自上而下递减。</p><p><strong>解决方案一：网关限流</strong></p><p>服务网关，作为整个分布式链路中的第一关卡，承接了所有用户的访问请求，所以从这里限流肯定是大头。目前主流的网关层有以软件为代表的Nginx，Spring Cloud中的Gateway和Zuul这类的组件，当然也有硬件的网关限流。</p><p>1.Nginx限流：思想就是漏桶算法，即能够强行保证请求实时处理的速度不会超过设置的阈值</p><p><strong>解决方案二：服务限流Redis 的 RateLimiter</strong></p><p><a href="https://segmentfault.com/a/1190000012947169" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012947169</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">String token = RedisRateLimiter.acquireTokenFromBucket(jedis, LIMIT, TIMEOUT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">response.sendError(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 你的业务逻辑</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jedisPool.returnResource(jedis);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式Session</title>
      <link href="/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FSession/"/>
      <url>/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FSession/</url>
      
        <content type="html"><![CDATA[<h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>服务器为每个用户创建一个会话，存储用户的相关信息，以便多次请求能够定位到同一个上下文。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p><p>Web开发中，web-server可以自动为同一个浏览器的访问用户自动创建session，提供数据存储功能。最常见的，会把用户的登录信息、用户信息存储在session中，以保持登录状态。</p><h2 id="什么是session一致性问题？"><a href="#什么是session一致性问题？" class="headerlink" title="什么是session一致性问题？"></a>什么是session一致性问题？</h2><p>只要用户不重启浏览器，每次http短连接请求，理论上服务端都能定位到session，保持会话。</p><h2 id="分布式session"><a href="#分布式session" class="headerlink" title="分布式session"></a>分布式session</h2><p>单服务器web应用中，session信息只需存在该服务器中，这是我们前几年最常接触的方式，但是近几年随着分布式系统的流行，单系统已经不能满足日益增长的百万级用户的需求，集群方式部署服务器已在很多公司运用起来，当高并发量的请求到达服务端的时候通过负载均衡的方式分发到集群中的某个服务器，这样就有可能导致同一个用户的多次请求被分发到集群的不同服务器上，就会出现取不到session数据的情况，于是session的共享就成了一个问题。</p><p><img alt="img" data-src="https://images2017.cnblogs.com/blog/926638/201711/926638-20171117190525546-1072349257.png" class="lazyload"></p><p>如上图，假设用户包含登录信息的session都记录在第一台web-server上，反向代理如果将请求路由到另一台web-server上，可能就找不到相关信息，而导致用户需要重新登录。</p><h2 id="Session一致性解决方案"><a href="#Session一致性解决方案" class="headerlink" title="Session一致性解决方案"></a>Session一致性解决方案</h2><h3 id="1-session复制（同步）"><a href="#1-session复制（同步）" class="headerlink" title="1.session复制（同步）"></a>1.session复制（同步）</h3><p> <img alt="img" data-src="https://images2017.cnblogs.com/blog/926638/201711/926638-20171117190609421-1278140860.png" class="lazyload"></p><p><strong>思路</strong>：多个web-server之间相互同步session，这样每个web-server之间都包含全部的session</p><p><strong>优点</strong>：web-server支持的功能，应用程序不需要修改代码</p><p><strong>不足</strong>：</p><ul><li>session的同步需要数据传输，占<strong>内网带宽</strong>，有时延</li><li>所有web-server都包含所有session数据，数据量受内存限制，无法水平扩展</li><li>有更多web-server时要歇菜</li></ul><p><strong>操作:</strong></p><p>1、修改tomcat下server.xml文件,开启如下配置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cluster className=<span class="string">"org.apache.catalina.ha.tcp.SimpleTcpCluster"</span>/&gt;</span><br></pre></td></tr></table></figure></div><p>2、本地项目web.xml增加如下配置:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--tomcat Session复制必须开启--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributable</span> /&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="客户端存储法"><a href="#客户端存储法" class="headerlink" title="客户端存储法"></a>客户端存储法</h3><p><img alt="img" data-src="https://images2017.cnblogs.com/blog/926638/201711/926638-20171117191245265-301978953.png" class="lazyload"></p><p><strong>思路</strong>：服务端存储所有用户的session，内存占用较大，可以将session存储到浏览器cookie中，每个端只要存储一个用户的数据了</p><p><strong>优点</strong>：服务端不需要存储</p><p><strong>缺点</strong>：</p><ul><li>每次http请求都携带session，占<strong>外网带宽</strong></li><li>数据存储在端上，并在网络传输，存在泄漏、篡改、窃取等安全隐患</li><li>session存储的数据大小受cookie限制</li></ul><p>“端存储”的方案虽然不常用，但确实是一种思路。</p><h3 id="反向代理hash一致性"><a href="#反向代理hash一致性" class="headerlink" title="反向代理hash一致性"></a>反向代理hash一致性</h3><p> <strong>思路</strong>：web-server为了保证高可用，有多台冗余，反向代理层能不能做一些事情，让同一个用户的请求保证落在一台web-server上呢？</p><p> <img alt="img" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf6598f853j30k80bsaci.jpg" class="lazyload"></p><h4 id="方案一：四层代理hash"><a href="#方案一：四层代理hash" class="headerlink" title="方案一：四层代理hash"></a><strong>方案一：四层代理hash</strong></h4><p>反向代理层使用用户ip来做hash，以保证同一个ip的请求落在同一个web-server上</p><p><img alt="img" data-src="https://images2017.cnblogs.com/blog/926638/201711/926638-20171117190819921-1868250278.png" class="lazyload"></p><h4 id="方案二：七层代理hash"><a href="#方案二：七层代理hash" class="headerlink" title="方案二：七层代理hash"></a><strong>方案二：七层代理hash</strong></h4><p>反向代理使用http协议中的某些业务属性来做hash，例如sid，city_id，user_id等，能够更加灵活的实施hash策略，以保证同一个浏览器用户的请求落在同一个web-server上</p><p><strong>优点</strong>：</p><ul><li>只需要改nginx配置，不需要修改应用代码</li><li>负载均衡，只要hash属性是均匀的，多台web-server的负载是均衡的</li><li>可以支持web-server水平扩展（session同步法是不行的，受内存限制）</li></ul><p><strong>不足</strong>：</p><ul><li>如果web-server重启，一部分session会丢失，产生业务影响，例如部分用户重新登录</li><li>如果web-server水平扩展，rehash后session重新分布，也会有一部分用户路由不到正确的session</li></ul><p>session一般是有有效期的，所有不足中的两点，可以认为等同于部分session失效，一般问题不大。</p><p>对于四层hash还是七层hash，个人推荐前者：<strong>让专业的软件做专业的事情</strong>，反向代理就负责转发，尽量不要引入应用层业务属性，除非不得不这么做（例如，有时候多机房多活需要按照业务属性路由到不同机房的web-server）。</p><h3 id="后端统一集中存储"><a href="#后端统一集中存储" class="headerlink" title="后端统一集中存储"></a>后端统一集中存储</h3><p> <img alt="img" data-src="https://images2017.cnblogs.com/blog/926638/201711/926638-20171117190914734-312299182.png" class="lazyload"></p><p><strong>思路</strong>：将session存储在web-server后端的存储层，数据库或者缓存</p><p><strong>优点</strong>：</p><ul><li>没有安全隐患</li><li>可以水平扩展，数据库/缓存水平切分即可</li><li>web-server重启或者扩容都不会有session丢失</li></ul><p><strong>不足</strong>：增加了一次网络调用，并且需要修改应用代码</p><h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><p>1、pom文件引入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>2、配置类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span> <span class="comment">//(maxInactiveIntervalInSeconds = 604800)//session超时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>3、当成本地的Session正常使用即可.</p><p>具体可参考:</p><p>[<a href="https://sunweiguo.github.io/2019/01/23/miscellany/06Spring%20Session/]" target="_blank" rel="noopener">https://sunweiguo.github.io/2019/01/23/miscellany/06Spring%20Session/]</a>(<a href="https://sunweiguo.github.io/2019/01/23/miscellany/06Spring" target="_blank" rel="noopener">https://sunweiguo.github.io/2019/01/23/miscellany/06Spring</a> Session/)</p><p><code>原理</code>: 就是通过过滤器对HttpRequest中的Session进行了一次封装.</p><p><img alt="image-20200526210333685" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf65keqq7sj30mk0dlwky.jpg" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><p>范式就是规范，要满足第二范式必须先满足第一范式，要满足第三范式，必须要先满足第二范式。</p><ul><li>1NF(第一范式)：列数据不可分割，即一列不能有多个值</li><li>2NF(第二范式)：主键(每一行都有唯一标识)</li><li>3NF(第三范式)：外键(表中不包含已在其他表中包含的非主关键信息)</li></ul><h2 id="count-1-、count-与count-列名-的区别"><a href="#count-1-、count-与count-列名-的区别" class="headerlink" title="count(1)、count(*)与count(列名)的区别"></a>count(1)、count(*)与count(列名)的区别</h2><p>执行效果上： </p><p>count(*)=count(1)&lt;&gt;count(列名)</p><p>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL </p><p>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL </p><p>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空不统计。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="查看表的存储引擎"><a href="#查看表的存储引擎" class="headerlink" title="查看表的存储引擎"></a><strong>查看表的存储引擎</strong></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">"table_name"</span> ;</span><br></pre></td></tr></table></figure></div><h3 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h3><ol><li><p><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p></li><li><p><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p></li><li><p><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</p></li><li><p><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：<a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MySQL-InnoDB-MVCC多版本并发控制</a></p><p>​        <code>MVCC协议</code>中,每个用户在连接数据库时看到的是一个具有一致性状态的镜像,每个事务在提交到数据库之前对其他用户均是不可见的。当事务需要更新数据时,不会直接覆盖以前的数据,而是生成—个新的版本的数据,因此一条数据会有多个版本存储,但是同一时刻只有最新的版本号是有效的。因此,读的时候就可以保证总是以当前时刻的版本的数据可以被读到,不论这条数据后来是否被修改或删除。</p><p><code>undo log</code>是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。</p></li></ol><ol start="5"><li><strong>MyISAM</strong>主键索引是非聚集索引，存储的数据与索引分离，需要回表。而<strong>InnoDB</strong>主键索引是聚集索引。</li></ol><p>InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p><p><strong>表级锁和行级锁对比：</strong></p><ul><li><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h2 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h2><h3 id="索引的数据结构-底层实现"><a href="#索引的数据结构-底层实现" class="headerlink" title="索引的数据结构(底层实现)?"></a>索引的数据结构(底层实现)?</h3><p>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.</p><h3 id="B树和B-树区别"><a href="#B树和B-树区别" class="headerlink" title="B树和B+树区别"></a>B树和B+树区别</h3><ul><li>B树的所有节点既存放键(key) 也存放数据(data)；而B+树只有叶子节点存放 key和data，其他内节点只存放key。</li><li>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点，有利于区间查找。</li><li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p>由于磁盘的读取也是按<strong>block</strong>块操作的（内存是按<strong>page</strong>页面操作的），因此B+树的节点大小一般设置为和磁盘块大小一致，这样一个B+树节点，就可以通过一次磁盘I/O把一个磁盘块的数据全部存储下来，<strong>所以当使用B-树存储索引的时候，磁盘I/O的操作次数是最少的</strong></p><p>那么MySQL最终为什么要采用B+树存储索引结构呢，那么看看B-树和B+树在存储结构上有什么不同？</p><ul><li>B-树的每一个节点，存了关键字和对应的数据地址，而B+树的非叶子节点只存关键字，不存数据地址。因此B+树的每一个非叶子节点存储的关键字是远远多于B-树的，B+树的叶子节点存放关键字和数据，因此，<strong>从树的高度上来说，B+树的高度要小于B-树，使用的磁盘I/O次数少，因此查询会更快一些。</strong></li><li>B-树由于每个节点都存储关键字和数据，因此离根节点进的数据，查询的就快，离根节点远的数据，查询的就慢；B+树所有的数据都存在叶子节点上，因此在B+树上搜索关键字，找到对应数据的<strong>时间是比较平均</strong>的，没有快慢之分。</li><li>在B-树上如果做区间查找，遍历的节点是非常多的；B+树所有叶子节点被连接成了有序链表结构，因此做整表遍历和<strong>区间查找是非常容易</strong>的。</li></ul><p>经过优化的B+树，主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。</p><p><img alt="image-20200527195106340" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf793blg6mj30eh084jul.jpg" class="lazyload"></p><p><img alt="image-20200527195115403" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf793gwpn1j30dz09m0x6.jpg" class="lazyload"></p><p>B树</p><p><img alt="image-20200527195146433" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf7940mxe1j308907mdgu.jpg" class="lazyload"></p><h3 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a><strong>Hash索引和B+树所有有什么区别或者说优劣呢?</strong></h3><p>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p><p>hash索引不支持使用索引进行排序,模糊查询</p><h3 id="为什么不对表中的每一个列创建一个索引呢？"><a href="#为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="为什么不对表中的每一个列创建一个索引呢？"></a>为什么不对表中的每一个列创建一个索引呢？</h3><p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><h3 id="为什么索引能提高查询速度"><a href="#为什么索引能提高查询速度" class="headerlink" title="为什么索引能提高查询速度"></a>为什么索引能提高查询速度</h3><h4 id="先从-MySQL-的基本存储结构说起"><a href="#先从-MySQL-的基本存储结构说起" class="headerlink" title="先从 MySQL 的基本存储结构说起"></a>先从 MySQL 的基本存储结构说起</h4><p>MySQL的基本存储结构是页(记录都存在页里边)：</p><p><img alt="image-20200527165933957" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf744uarg0j30lw0hewj5.jpg" class="lazyload"></p><p><img alt="image-20200527165912250" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf744gnf4jj30yy0cd46k.jpg" class="lazyload"></p><ul><li><strong>各个数据页可以组成一个双向链表</strong></li><li>每个数据页中的记录又可以组成一个单向链表<ul><li>每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li><li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li></ul></li></ul><p>所以说，如果我们写select * from user where indexname = ‘xxx’这样没有进行任何优化的sql语句，默认会这样做：</p><ol><li><strong>定位到记录所在的页：需要遍历双向链表，找到所在的页</strong></li><li><strong>从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了</strong></li></ol><p>很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。</p><h4 id="使用索引之后"><a href="#使用索引之后" class="headerlink" title="使用索引之后"></a>使用索引之后</h4><p>索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：</p><p><img alt="image-20200527165842152" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf743xob4oj30zh0itgyz.jpg" class="lazyload"></p><p>要找到id为8的记录简要步骤：</p><p><img alt="image-20200527165814369" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf743gld1lj30zd0jmndj.jpg" class="lazyload"></p><p>很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 <strong>“目录”</strong> 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）</p><p>其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h4><p><strong>数据表的主键列使用的就是主键索引。</strong></p><p><strong>一张数据表有只能有一个主键，并且主键不能为null，不能重复。</strong></p><p>在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。</p><h4 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h4><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ol><li><p><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。</strong>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p></li><li><p><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</strong></p></li><li><p><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</p></li><li><p><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。</p></li></ol><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>在 Mysql 中，InnoDB引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><p><code>聚集索引的优点</code></p><p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><p><code>聚集索引的缺点</code></p><ol><li><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p><p><strong>二级索引属于非聚集索引。</strong></p><p>非聚集索引的叶子节点存放的是主键+列值， 需要根据主键再回表查数据。</p><p><code>非聚集索引的优点</code></p><p><strong>更新代价比聚集索引要小</strong>,因为非聚集索引的叶子节点是不存放数据的</p><p><code>非聚集索引的缺点</code></p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><h4 id="非聚集索引一定回表查询吗-覆盖索引"><a href="#非聚集索引一定回表查询吗-覆盖索引" class="headerlink" title="非聚集索引一定回表查询吗(覆盖索引)?"></a>非聚集索引一定回表查询吗(覆盖索引)?</h4><p><strong>非聚集索引不一定回表查询。</strong></p><blockquote><p>试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> username=<span class="string">'guang19'</span>;</span><br></pre></td></tr></table></figure></div><blockquote><p>那么这个索引的key本身就是name，查到对应的name直接返回就行了，无需回表查询。</p></blockquote><p><strong>即使是MYISAM也是这样，虽然MYISAM的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢?</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><p>主键索引本身的key就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条SQL需要查询name，name字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><hr><h3 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h3><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p><h4 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h4><p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><h3 id="索引不适合哪些场景"><a href="#索引不适合哪些场景" class="headerlink" title="索引不适合哪些场景"></a><strong>索引不适合哪些场景</strong></h3><ul><li>数据量少的不适合加索引</li><li>更新比较频繁的也不适合加索引</li><li>区分度低的字段不适合加索引（如性别） 对比 部件表 rest_status_id 就不需要添加索引。</li></ul><p>​    索引区分度越明显，查询效率越高</p><hr><h2 id="一条SQL语句执行得很慢的原因有哪些？"><a href="#一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="一条SQL语句执行得很慢的原因有哪些？"></a>一条SQL语句执行得很慢的原因有哪些？</h2><h3 id="大多数情况是正常的，只是偶尔会出现很慢的情况。"><a href="#大多数情况是正常的，只是偶尔会出现很慢的情况。" class="headerlink" title="大多数情况是正常的，只是偶尔会出现很慢的情况。"></a>大多数情况是正常的，只是偶尔会出现很慢的情况。</h3><h4 id="数据库在刷新脏页（flush）我也无奈啊"><a href="#数据库在刷新脏页（flush）我也无奈啊" class="headerlink" title="数据库在刷新脏页（flush）我也无奈啊"></a>数据库在刷新脏页（flush）我也无奈啊</h4><p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p><blockquote><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p></blockquote><p><strong>刷脏页有下面4种场景（后两种不用太关注“性能”问题）：</strong></p><ul><li><strong>redolog写满了：</strong>redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</li><li><strong>内存不够用了：</strong>如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li></ul><h4 id="拿不到锁我能怎么办"><a href="#拿不到锁我能怎么办" class="headerlink" title="拿不到锁我能怎么办"></a>拿不到锁我能怎么办</h4><p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p><h3 id="在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。"><a href="#在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。" class="headerlink" title="在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。"></a>在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</h3><h4 id="没用到索引"><a href="#没用到索引" class="headerlink" title="没用到索引"></a>没用到索引</h4><p><strong>（1）、字段没有索引</strong></p><p><strong>（2）、字段有索引，但却没有用索引</strong></p><ul><li>以“%”开头的LIKE语句，模糊匹配</li><li>OR语句前后没有同时使用索引</li></ul><h4 id="呵呵，数据库自己选错索引了"><a href="#呵呵，数据库自己选错索引了" class="headerlink" title="呵呵，数据库自己选错索引了"></a>呵呵，数据库自己选错索引了</h4><p>我们在进行查询操作的时候，例如</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure></div><p>我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>.也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p><p>好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 &lt; c and c &lt; 100000 的数据。</p><p><strong>为什么会这样呢？</strong></p><p>其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。</p><p>如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c &lt; and c &lt; 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。</p><p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p><p>判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p><p>那么问题来了，<strong>系统是怎么预测判断的呢？</strong></p><p>居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p><p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p><blockquote><p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p></blockquote><p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> c &lt; <span class="number">100</span> <span class="keyword">and</span> c &lt; <span class="number">100000</span>;</span><br></pre></td></tr></table></figure></div><p>我们也可以通过</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure></div><p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> t;</span><br></pre></td></tr></table></figure></div><p>来重新统计分析。</p><p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p><h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><p><strong>•连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p><p>•<strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</p><p>•<strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p><p>•<strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p><p>•<strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</p><p><img alt="image-20200527193005072" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf78hg9f9yj30mw0pztdv.jpg" class="lazyload"></p><h2 id="MySQL高性能优化建议"><a href="#MySQL高性能优化建议" class="headerlink" title="MySQL高性能优化建议"></a>MySQL高性能优化建议</h2><hr><h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><h4 id="所有表必须使用-Innodb-存储引擎"><a href="#所有表必须使用-Innodb-存储引擎" class="headerlink" title="所有表必须使用 Innodb 存储引擎"></a>所有表必须使用 Innodb 存储引擎</h4><p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。</p><p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p><h4 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="数据库和表的字符集统一使用 UTF8"></a>数据库和表的字符集统一使用 UTF8</h4><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><h4 id="尽量控制单表数据量的大小-建议控制在-500-万以内。"><a href="#尽量控制单表数据量的大小-建议控制在-500-万以内。" class="headerlink" title="尽量控制单表数据量的大小,建议控制在 500 万以内。"></a>尽量控制单表数据量的大小,建议控制在 500 万以内。</h4><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h4 id="禁止从开发环境-测试环境直接连接生成环境数据库"><a href="#禁止从开发环境-测试环境直接连接生成环境数据库" class="headerlink" title="禁止从开发环境,测试环境直接连接生成环境数据库"></a>禁止从开发环境,测试环境直接连接生成环境数据库</h4><hr><h3 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h3><h4 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h4><p><strong>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></p><p>MySQL 提供了两个方法来处理 ip 地址</p><p>•inet_aton 把 ip 转为无符号整型 (4-8 位)•inet_ntoa 把整型的 ip 转为地址</p><p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p><p><strong>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</strong></p><p><strong>原因：</strong></p><p>无符号相对于有符号可以多出一倍的存储空间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIGNED INT -2147483648~2147483647UNSIGNED INT 0~429496729</span><br></pre></td></tr></table></figure></div><h4 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="尽可能把所有列定义为 NOT NULL"></a>尽可能把所有列定义为 NOT NULL</h4><p><strong>原因：</strong></p><p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p><p>进行比较和计算时要对 NULL 值做特别的处理</p><h3 id="6-同财务相关的金额类数据必须使用-decimal-类型"><a href="#6-同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="6. 同财务相关的金额类数据必须使用 decimal 类型"></a>6. 同财务相关的金额类数据必须使用 decimal 类型</h3><p>•非精准浮点：float,double</p><p>•精准浮点：decimal</p><p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p><p>可用于存储比 bigint 更大的整型数据</p><hr><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><h4 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><h4 id="每个Innodb表必须有个主键"><a href="#每个Innodb表必须有个主键" class="headerlink" title="每个Innodb表必须有个主键"></a>每个Innodb表必须有个主键</h4><p><strong>Innodb</strong> 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p><strong>Innodb</strong> 是按照主键索引的顺序来组织表的</p><p>•不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</p><p>•不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</p><p>•主键建议使用自增 ID 值</p><hr><h4 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h4><p>1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 </p><p>2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式 。</p><hr><h4 id="避免建立冗余索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引（增加了查询优化器生成执行计划的时间）</h4><p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><hr><h4 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h4><p><strong>尽量避免使用外键约束</strong></p><p>•不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引•外键可用于保证数据的参照完整性，但建议在业务端实现•外键会影响父表和子表的写操作从而降低性能</p><hr><h3 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h3><h4 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h4><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong></p><p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h4 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h4><p>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL•MySQL 中，一个 SQL 只能使用一个 CPU 进行计算•SQL 拆分后可以通过并行执行来提高处理效率</p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard.md" target="_blank" rel="noopener">为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？你们具体是如何对数据库如何进行垂直拆分或水平拆分的？</a></li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-method.md" target="_blank" rel="noopener">现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？</a></li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-dynamic-expand.md" target="_blank" rel="noopener">如何设计可以动态扩容缩容的分库分表方案？</a></li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-global-id-generate.md" target="_blank" rel="noopener">分库分表之后，id 主键如何处理？</a></li></ul><h2 id="binlog主从同步（主从不一致问题解决）"><a href="#binlog主从同步（主从不一致问题解决）" class="headerlink" title="binlog主从同步（主从不一致问题解决）"></a>binlog主从同步（主从不一致问题解决）</h2><h3 id="mysql复制的类型"><a href="#mysql复制的类型" class="headerlink" title="mysql复制的类型"></a>mysql复制的类型</h3><p>1.基于语句的复制 ：主库把sql语句写入到bin log中，完成复制<br> 2.基于行数据的复制：主库把每一行数据变化的信息作为事件，写入到bin log，完成复制<br> 3.混合复制：上面两个结合体，默认用语句复制，出问题时候自动切换成行数据复制</p><h3 id="主从复制工作原理剖析"><a href="#主从复制工作原理剖析" class="headerlink" title="主从复制工作原理剖析"></a>主从复制工作原理剖析</h3><p>1、Master 数据库只要发生变化，立马记录到Binary log 日志文件中<br>2、Slave数据库启动一个I/O thread连接Master数据库，请求Master变化的二进制日志<br>3、Slave I/O获取到的二进制日志，保存到自己的Relay log 日志文件中。<br>4、Slave 有一个 SQL 线程定时检查Realy log是否变化，变化那么就更新数据。</p><p><img alt="image-20200811095721600" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghmn10h564j30sg0k0dos.jpg" class="lazyload"></p><h3 id="主从复制延迟原因"><a href="#主从复制延迟原因" class="headerlink" title="主从复制延迟原因"></a>主从复制延迟原因</h3><p>从库从主库通过的过程是串行化的（写binlog、读取到relaylog），所以会有一定的延迟，为<code>主从延迟</code>。经验来说，主库写并发为1000，从库延迟为几毫秒，写并发为2000，从库延迟为几十毫秒，写并发为6000-8000，从库延迟为几秒，此时主库快崩溃了。</p><h3 id="主从复制数据丢失问题，半同步复制"><a href="#主从复制数据丢失问题，半同步复制" class="headerlink" title="主从复制数据丢失问题，半同步复制"></a>主从复制数据丢失问题，半同步复制</h3><p><code>半同步复制</code>防止主数据库down了造成数据丢失，至少一个从库写入到relaylog日志里，主库才会认为写入成功了。</p><h3 id="缓解主从复制延迟问题"><a href="#缓解主从复制延迟问题" class="headerlink" title="缓解主从复制延迟问题"></a>缓解主从复制延迟问题</h3><p><code>问题现象：</code></p><p>插入一条数据，查出这条数据，更新这条数据。高峰期每秒2000多写并发，造成从库没查到。</p><p><code>解决：</code></p><p>1、写relayLog日志需多个线程。</p><p>2、<code>并行复制</code>mysql5.7可开启多个sql线程从relay日志去读取，缓解主从延迟问题。</p><p>3、将一个主库拆分为多个主库，降低主库的写并发。</p><p>4、可以将核心业务的查操作直连主库，但是不太建议这点，违背了读写分离的初衷。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 削峰实战！</title>
      <link href="/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ%E5%89%8A%E5%B3%B0%E5%AE%9E%E6%88%98/"/>
      <url>/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ%E5%89%8A%E5%B3%B0%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>MQ的主要特点为<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>，该文章主要记录与分享个人在实际项目中的RocketMQ<strong>削峰</strong>用法，用于减少数据库压力的业务场景，其中RocketMQ的核心组件概念如下：</p><ul><li><p>Producer：生产发送消息</p></li><li><p>Broker：存储Producer发送过来的消息</p></li><li><p>Consumer：从Broker拉取消息并进行消费</p></li><li><p>NameServer：为Producer或Consumer路由到Broker</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/N34tfh8WYkgiaf7EfnAEIBUr0BVSJF73iaa28IgRegPO4meKtDOEP6XfYOm14dIrdFicRlMEiaK06Sh0jV8PBQDPibg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p></li></ul><p>其中消费流程有以下几点是必须注意的：</p><ul><li>RocketMQ的Consumer获取消息是通过向Broker发送拉取请求获取的，而不是由Broker发送Consumer接收的方式。</li><li>Consumer每次拉取消息时消息都会被均匀分发到消息队列再进行传输，所以RocketMQ中的很多参数都是针对队列而不是Topic的(这个是重点，顺便吐槽下源码的文档讲的真不清晰，很多都需要自己试错，但Dashboard做得很好)，其中每个Broker消息队列(ConsumeQueue)的数量都可以通过RocketMQ DashBoard实时更改调整。</li></ul><h2 id="rocketmq-spring-boot-starter用法简介"><a href="#rocketmq-spring-boot-starter用法简介" class="headerlink" title="rocketmq-spring-boot-starter用法简介"></a>rocketmq-spring-boot-starter用法简介</h2><p>当开发中需要快速集成RocketMQ时可以考虑使用 rocketmq-spring-boot-starter 搭建RocketMQ的集成环境，但该框架并不完全具备RocketMQ所有的配置简化，如需批量消费消息便需要自定义一个DefaultMQPushConsumer bean去消费了。个人在开发中常用的<code>rocketmq-spring-boot-starter</code>相关类：</p><ul><li><p><code>RocketMQListener</code>接口：消费者都需实现该接口的消费方法<code>onMessage(msg)</code>。</p></li><li><p><code>RocketMQPushConsumerLifecycleListener</code>接口：当<code>@RocketMQMessageListener</code>中的配置不足以满足我们的需求时，可以实现该接口直接更改消费者类<code>DefaultMQPushConsumer</code>配置</p></li><li><p><code>@RocketMQMessageListener</code>：被该注解标注并实现了接口<code>RocketMQListener</code>的bean为一个消费者并监听指定topic队列中的消息，该注解中包含消费者的一些常用配置(大部分按默认即可)，一般只需更改consumerGroup(消费组)与topic。<code>RocketMQMessageListener</code>中的属性配置是可以使用Placeholder(占位符)从配置文件或配置中心获取的，如下图：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/N34tfh8WYkgiaf7EfnAEIBUr0BVSJF73iavViajAjibzPDib8ppJIIicG4ONyeP67VFgjpjukPHiaPChm1zHT5syCV5icQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p></li></ul><h2 id="业务案例"><a href="#业务案例" class="headerlink" title="业务案例"></a>业务案例</h2><p>有一个点赞业务，不限制用户的点赞数只需进行记录(产品需求，开发提议无效)，当每个用户都进行x连击享受数量猛增的快感时如果数据库都需要进行x个点赞数据的插入，数据库毫无疑问会塞死导致崩溃。于是想到可以尝试下MQ削峰，比如每秒来了5000消息但数据库只能承受2000，那我消费时每次只拉取消费1600就好了，剩下的放在Broker堆积慢慢消费就好。由于之前的消息中心也在用RocketMQ，于是确认使用RocketMQ来进行削峰。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/N34tfh8WYkgiaf7EfnAEIBUr0BVSJF73ia32Z6gAzObiar941SWfEDBjFq3j9Qibq8ZDkIibt5DIJuibt1rpmSPuz9mQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><blockquote><p>文章例子环境：1NameServer + 2Broker + 1Consumer</p></blockquote><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></div><h3 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">properties</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rocketmq</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">name-server</span>: <span class="string">127.0.0.1:9876</span></span><br><span class="line">  <span class="attr">producer</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">group</span>: <span class="string">praise-group</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">10000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">root</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">tiger</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/wilson</span></span><br><span class="line"><span class="attr">swagger</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">docket</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">base-package</span>: <span class="string">io.rocket.consumer.controller</span></span><br><span class="line"><span class="attr">复制代码</span></span><br></pre></td></tr></table></figure></div><h2 id="点赞接口"><a href="#点赞接口" class="headerlink" title="点赞接口"></a>点赞接口</h2><p><strong>PraiseRecord(点赞记录):</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PraiseRecord</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> Long liveId;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></div><p><strong>MessageController(简单的测试接口):</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/message"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/praise"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">praise</span><span class="params">(@RequestBody PraiseRecordVO vo)</span> </span>&#123;</span><br><span class="line">        rocketMQTemplate.sendOneWay(RocketConstant.Topic.PRAISE_TOPIC, MessageBuilder.withPayload(vo).build());</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></div><p>由于用户可以连续点赞，所以考虑可以在点赞消息的处理上宽松一点(容许消息丢失)以追求更高的性能，因此选择使用<code>sendOneyWay()</code>进行消息发送。</p><blockquote><p>RocketMQ的消息发送方式主要含syncSend()同步发送、asyncSend()异步发送、sendOneWay()三种方式，sendOneWay()也是异步发送，区别在于不需等待Broker返回确认，所以可能会存在信息丢失的状况，但吞吐量更高，具体需根据业务情况选用。</p><p>性能：sendOneWay &gt; asyncSend &gt; syncSend RocketMQTemplate的send()方法默认是同步(syncSend)的,更多可看源码实现。</p></blockquote><h2 id="PraiseListener：点赞消息消费者"><a href="#PraiseListener：点赞消息消费者" class="headerlink" title="PraiseListener：点赞消息消费者"></a>PraiseListener：点赞消息消费者</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = RocketConstant.Topic.PRAISE_TOPIC, consumerGroup = RocketConstant.ConsumerGroup.PRAISE_CONSUMER)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PraiseListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">PraiseRecordVO</span>&gt;, <span class="title">RocketMQPushConsumerLifecycleListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PraiseRecordService praiseRecordService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(PraiseRecordVO vo)</span> </span>&#123;</span><br><span class="line">        praiseRecordService.insert(vo.copyProperties(PraiseRecord::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareStart</span><span class="params">(DefaultMQPushConsumer consumer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次拉取的间隔，单位为毫秒</span></span><br><span class="line">        consumer.setPullInterval(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 设置每次从队列中拉取的消息数为16</span></span><br><span class="line">        consumer.setPullBatchSize(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>单次pull消息的最大数目受broker存储的<code>MessageStoreConfig.maxTransferCountOnMessageInMemory</code>(默认为32)值限制，即若想要消费者从队列拉取的消息数大于32有效(pullBatchSize&gt;32)则需更改Broker的启动参数<code>maxTransferCountOnMessageInMemory</code>值。在MQ削峰的配置参数里，以下几个<code>DefaultMQPushConsumer</code>的参数是需要注意一下的：</p><ul><li><code>pullInterval</code>：每次从Broker拉取消息的间隔，单位为毫秒</li><li><code>pullBatchSize</code>：每次从Broker队列拉取到的消息数，该参数很容易让人误解，一开始我以为是每次拉取的消息总数，但测试过几次后确认了实质上是从每个队列的拉取数(源码上的注释文档真的很差，跟没有一样)，即Consume每次拉取的消息总数如下：<code>EachPullTotal=所有Broker上的写队列数和(writeQueueNums=readQueueNums) * pullBatchSize</code></li><li><code>consumeMessageBatchMaxSize</code>：每次消费(即将多条消息合并为List消费)的最大消息数目，默认值为1，rocketmq-spring-boot-starter 目前不支持批量消费(2.1.0版本)</li></ul><p>在消费者开始消息消费时会先从各队列中拉取一条消息进行消费，消费成功后再以每次pullBatchSize的数目进行拉取。</p><p>PraiseListener中设置了每次拉取的间隔为2s，每次从队列拉取的消息数为16，在搭建了2master broker且broker上writeQueueNums=readQueueNums=4的环境下每次拉取的消息理论数值为16 * 2 * 4 = 128，在第一次从各队列拉取1条消息(即共8条)后消费成功后会每次就会拉取最多128条消息进行消费，想验证下的可以把onMessage()的insert()改为log.info(“1”)然后统计单位秒内打印的日志数是否为128。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/N34tfh8WYkgiaf7EfnAEIBUr0BVSJF73iawLe4M03xcD1uRveATZrh7wRYLhFLjk1dicK6QKrydpaj8ZM8s5U1wEg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>根据以上配置单Conumer情况下每2s理论消费为128，即每2秒数据库新增的点赞数据大概为128条左右，有20%偏差都在个人可接受范围内，然后对点赞接口进行简单压测1s 2000请求校验MQ效果，根据消费配置理论上需要16次拉取即需32s才能消费完，压测后查看数据库校验效果：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/N34tfh8WYkgiaf7EfnAEIBUr0BVSJF73iau94rVMpJHMZrNmR9jtmzOqQx0aFTTSkPfiaNzOP3MQmVvELIg3ZZayg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/N34tfh8WYkgiaf7EfnAEIBUr0BVSJF73iatHQtHJyBNdYjD46XwkrKquSdumLt8dQSDtTgUBMEyI1mItiay2jPPlA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>由上图可以看出除第一次2s和最后一次2s外数据库每2s的插入数据数和一般都在128附近波动，也用了34s(因第一次拉取数较少所以比理论多花费一次拉取)消费的偏差大小可能会受每次拉取数pullBatchSize、Broker上的消息队列数、网络波动等情况影响，但需要的目的已经达到了，我只想把单位时间内过多的数据库操作交给MQ做分隔成多个单位时间内的小批量操作，消息过多就堆积，当请求峰值过了后直到MQ堆积的消息消费完前数据库的插入数依旧会与峰值期的插入数相差不大，达到了MQ削峰填谷的效果。</p><h3 id="上线了但消费效率预估失误如何动态更改消费效率-？"><a href="#上线了但消费效率预估失误如何动态更改消费效率-？" class="headerlink" title="上线了但消费效率预估失误如何动态更改消费效率 ？"></a>上线了但消费效率预估失误如何动态更改消费效率 ？</h3><p>当把拉取数pullBatchSize设置Broker的默认最大传输值32了，线上又不想重启Broker更改maxTransferCountOnMessageInMemory参数，如有2个Broker且queue都为4，那么拉取消费效率才为32 * 2 * 4 = 256，如果想要动态调整，可以从Broker数或Broker队列数下手，可以将Broker的writeQueueNums、readQueueNums增大，如都改为8，那么效率就成了32 * 2 * 8 = 512。</p><p>需要注意的是更改完queues后必须去Dashboard的Topic下的CONSUMER MANAGER查看新增的队列上是否都有Consumer成功注册上去了，因为遇到了在测试与生产上使用rocketmq-spring-boot-starter @RocketMQListener标注消费者不会自动注册到新队列上的情况，但没排除是不是RocketMQ版本的原因(个人本地的版本比环境上的高了一个小版本0.0.1，本地没出现没消费者注册到新队列上的问题)，而是使用了自定义DefaultMQPushConsumer bean(原生的方式都是没有问题的)的备用方案。当再启动新的消费者应用时CONSUMER MANAGER(下图)中就会出现 新Consumer数 * 各Broker队列数和的队列行。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/N34tfh8WYkgiaf7EfnAEIBUr0BVSJF73iaET9VzXjeHy4TsnErsUB4wrgaw7OibAPxtz1hHUncu3GMYezWvLRI9Tw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h3 id="如何使用RocketMQ批量消费-？"><a href="#如何使用RocketMQ批量消费-？" class="headerlink" title="如何使用RocketMQ批量消费 ？"></a>如何使用RocketMQ批量消费 ？</h3><p>虽然点赞业务使用MQ单条插入后TPS已经达到当前业务指标要求了，但考虑到如果后续要求在不添加机器数的情况下增加TPS，且数据量还没到分库分表的程度，个人就打算从批量消费下手，由一次插入一条点赞记录改为一次性插入多条(insertBatch)。当然能满足现有需求能不做肯定不做的，过度优化过分碍事，但想多点方案不会坏事。</p><p>rocketmq-spring-boot-starter并没有提供批量消费的功能，所以要批量消费消息需要自定义<code>DefaultMQPushConsumer</code>并配置其<code>consumeMessageBatchMaxSize</code>属性。<code>consumeMessageBatchMaxSize</code>属性默认值为1，即每次只消费一条消息，需要注意的是该属性也会受<code>pullBatchSize</code>影响，如果<code>consumeMessageBatchMaxSize</code>为32但<code>pullBatchSize</code>只为12，那么每次批量消费的最大消息数也就只有12。如下为个人测试批量消费Consumer的测试bean：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DefaultMQPushConsumer userMQPushConsumer() throws MQClientException &#123;</span><br><span class="line">    DefaultMQPushConsumer consumer &#x3D; new DefaultMQPushConsumer(RocketConstant.ConsumerGroup.SPRING_BOOT_USER_CONSUMER);</span><br><span class="line">    consumer.setNamesrvAddr(nameServer);</span><br><span class="line">    consumer.subscribe(RocketConstant.Topic.SPRING_BOOT_USER_TOPIC, &quot;*&quot;);</span><br><span class="line">    &#x2F;&#x2F; 设置每次消息拉取的时间间隔，单位毫秒</span><br><span class="line">    consumer.setPullInterval(1000);</span><br><span class="line">    &#x2F;&#x2F; 设置每个队列每次拉取的最大消息数</span><br><span class="line">    consumer.setPullBatchSize(24);</span><br><span class="line">    &#x2F;&#x2F; 设置消费者单次批量消费的消息数目上限</span><br><span class="line">    consumer.setConsumeMessageBatchMaxSize(12);</span><br><span class="line">    consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context)</span><br><span class="line">            -&gt; &#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfos &#x3D; new ArrayList&lt;&gt;(msgs.size());</span><br><span class="line">        Map&lt;Integer, Integer&gt; queueMsgMap &#x3D; new HashMap&lt;&gt;(8);</span><br><span class="line">        msgs.forEach(msg -&gt; &#123;</span><br><span class="line">            userInfos.add(JSONObject.parseObject(msg.getBody(), UserInfo.class));</span><br><span class="line">            queueMsgMap.compute(msg.getQueueId(), (key, val) -&gt; val &#x3D;&#x3D; null ? 1 : ++val);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(&quot;userInfo size: &#123;&#125;, content: &#123;&#125;&quot;, userInfos.size(), userInfos);</span><br><span class="line">        &#x2F;*</span><br><span class="line">          处理批量消息，如批量插入：userInfoMapper.insertBatch(userInfos);</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    return consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果默认配置情况下log打印出的userInfo size恒为1，但由于设置了<code>consumeMessageBatchMaxSize</code>与<code>pullBatchSize</code>，且<code>pullBatchSize</code>较小，所以每次消费的消息数最大值为12，如下图：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz/N34tfh8WYkgiaf7EfnAEIBUr0BVSJF73iaRwnskMlQlgN22rjUQfwibpJI59WAXL8HiavSqSXAx5hRVMIGRWRGQUYw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h1 id="附本文相关信息"><a href="#附本文相关信息" class="headerlink" title="附本文相关信息"></a>附本文相关信息</h1><ul><li><p>确保mqnamesrv与mqbroker已启动成功，如该文章环境的启动：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mqnamesrv -n 127.0.0.1:9876</span><br><span class="line">mqbroker -c E:\RocketMQ\rocketmq-all-4.5.2-bin-release\bin\2m-noslave\broker-a.properties</span><br><span class="line">mqbroker -c E:\RocketMQ\rocketmq-all-4.5.2-bin-release\bin\2m-noslave\broker-b.properties</span><br></pre></td></tr></table></figure></div></li><li><p>RocketMQ DashBoard启动流程可参考官方github文档或到我的资源里下载jar包运行</p></li><li><p>源码地址（<a href="https://github.com/Wilson-He/spring-boot-series/tree/master/spring-rocketmq），2m-noslave目录是该文章中例子中的2master" target="_blank" rel="noopener">https://github.com/Wilson-He/spring-boot-series/tree/master/spring-rocketmq），2m-noslave目录是该文章中例子中的2master</a> broker配置与启动脚本，spring-boot-consumer-peak目录为包含该文章相关代码的实际例子</p></li></ul><p><strong>END</strong></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要用单例模式-手写几种线程安全的单例模式"><a href="#为什么要用单例模式-手写几种线程安全的单例模式" class="headerlink" title="为什么要用单例模式?手写几种线程安全的单例模式?"></a>为什么要用单例模式?手写几种线程安全的单例模式?</h2><p><strong>简单来说使用单例模式可以带来下面几个好处:</strong></p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p><strong>单例模式有多种实现方式，但是，有三个相同的特点：</strong></p><ul><li>构造器私有；</li><li>含持有自己类型的属性；</li><li>对外提供获取实例的静态方法；</li></ul><p><strong>懒汉式(双重检查加锁版本)</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过将instance声明为volatile型来防止new Instance()的重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查实例，如果不存在，就进入同步代码块</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只有第一次才彻底执行这里的代码</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">               <span class="comment">//进入同步代码块后，再检查一次，如果仍是null，才创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>静态内部类方式</strong></p><p>静态内部实现的单例是懒加载的且线程安全。</p><p>只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>[exocr@iz8vb85pir06gf268taw08z bin]$ ./zkServer.sh start<br>JMX enabled by default<br>Using config: /home/exocr/zookeeper-3.4.6/bin/../conf/zoo.cfg<br>Starting zookeeper … /bin/echo: 写入错误: 设备上没有空间<br>FAILED TO WRITE PID</p><p>&gt; zookeeper.out</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据处理</title>
      <link href="/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="重要思想"><a href="#重要思想" class="headerlink" title="重要思想"></a>重要思想</h2><p>1、分治法，hash运算将有相同特征的值放到同一个文件中</p><p>2、bitMap位图法，求解数据重复问题</p><p>3、使用堆排序，解决topN问题，PriorityQueue是堆实现的</p><p>4、HashMap统计有限key的value次数，HashSet去重</p><h2 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h2><p>1 <strong>GB</strong> ≈ 10^3^ <strong>MB</strong> ≈ 10^6^ <strong>KB</strong> ≈ 10^9^ <strong>字节</strong> ≈ 8<em>10^9^ *</em>Bit**</p><p>1个bit存储一个数字</p><p>40亿个数 40<em>10^8^÷8\</em>10^9^=5G</p><h2 id="如何从大量的-URL-中找出相同的-URL？"><a href="#如何从大量的-URL-中找出相同的-URL？" class="headerlink" title="如何从大量的 URL 中找出相同的 URL？"></a>如何从大量的 URL 中找出相同的 URL？</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p><blockquote><p>5, 000, 000, 000 * 64B ≈ 5GB * 64 = 320GB</p></blockquote><p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p><strong>思路如下</strong>：</p><p>==特点：通过hash运算将有相同特征的值放到同一个文件中==</p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code> ，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p><p>接着遍历 ai( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>对每个子文件进行 HashSet 统计。</li></ol><hr><h2 id="如何从大量数据中找出高频词？"><a href="#如何从大量数据中找出高频词？" class="headerlink" title="如何从大量数据中找出高频词？"></a>如何从大量数据中找出高频词？</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h3 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h3><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>思路如下</strong>：</p><p>==特点：通过hash运算将有相同特征的值放到同一个文件中==</p><p>首先遍历大文件，对遍历到的每个词x，执行 <code>hash(x) % 5000</code> ，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code> ；若存在，则执行 <code>map.put(x, map.get(x)+1)</code> ，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><p>PriorityQueue底层由小顶堆实现，通过重写compare转变成大顶堆。</p><h3 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>使用 HashMap 统计频数；</li><li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li></ol><hr><h2 id="如何找出某一天访问百度网站最多的-IP？"><a href="#如何找出某一天访问百度网站最多的-IP？" class="headerlink" title="如何找出某一天访问百度网站最多的 IP？"></a>如何找出某一天访问百度网站最多的 IP？</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p><h3 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h3><p>==特点：通过hash运算将有相同特征的值放到同一个文件中==</p><p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p><blockquote><p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p></blockquote><h3 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h3><ol><li>分而治之，进行哈希取余；</li><li>使用 HashMap 统计频数；</li><li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li></ol><hr><h2 id="如何在大量的数据中找出不重复的整数？"><a href="#如何在大量的数据中找出不重复的整数？" class="headerlink" title="如何在大量的数据中找出不重复的整数？"></a>如何在大量的数据中找出不重复的整数？</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p><h3 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p><h4 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p><p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p><p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure></div><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 1 0 1 0</span><br></pre></td></tr></table></figure></div><p>依次遍历，结束后，位数组是这样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 0 1 1 1 0</span><br></pre></td></tr></table></figure></div><p>每个为 1 的位，它的下标都表示了一个数：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in range(8):</span><br><span class="line">    if bits[i] &#x3D;&#x3D; 1:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure></div><p>这样我们其实就已经实现了排序。</p><p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。</p><p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p><ul><li>00 表示这个数字没出现过；</li><li>01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li><li>10 表示这个数字出现了多次。</li></ul><p>那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p><p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p><h3 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><hr><h2 id="如何在大量数据中判断一个数是否存在？"><a href="#如何在大量数据中判断一个数是否存在？" class="headerlink" title="如何在大量数据中判断一个数是否存在？"></a>如何在大量数据中判断一个数是否存在？</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p><h3 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p><h4 id="方法二：位图法-1"><a href="#方法二：位图法-1" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4, 000, 000, 000b≈512M。</p><p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p><h3 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否存在、判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p><hr><h2 id="如何查询最热门的查询串？"><a href="#如何查询最热门的查询串？" class="headerlink" title="如何查询最热门的查询串？"></a>如何查询最热门的查询串？</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过 255 字节。</p><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><h3 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p><h4 id="方法一：分治法-2"><a href="#方法一：分治法-2" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>分治法依然是一个非常实用的方法。</p><p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p><p>方法可行，但不是最好，下面介绍其他方法。</p><h4 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h4><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。</p><p><strong>思路如下</strong>：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code> 。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code> 。</p><h4 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h4><p>方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p><strong>思路如下</strong>：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p><h3 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h3><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p><hr><h2 id="如何统计不同电话号码的个数？"><a href="#如何统计不同电话号码的个数？" class="headerlink" title="如何统计不同电话号码的个数？"></a>如何统计不同电话号码的个数？</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p><h3 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h3><p>这道题本质还是求解<strong>数据重复</strong>的问题，对于这类问题，一般首先考虑位图法。</p><p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p><p><strong>思路如下</strong>：</p><p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p><h3 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h3><p>求解数据重复问题，记得考虑位图法。</p><h2 id="如何按照-query-的频度排序？"><a href="#如何按照-query-的频度排序？" class="headerlink" title="如何按照 query 的频度排序？"></a>如何按照 query 的频度排序？</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p><h3 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h3><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p><h4 id="方法一：HashMap-法"><a href="#方法一：HashMap-法" class="headerlink" title="方法一：HashMap 法"></a>方法一：HashMap 法</h4><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。</p><h4 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h4><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 <code>hash(query) % 10</code> 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p><p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p><h3 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h3><ul><li>内存若够，直接读入进行排序；</li><li>内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li></ul><h2 id="如何从-5-亿个数中找出中位数？"><a href="#如何从-5-亿个数中找出中位数？" class="headerlink" title="如何从 5 亿个数中找出中位数？"></a>如何从 5 亿个数中找出中位数？</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 <code>(N+1)/2</code> 个数；当样本数为偶数时，中位数为 第 <code>N/2</code> 个数与第 <code>1+N/2</code> 个数的均值。</p><h3 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h3><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 <code>O(NlogN)</code> 。这里使用其他方法。</p><h4 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h4><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p><p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class MedianFinder &#123;</span><br><span class="line">    </span><br><span class="line">    private PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line"></span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    public MedianFinder() &#123;</span><br><span class="line">        maxHeap &#x3D; new PriorityQueue&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">        minHeap &#x3D; new PriorityQueue&lt;&gt;(Integer::compareTo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addNum(int num) &#123;</span><br><span class="line">        if (maxHeap.isEmpty() || maxHeap.peek() &gt; num) &#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int size1 &#x3D; maxHeap.size();</span><br><span class="line">        int size2 &#x3D; minHeap.size();</span><br><span class="line">        if (size1 - size2 &gt; 1) &#123;</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        &#125; else if (size2 - size1 &gt; 1) &#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double findMedian() &#123;</span><br><span class="line">        int size1 &#x3D; maxHeap.size();</span><br><span class="line">        int size2 &#x3D; minHeap.size();</span><br><span class="line">        </span><br><span class="line">        return size1 &#x3D;&#x3D; size2 </span><br><span class="line">            ? (maxHeap.peek() + minHeap.peek()) * 1.0 &#x2F; 2</span><br><span class="line">            : (size1 &gt; size2 ? maxHeap.peek() : minHeap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>见 LeetCode No.295：<a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">https://leetcode.com/problems/find-median-from-data-stream/</a></p></blockquote><p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法<strong>适用于数据量较小的情况</strong>。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p><h4 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h4><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p><p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p><p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p><blockquote><p><strong>提示</strong>，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。</p></blockquote><p>对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p><blockquote><p><strong>注意</strong>，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p></blockquote><h3 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h3><p>分治法，真香！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略设计入门</title>
      <link href="/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
      <url>/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p> 在前面中对策略模式应该有了一个最初步的认识。那么什么是策略模式呢？所谓策略模式就是定义了算法族，分别封装起来，让他们之前可以互相转换，此模式然该算法的变化独立于使用算法的客户。</p><p> 在软件系统中有很多种方法可以实现同一个功能，比如排序算法它有冒泡排序、选择排序、快速排序、插入排序等等。这里我们有一种硬编码方法，就是讲所以的排序算法全部写在一个类中，每一种算法的具体实现对应着一个方法，然后写一个总方法通过if…else…来判断选择具体的排序算法，但是这样做存在几个问题。</p><p> 第一：如果需要增加新的算法，则需要修改源代码。</p><p> 第二：如果更新了排序算法，那么需要在客户端也需要修改代码，麻烦。</p><p> 第三：充斥着大量的if…else…语句，代码维护比较困难。</p><p> 所以为了解决这些问题，我们可以定义一些独立的类来封装不同的算法，每一个独立的类对应着一个具体的算法实现，在这里我们就将这里每一个独立的类称之为一个策略。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p> 下图为策略模式的结构：</p><p><img alt="1111" data-src="http://static.iocoder.cn/2f52bd2dbe0d666260e08f76cbb9d1f7" class="lazyload"></p><p> 这个UML图与状态模式的几乎一模一样，状态模式是通过改变对象内部的状态来帮助对象控制自己的行为，我们可以这样理解状态模式其实是对状态进行封装，它是将动作动作的实现和责任进行分割，把动作委托到代表当前状态的对象。而策略模式是对算法进行封装，把算法的责任和算法本身进行分割开来，同时委派给不同的对象进行管理。策略模式是将一个系列的算法封装到一系列的策略里面。</p><p> 其实对于算法的选择，策略模式并不关心，它只是对算法进行封装，至于算法什么时候什么地方使用什么算法都是客户所决定的，这样就提高了系统的灵活性，但同时也增加了客户的负担，因为客户需要清楚知道选择什么样的算法对自己最有利，这就需要客户对每一个算法都清楚知道他们的区别。</p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p> 我们都知道排序算法有很多种，但是什么时候选择冒泡排序，什么时候选择选择排序，什么时候选择插入排序，所以这里用排序算法来演示策略模式的实现。 首先我们先来看看在没有使用策略模式的情况。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"type1"</span>.equals(type))&#123;</span><br><span class="line">            <span class="comment">//选择快速排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"type2"</span>.equals(type))&#123;</span><br><span class="line">            <span class="comment">//选择插入排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"type3"</span>.equals(type))&#123;</span><br><span class="line">            <span class="comment">//选择冒泡排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"type4"</span>.equals(type))&#123;</span><br><span class="line">            <span class="comment">//选择选择排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p> 对于这样的代码实现，除了代码中充斥着大量的if…else if…else,导致程序可维护性很差，而且系统的可扩展性不好，如果某个排序模块进行更改了，有可能需要修改源代码。所以在对于这样的情景是非常合适使用策略模式的。</p><p> 那么如何使用策略模式呢？首先我们需要定义一个接口，该接口提供排序算法，然后定义想要的排序算法，实现给接口即可。如下：</p><p><img alt="222" data-src="http://static.iocoder.cn/921d2248385b5cdcecf0d3fc1626cd5f" class="lazyload"></p><h3 id="定义接口类"><a href="#定义接口类" class="headerlink" title="定义接口类"></a>定义接口类</h3><p>首先是Sort接口，该接口定义了排序算法，所有的排序算法都应该实现该接口。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sort</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> arr[]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类"></a>具体实现类</h3><p>然后是三个具体的排序算法，他们实现Sort接口。</p><p> 冒泡排序：BubbleSort.java</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">Sort</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> arr[])&#123;</span><br><span class="line">       <span class="keyword">int</span> len=arr.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">              <span class="keyword">int</span> temp;</span><br><span class="line">              <span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                  temp=arr[j];</span><br><span class="line">                  arr[j]=arr[i];</span><br><span class="line">                  arr[i]=temp;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"冒泡排序"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p> 插入排序：InsertionSort.java</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InsertionSort implements Sort &#123;</span><br><span class="line">    public int[] sort(int arr[]) &#123;</span><br><span class="line">        int len &#x3D; arr.length;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; len; i++) &#123;</span><br><span class="line">            int j;</span><br><span class="line">            int temp &#x3D; arr[i];</span><br><span class="line">            for (j &#x3D; i; j &gt; 0; j--) &#123;</span><br><span class="line">                if (arr[j - 1] &gt; temp) &#123;</span><br><span class="line">                    arr[j] &#x3D; arr[j - 1];</span><br><span class="line"></span><br><span class="line">                &#125; else</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;插入排序&quot;);</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p> 选择排序：SelectSort.java</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionSort implements Sort &#123;</span><br><span class="line">    public int[] sort(int arr[]) &#123;</span><br><span class="line">        int len &#x3D; arr.length;</span><br><span class="line">        int temp;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            temp &#x3D; arr[i];</span><br><span class="line">            int j;</span><br><span class="line">            int samllestLocation &#x3D; i;</span><br><span class="line">            for (j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">                if (arr[j] &lt; temp) &#123;</span><br><span class="line">                    temp &#x3D; arr[j];</span><br><span class="line">                    samllestLocation &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[samllestLocation] &#x3D; arr[i];</span><br><span class="line">            arr[i] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;ѡ������&quot;);</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="定义处理器"><a href="#定义处理器" class="headerlink" title="定义处理器"></a>定义处理器</h3><p>最后就是测试类客户端了Client.java</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sort sortObj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> arr[])</span><br><span class="line">    &#123;</span><br><span class="line">        sortObj.sort(arr);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSortObj</span><span class="params">(Sort sortObj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sortObj = sortObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="调用过程：由处理器根据需要选择具体实现"><a href="#调用过程：由处理器根据需要选择具体实现" class="headerlink" title="调用过程：由处理器根据需要选择具体实现"></a>调用过程：由处理器根据需要选择具体实现</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span> result[];</span><br><span class="line">       ArrayHandler ah=<span class="keyword">new</span> ArrayHandler();</span><br><span class="line"></span><br><span class="line">       Sort sort = <span class="keyword">new</span> SelectionSort();    <span class="comment">//使用选择排序</span></span><br><span class="line"></span><br><span class="line">       ah.setSortObj(sort); <span class="comment">//设置具体策略</span></span><br><span class="line">       result=ah.sort(arr);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.length;i++)</span><br><span class="line">       &#123;</span><br><span class="line">               System.out.print(result[i] + <span class="string">","</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p> 运行结果</p><p> 選擇排序 1,2,3,4,5,6,7,9,10,</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p> 1、策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 2、策略模式提供了可以替换继承关系的办法。</p><p> 3、使用策略模式可以避免使用多重条件转移语句。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p> 1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 2、策略模式将造成产生很多策略类，</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis技术总结</title>
      <link href="/2020/01/15/3.%20redis/redis%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/15/3.%20redis/redis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>网上Java的资料零零散散，甚至有一些错误，作者希望能结合自己的实际开发经验和面试经验，对Redis知识体系进行系统梳理。</p><p>本文参考主要【引用】中的内容，并结合自己的日常积累，欢迎留言交流指正。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><strong>注：本文主要参考</strong></li><li><a href="https://mp.weixin.qq.com/s/vXBFscXqDcXS_VaIERplMQ！" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vXBFscXqDcXS_VaIERplMQ！</a><ul><li><a href="https://github.com/AobingJava/JavaFamily" target="_blank" rel="noopener">https://github.com/AobingJava/JavaFamily</a></li><li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></li></ul></li></ul><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="谈谈你对缓存的理解"><a href="#谈谈你对缓存的理解" class="headerlink" title="谈谈你对缓存的理解"></a>谈谈你对缓存的理解</h3><p><img alt="image-20200526204006874" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf64w2sw7uj30pz0dfwtk.jpg" class="lazyload"></p><h3 id="Redis-优缺点"><a href="#Redis-优缺点" class="headerlink" title="Redis 优缺点"></a>Redis 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>读写性能优异</strong>， Redis能读的速度是 <code>110000</code> 次/s，写的速度是 <code>81000</code> 次/s。</li><li><strong>支持数据持久化</strong>，支持 AOF 和 RDB 两种持久化方式。</li><li><strong>支持事务</strong>，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li><li><strong>数据结构丰富</strong>，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li><li><strong>支持主从复制</strong>，主机会自动将数据同步到从机，可以进行读写分离，多种集群方案。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>数据库 <strong>容量受到物理内存的限制</strong>，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis <strong>不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了 <strong>系统的可用性</strong>。</li><li><strong>Redis 较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h4 id="Redis-和-Memcached-有啥区别，为啥选Redis？"><a href="#Redis-和-Memcached-有啥区别，为啥选Redis？" class="headerlink" title="Redis 和 Memcached 有啥区别，为啥选Redis？"></a>Redis 和 Memcached 有啥区别，为啥选Redis？</h4><ul><li><strong>Redis</strong> 相比 <strong>Memcached</strong> 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， <strong>Redis</strong> 会是不错的选择。</li><li><strong>Redis</strong> 原生支持集群模式，而 <strong>Memcached</strong> 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li><li>性能对比：由于 <strong>Redis</strong> 只使用单核，而 <strong>Memcached</strong> 可以使用多核，所以平均每一个核上 <strong>Redis</strong> 在存储小数据时比 <strong>Memcached</strong> 性能更高。而在 100k 以上的数据中，<strong>Memcached</strong> 性能要高于 <strong>Redis</strong>，虽然 <strong>Redis</strong> 最近也在存储大数据的性能上进行优化，但是比起 <strong>Memcached</strong>，还是稍有逊色。</li></ul><h3 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h3><p>简单总结：</p><ol><li><strong>纯内存操作</strong>：读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；<em>(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)</em></li><li><strong>单线程，无锁竞争</strong>：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；</li><li><strong>多路 I/O 复用模型，非阻塞 I/O</strong>：采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；</li><li><strong>高效的数据结构，加上底层做了大量优化</strong>：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..</li></ol><p><img alt="image-20200512111931582" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepi08qesvj30tv0d3qak.jpg" class="lazyload"></p><p>​    多个Socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h3 id="Redis-有哪些数据结构"><a href="#Redis-有哪些数据结构" class="headerlink" title="Redis 有哪些数据结构"></a>Redis 有哪些数据结构</h3><p><strong>Redis</strong> 可以存储 <strong>键</strong> 和 <strong>不同类型数据结构值</strong> 之间的映射关系。键的类型只能是字符串，而值除了支持最 <strong>基础的五种数据类型</strong> 外，还支持一些 <strong>高级数据类型</strong>：</p><p><img alt="image-20200512155746023" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepq1ryhqzj30i40bvaci.jpg" class="lazyload"></p><blockquote><p>“</p><p>一定要说出一些高级数据结构 <em>(当然你自己也要了解.. 下面会说到的别担心)</em>，这样面试官的眼睛才会亮。</p><p>可重点了解<strong>HyperLogLog</strong>和Pub/Sub</p><p><strong>pub/sub有什么缺点？</strong></p><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<strong>RocketMQ</strong>等。</p></blockquote><h3 id="实际项目缓存应用场景"><a href="#实际项目缓存应用场景" class="headerlink" title="实际项目缓存应用场景"></a>实际项目缓存应用场景</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h4><ul><li>全局订单号</li><li>分布式Session共享（否则从一个页面跳转到另一个页面可能Session就过期了）</li><li>分布式锁</li></ul><h4 id="Hash：相当于嵌套Map"><a href="#Hash：相当于嵌套Map" class="headerlink" title="Hash：相当于嵌套Map"></a><strong>Hash</strong>：相当于嵌套Map</h4><ul><li>存储用户信息、商品信息等</li></ul><p><strong>注意：</strong></p><ul><li>bigkey问题</li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h4><ul><li>微信推送消息列表</li><li>异步任务队列（解决redis数据不一致问题）<ul><li><strong>rpush</strong>生产消息，<strong>lpop</strong>消费消息。当lpop没有消息的时候，要适当sleep一会再重试。另外list还有个指令叫<strong>blpop</strong>，在没有消息的时候，它会阻塞住直到消息到来。</li></ul></li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h4><ul><li>Ip黑名单</li><li>微博关注取交集</li></ul><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a><strong>ZSet</strong></h4><ul><li><p>接口调用用户TopK</p></li><li><p>秒杀实现</p></li></ul><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><ul><li>实现网站所有网页pv<strong>(浏览量，用户没点一次记录一次)</strong>、uv(<strong>同一个用户一天之内的多次访问请求只能计数一次</strong>)统计。</li></ul><p>注⚠️：</p><p>在大量数据的情况下，有一定误差。<strong>HyperLogLog</strong> 提供了两个指令 <code>PFADD</code> 和 <code>PFCOUNT</code>，字面意思就是一个是增加，另一个是获取计数。<code>PFADD</code> 和 <code>set</code> 集合的 <code>SADD</code> 的用法是一样的，来一个用户 ID，就将用户 ID 塞进去就是，<code>PFCOUNT</code> 和 <code>SCARD</code>的用法是一致的，直接获取计数值。</p><h4 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h4><ul><li>查找附近人</li></ul><h3 id="使用缓存会出现什么问题？"><a href="#使用缓存会出现什么问题？" class="headerlink" title="使用缓存会出现什么问题？"></a>使用缓存会出现什么问题？</h3><p>一般来说有如下几个问题，回答思路遵照 <strong>是什么</strong> → <strong>为什么</strong> → <strong>怎么解决</strong>：</p><ol><li>缓存雪崩问题；</li><li>缓存穿透问题；</li><li>缓存和数据库双写一致性问题；</li><li>并发写竞争</li></ol><h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h4><p><img alt="image-20200713092519881" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggp34jy47oj31kz0u0tu6.jpg" class="lazyload"></p><p>对于 <strong>“Redis 挂掉了，请求全部走数据库”</strong> 这样的情况，我们还可以有如下的思路：</p><ul><li><strong>事发前</strong>：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。</li><li><strong>事发中</strong>：万一 Redis 真的挂了，我们可以设置本地缓存(ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li><li><strong>事发后</strong>：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><h4 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h4><p><img alt="image-20200509211822423" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepq38g21tj30ty0fswld.jpg" class="lazyload"></p><p> 布隆过滤器的实现：使用 Google 开源的 Guava 中自带的布隆过滤器，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p><p>参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id &lt;=0的直接拦截等。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>缓存击穿</strong>是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。</p><p><code>解决：</code></p><p>定时任务刷缓存（占用系统资源、10分钟过期、9分钟刷），设置热点数据永远不过期。或者访问数据库时加上互斥锁就能搞定了</p><h4 id="热点Key问题"><a href="#热点Key问题" class="headerlink" title="热点Key问题"></a>热点Key问题</h4><p><a href="https://segmentfault.com/a/1190000019745366?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019745366?utm_source=tag-newest</a></p><h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><p>针对于热点Key的解决方案网上的查找出来无非就是两种</p><ul><li>服务端缓存：即将热点数据缓存至服务端的内存中</li><li>备份热点Key：即将 热点Key + 随机数，随机分配至Redis其他节点中。这样访问热点key的时候就不会全部命中到一台机器上了。（给hot key加上前缀或者后缀，把一个hotkey 的数量变成 redis 实例个数N的倍数M，从而由访问一个 redis key 变成访问 N * M 个redis key）</li></ul><p>其实这两个解决方案前提都是知道了热点Key是什么的情况，那么如何找到热点key呢？</p><h5 id="热点检测"><a href="#热点检测" class="headerlink" title="热点检测"></a>热点检测</h5><ol><li>凭借经验，进行预估：例如提前知道了某个活动的开启，那么就将此Key作为热点Key</li><li>客户端收集：在操作Redis之前对数据进行统计</li><li>抓包进行评估：Redis使用TCP协议与客户端进行通信，通信协议采用的是RESP，所以能进行拦截包进行解析</li><li>在proxy层，对每一个 redis 请求进行收集上报</li><li>Redis自带命令查询：Redis4.0.4版本提供了<code>redis-cli –hotkeys</code>就能找出热点Key</li></ol><h4 id="缓存与数据库双写一致问题"><a href="#缓存与数据库双写一致问题" class="headerlink" title="缓存与数据库双写一致问题"></a>缓存与数据库双写一致问题</h4><h5 id="对于读操作，流程是这样的"><a href="#对于读操作，流程是这样的" class="headerlink" title="对于读操作，流程是这样的"></a>对于读操作，流程是这样的</h5><p>上面讲缓存穿透的时候也提到了：如果从数据库查不到数据则不写入缓存。</p><p>一般我们对<strong>读操作</strong>的时候有这么一个<strong>固定的套路</strong>：</p><ul><li>如果我们的数据在缓存里边有，那么就直接取缓存的。</li><li>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后<strong>将数据库查出来的数据写到缓存中</strong>。</li><li>最后将数据返回给请求</li></ul><p>如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要<strong>更新</strong>时候呢？各种情况很可能就<strong>造成数据库和缓存的数据不一致</strong>了。</p><ul><li>这里不一致指的是：<strong>数据库的数据跟缓存的数据不一致</strong></li></ul><p><img alt="数据库和缓存的数据不一致" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepq3y4879j30n20e70tr.jpg" class="lazyload"></p><p>从理论上说，只要我们设置了<strong>键的过期时间</strong>，我们就能保证缓存和数据库的数据<strong>最终是一致</strong>的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</p><p>除了设置过期时间，我们还需要做更多的措施来<strong>尽量避免</strong>数据库与缓存处于不一致的情况发生。</p><h5 id="对于更新操作"><a href="#对于更新操作" class="headerlink" title="对于更新操作"></a>对于更新操作</h5><p>一般来说，执行更新操作时，我们会有两种选择：</p><ul><li>先操作数据库，再操作缓存</li><li>先操作缓存，再操作数据库</li></ul><p>首先，要明确的是，无论我们选择哪个，我们都希望这<strong>两个操作要么同时成功，要么同时失败</strong>。所以，这会演变成一个<strong>分布式事务</strong>的问题。</p><p>所以，<strong>如果原子性被破坏了</strong>，可能会有以下的情况：</p><ul><li><strong>操作数据库成功了，操作缓存失败了</strong>。</li><li><strong>操作缓存成功了，操作数据库失败了</strong>。</li></ul><blockquote><p>如果第一步已经失败了，我们直接返回Exception出去就好了，第二步根本不会执行。</p></blockquote><p>下面我们具体来分析一下吧。</p><h5 id="操作缓存"><a href="#操作缓存" class="headerlink" title="操作缓存"></a>操作缓存</h5><p>操作缓存也有两种方案：</p><ul><li>更新缓存</li><li>删除缓存</li></ul><p>一般我们都是采取<strong>删除缓存</strong>缓存策略的，原因如下：</p><ol><li>高并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就<strong>更加容易</strong>导致数据库与缓存数据不一致问题。(删除缓存<strong>直接和简单</strong>很多)</li><li>如果每次更新了数据库，都要更新缓存【这里指的是频繁更新的场景，这会耗费一定的性能】，倒不如直接删除掉。等再次读取时，缓存里没有，那我到数据库找，在数据库找到再写到缓存里边(体现<strong>懒加载</strong>)</li></ol><p>基于这两点，对于缓存在更新时而言，都是建议执行<strong>删除</strong>操作！</p><h6 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h6><p>正常的情况是这样的：</p><ul><li>先操作数据库，成功；</li><li>再删除缓存，也成功；</li></ul><p>如果原子性被破坏了：</p><ul><li>第一步成功(操作数据库)，第二步失败(删除缓存)，会导致<strong>数据库里是新数据，而缓存里是旧数据</strong>。</li><li>如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。</li></ul><p>如果在高并发的场景下，出现数据库与缓存数据不一致的<strong>概率特别低</strong>，也不是没有：</p><ul><li>缓存<strong>刚好</strong>失效</li><li>线程A查询数据库，得一个旧值</li><li>线程B将新值写入数据库</li><li>线程B删除缓存</li><li>线程A将查到的旧值写入缓存</li></ul><p>要达成上述情况，还是说一句<strong>概率特别低</strong>：</p><blockquote><p>因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，<strong>而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存</strong>，所有的这些条件都具备的概率基本并不大。</p></blockquote><p>对于这种策略，其实是一种设计模式：<code>Cache Aside Pattern</code></p><p><strong>删除缓存失败的解决思路</strong>：</p><ul><li>将需要删除的key发送到消息队列中</li><li>自己消费消息，获得需要删除的key</li><li><strong>不断重试删除操作，直到成功</strong></li></ul><h6 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h6><p>正常情况是这样的：</p><ul><li>先删除缓存，成功；</li><li>再更新数据库，也成功；</li></ul><p>如果原子性被破坏了：</p><ul><li>第一步成功(删除缓存)，第二步失败(更新数据库)，数据库和缓存的数据还是一致的。</li><li>如果第一步(删除缓存)就失败了，我们可以直接返回错误(Exception)，数据库和缓存的数据还是一致的。</li></ul><p>看起来是很美好，但是我们在并发场景下分析一下，就知道还是有问题的了：</p><ul><li>线程A删除了缓存</li><li>线程B查询，发现缓存已不存在</li><li>线程B去数据库查询得到旧值</li><li>线程B将旧值写入缓存</li><li>线程A将新值写入数据库</li></ul><p>所以也会导致数据库和缓存不一致的问题。</p><p><strong>并发下解决数据库与缓存不一致的思路</strong>：</p><ul><li>将删除缓存、修改数据库、读取缓存等的操作积压到<strong>队列</strong>里边，实现<strong>串行化</strong>。</li></ul><h6 id="对比两种策略"><a href="#对比两种策略" class="headerlink" title="对比两种策略"></a>对比两种策略</h6><p>我们可以发现，两种策略各自有优缺点：</p><ul><li><p>先删除缓存，再更新数据库</p></li><li><ul><li>在高并发下表现不如意，在原子性被破坏时表现优异</li></ul></li><li><p>先更新数据库，再删除缓存(<code>Cache Aside Pattern</code>设计模式)</p></li><li><ul><li>在高并发下表现优异，在原子性被破坏时表现不如意</li></ul></li></ul><h6 id="其他保障数据一致的方案与资料"><a href="#其他保障数据一致的方案与资料" class="headerlink" title="其他保障数据一致的方案与资料"></a>其他保障数据一致的方案与资料</h6><p>可以用<strong>databus</strong>或者阿里的<strong>canal监听binlog</strong>进行更新。</p><p>参考资料：</p><ul><li><p>缓存更新的套路</p></li><li><ul><li><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a></li></ul></li><li><p>如何保证缓存与数据库双写时的数据一致性？</p></li><li><ul><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md</a></li></ul></li><li><p>分布式之数据库和缓存双写一致性方案解析</p></li><li><ul><li><a href="https://zhuanlan.zhihu.com/p/48334686" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48334686</a></li></ul></li><li><p>Cache Aside Pattern</p></li><li><ul><li><a href="https://blog.csdn.net/z50l2o08e2u4aftor9a/article/details/81008933" target="_blank" rel="noopener">https://blog.csdn.net/z50l2o08e2u4aftor9a/article/details/81008933</a></li></ul></li></ul><h4 id="多系统并发操作Redis带来的问题"><a href="#多系统并发操作Redis带来的问题" class="headerlink" title="多系统并发操作Redis带来的问题"></a>多系统并发操作Redis带来的问题</h4><p>嗯嗯这个问题我以前开发的时候遇到过，其实并发过程中确实会有这样的问题，比如下面这样的情况</p><p><a href="https://camo.githubusercontent.com/c8b38486a5e9ceb1986873a609d04e042e08fb89/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303679386d4e366c79316738737a7274306779776a333073653065346161792e6a7067" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/c8b38486a5e9ceb1986873a609d04e042e08fb89/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303679386d4e366c79316738737a7274306779776a333073653065346161792e6a7067" class="lazyload"></a></p><p>系统A、B、C三个系统，分别去操作<strong>Redis</strong>的同一个Key，本来顺序是1，2，3是正常的，但是因为系统A网络突然抖动了一下，B，C在他前面操作了<strong>Redis</strong>，这样数据不就错了么。</p><p>就好比下单，支付，退款三个顺序你变了，你先退款，再下单，再支付，那流程就会失败，那数据不就乱了？你订单还没生成你却支付，退款了？明显走不通了，这在线上是很恐怖的事情。</p><p><code>如何解决呢？</code></p><p>我们可以找个管家帮我们管理好数据的嘛！</p><p><a href="https://camo.githubusercontent.com/e4aca07aad0c7448a19d9678700853b0299fc5a8/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303679386d4e366c793167387430616a79636a796a33307165306a6f7134682e6a7067" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/e4aca07aad0c7448a19d9678700853b0299fc5a8/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303679386d4e366c793167387430616a79636a796a33307165306a6f7134682e6a7067" class="lazyload"></a></p><p>1、某个时刻，多个系统实例都去更新某个 key。可以基于 <strong>Zookeeper</strong> 实现分布式锁。每个系统通过 <strong>Zookeeper</strong> 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 Key，别人都不允许读和写。</p><p>2、你要写入缓存的数据，都是从 <strong>MySQL</strong> 里查出来的，都得写入 <strong>MySQL</strong> 中，写入 <strong>MySQL</strong> 中的时候必须保存一个时间戳，从 <strong>MySQL</strong> 查出来的时候，时间戳也查出来。</p><p>每次要<strong>写之前，先判断</strong>一下当前这个 Value 的时间戳是否比缓存里的 Value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p><h2 id="持久化篇"><a href="#持久化篇" class="headerlink" title="持久化篇"></a>持久化篇</h2><h3 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h3><p><strong>Redis</strong> 的数据 <strong>全部存储</strong> 在 <strong>内存</strong> 中，如果 <strong>突然宕机</strong>，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 <strong>持久化机制</strong>，它会将内存中的数据库状态 <strong>保存到磁盘</strong> 中。</p><p>两者可同时共存，先加载.aof。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。rdb保存的是dump.rdb文件。</li><li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</li></ul><p>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><h4 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h4><ul><li>配置文件中默认的快照配置，冷拷贝后重新使用，可以cp  dump.rdb  dump_new.rdb</li><li>命令save或者是bgsave。</li></ul><p>Save：save时只管保存，其它不管，全部阻塞.</p><p>BGSAVE：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p><p>可以通过lastsave命令获取最后一次成功执行快照的时间.</p><h4 id="如何恢复"><a href="#如何恢复" class="headerlink" title="如何恢复"></a>如何恢复</h4><pre><code>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可CONFIG GET dir获取目录 </code></pre><h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><pre><code>动态所有停止RDB保存规则的方法：redis-cli config set save &quot;&quot;</code></pre><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，</li><li>只许追加文件但不可以改写文件，redis重启根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</li></ul><h4 id="配置使用-1"><a href="#配置使用-1" class="headerlink" title="配置使用"></a>配置使用</h4><ul><li>修改默认的appendonly no，改为yes</li></ul><h4 id="同步频率"><a href="#同步频率" class="headerlink" title="同步频率"></a>同步频率</h4><p>每次修改都同步：appendfsync always  同步操作，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</p><p>每秒同步一次：appendfsync everysec  异步操作，每秒记录如果一秒内宕机，有数据丢失</p><p>不同步：appendfsync no  从不同步</p><h4 id="被写坏的AOF文件修复："><a href="#被写坏的AOF文件修复：" class="headerlink" title="被写坏的AOF文件修复："></a>被写坏的AOF文件修复：</h4><pre><code>redis-check-aof --fix进行修复恢复：重启redis然后重新加载</code></pre><h3 id="RDB与AOF优劣比对："><a href="#RDB与AOF优劣比对：" class="headerlink" title="RDB与AOF优劣比对："></a>RDB与AOF优劣比对：</h3><p>RDB和AOF并不互斥，它俩可以<strong>同时使用</strong>。</p><ul><li>RDB的优点：载入时<strong>恢复数据快</strong>、文件体积小。</li><li>RDB的缺点：会一定程度上<strong>丢失数据</strong>(因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。)</li><li>AOF的优点：丢失数据少(默认配置只丢失一秒的数据)。</li><li>AOF的缺点：恢复数据相对较慢，文件体积大</li></ul><p>如果Redis服务器<strong>同时开启</strong>了RDB和AOF持久化，服务器会<strong>优先使用AOF文件</strong>来还原数据(因为AOF更新频率比RDB更新频率要高，还原的数据更完善)。</p><p>实际生产应redis宕机的话，应使用rdb进行快速恢复，然后使用aof进行补充完整。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>　　分布式锁其实可以理解为：控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性。 举个不太恰当的例子：假设共享的资源就是一个房子，里面有各种书，分布式系统就是要进屋看书的人，分布式锁就是保证这个房子只有一个门并且一次只有一个人可以进，而且门只有一把钥匙。然后许多人要去看书，可以，排队，第一个人拿着钥匙把门打开进屋看书并且把门锁上，然后第二个人没有钥匙，那就等着，等第一个出来，然后你在拿着钥匙进去，然后就是以此类推。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在识别完成后，如识别成功，需要先查出接口当前使用次数，判断一下，然后给接口使用表进行减一操作，统计表进行加一操作。我们知道这个过程在并发条件下是线程不安全的，为了保证线程的安全性在此加了分布式锁。</p><p>单机锁解决单机内存共享变量问题，分布式锁解决多台机器共享变量问题，例如并发扣减库存。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>互斥性<ul><li>保证同一时间只有一个客户端可以拿到锁，也就是可以对共享资源进行操作</li></ul></li><li>安全性<ul><li>只有加锁的服务才能有解锁权限，也就是不能让a加的锁，bcd都可以解锁，如果都能解锁那分布式锁就没啥意义了</li><li>可能出现的情况就是a去查询发现持有锁，就在准备解锁，这时候忽然a持有的锁过期了，然后b去获得锁，因为a锁过期，b拿到锁，这时候a继续执行第二步进行解锁如果不加校验，就将b持有的锁就给删除了</li></ul></li><li>避免死锁</li><li><ul><li>出现死锁就会导致后续的任何服务都拿不到锁,不能再对共享资源进行任何操作了</li></ul></li><li>保证加锁与解锁操作是原子性操作</li><li><ul><li>这个其实属于是实现分布式锁的问题，假设a用redis实现分布式锁</li><li>假设加锁操作，操作步骤分为两步：</li><li>1，设置key set（key，value）2，给key设置过期时间</li></ul></li><li><ul><li>假设现在a刚实现set后，程序崩了就导致了没给key设置过期时间就导致key一直存在就发生了死锁</li></ul></li></ul><h3 id="分布式锁的几种方式"><a href="#分布式锁的几种方式" class="headerlink" title="分布式锁的几种方式"></a>分布式锁的几种方式</h3><p>　　实现分布式锁的方式有很多，只要满足上述条件的都可以实现分布式锁，比如数据库，redis，zookeeper，在这里就先讲一下如何使用redis实现分布式锁</p><h3 id="使用redis实现分布式锁"><a href="#使用redis实现分布式锁" class="headerlink" title="使用redis实现分布式锁"></a>使用redis实现分布式锁</h3><ul><li>使用redis命令 set key value NX EX max-lock-time 实现加锁（同时把setnx和expire合成一条指令来用，否则setnx之后执行expire之前进程意外crash，这个锁就永远得不到释放了。）</li><li>使用redis命令 EVAL 实现解锁</li></ul><h4 id="加锁："><a href="#加锁：" class="headerlink" title="加锁："></a>加锁：</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  * 加锁操作</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 锁标识</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 客户端标识</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeOut 过期时间</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Boolean <span class="title">lock</span><span class="params">(String key,String value,Long timeOut)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">     String var1 = jedis.set(key,value,<span class="string">"NX"</span>,<span class="string">"EX"</span>,timeOut);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(LOCK_SUCCESS.equals(var1))&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>解读：</p><ul><li><p>加锁操作：jedis.set(key,value,”NX”,”EX”,timeOut)【保证加锁的原子操作】</p><p>![image-20200512213852945](/Users/lilei/Library/Application Support/typora-user-images/image-20200512213852945.png)</p></li></ul><hr><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long UNLOCK_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  * 解锁操作</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 锁标识</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 客户端标识</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">unLock</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">     String luaScript = <span class="string">"if redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1]) else  return 0 end"</span>;</span><br><span class="line"> </span><br><span class="line">     Object var2 = jedis.eval(luaScript,Collections.singletonList(key), Collections.singletonList(value));</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (UNLOCK_SUCCESS == var2) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>解读:</p><ul><li>luaScript 这个字符串是个lua脚本，代表的意思是如果根据key拿到的value跟传入的value相同就执行del，否则就返回0【保证安全性】</li><li>jedis.eval(String,list,list);这个命令就是去执行lua脚本，KEYS的集合就是第二个参数，ARGV的集合就是第三参数【保证解锁的原子操作】</li></ul><p>上述就实现了怎么使用redis去正确的实现分布式锁，但是有个小缺陷就是锁过期时间要设置为多少合适，这个其实还是需要去根据业务场景考量一下的</p><hr><h4 id="重试机制："><a href="#重试机制：" class="headerlink" title="重试机制：　　"></a>重试机制：　　</h4><p>上面那只是讲了加锁与解锁的操作，试想一下如果在业务中去拿锁如果没有拿到是应该阻塞着一直等待还是直接返回，这个问题其实可以写一个重试机制，根据重试次数和重试时间做一个循环去拿锁，当然这个重试的次数和时间设多少合适，是需要根据自身业务去衡量的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 重试机制</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 锁标识</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 客户端标识</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeOut 过期时间</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> retry 重试次数</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sleepTime 重试间隔时间</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">lockRetry</span><span class="params">(String key,String value,Long timeOut,Integer retry,Long sleepTime)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    Boolean flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;retry;i++)&#123;</span><br><span class="line"> </span><br><span class="line">            flag = lock(key,value,timeOut);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(sleepTime);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> </span><br><span class="line">        e.printStackTrace();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="进阶分布式锁"><a href="#进阶分布式锁" class="headerlink" title="进阶分布式锁"></a>进阶分布式锁</h3><p>以上实现方式会出现并发竞争，系统异常导致锁未释放，锁过期时间不合理，当前线程锁被其他线程解锁等问题。以下为优化方案：</p><h4 id="stringRedisTemplate实现-自定义逻辑"><a href="#stringRedisTemplate实现-自定义逻辑" class="headerlink" title="stringRedisTemplate实现(自定义逻辑)"></a>stringRedisTemplate实现(自定义逻辑)</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 模拟秒杀场景，利用Redis实现分布式锁（原生实现）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 设置clientId，避免在高并发场景下自己的锁被他人解了</span></span><br><span class="line">    <span class="comment">// 这里可以加上requestId放在value里面，在finally释放锁之前判断一下是不是当前请求的锁</span></span><br><span class="line">      String clientId = UUID.randomUUID().toString();</span><br><span class="line">      String lockKey = <span class="string">"lock"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 加锁</span></span><br><span class="line">          <span class="comment">// 设置过期时间为10s，避免系统异常导致锁无法释放（不安全升级）</span></span><br><span class="line">          Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, clientId, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">          <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//获取当前库存</span></span><br><span class="line">          <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">"stock"</span>)));</span><br><span class="line">          <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">              stringRedisTemplate.opsForValue().set(<span class="string">"stock"</span>, realStock + <span class="string">""</span>);</span><br><span class="line">              System.out.println(<span class="string">"扣减成功，剩余库存"</span> + realStock);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">"库存不足"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          System.out.println(e.getMessage());</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放锁</span></span><br><span class="line">          <span class="keyword">if</span> (clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))) &#123;</span><br><span class="line">              stringRedisTemplate.delete(lockKey);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><h4 id="Redisson实现"><a href="#Redisson实现" class="headerlink" title="Redisson实现"></a>Redisson实现</h4><p>通过 <code>eval</code> 命令来执行 <em>Lua</em> 脚本，保证原子性</p><p>默认30S过期时间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟秒杀场景，利用Redisson实现分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * SpringBoot集成redisson(单机,集群,哨兵)：参考 https://www.jianshu.com/p/2b19dec72ab0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里简单实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String lockKey = <span class="string">"lock"</span>;</span><br><span class="line">        RLock redissonLock = redisson.getLock(lockKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            redissonLock.lock();</span><br><span class="line">            <span class="comment">//获取当前库存</span></span><br><span class="line">            <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">"stock"</span>)));</span><br><span class="line">            <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realStock = stock - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">"stock"</span>, realStock + <span class="string">""</span>);</span><br><span class="line">                System.out.println(<span class="string">"扣减成功，剩余库存"</span> + realStock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"库存不足"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            redissonLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RedisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单机模式</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://172.16.219.215:6379"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="Redisson底层原理"><a href="#Redisson底层原理" class="headerlink" title="Redisson底层原理"></a>Redisson底层原理</h4><p><img alt="image-20200526165243747" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5ybg4v0ej30tq0f8dlu.jpg" class="lazyload"></p><p>基本同自己stringRedisTemplate实现的逻辑，补充：看门锁在原线程中开启一个子线程，定时检测父线程的锁是否还存在，如果存在则进行锁续命。</p><p>加锁和解锁（判断锁存在即删除锁）都通过用lua脚本保证了自己的原子性。</p><h3 id="分布式锁性能优化"><a href="#分布式锁性能优化" class="headerlink" title="分布式锁性能优化"></a>分布式锁性能优化</h3><p>其实说出来也很简单，相信很多人看过java里的<strong>ConcurrentHashMap</strong>的源码和底层原理，应该知道里面的核心思路，就是<strong>分段加锁</strong>！</p><p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改ConcurrentHashMap中的数据。</p><p>另外，Java 8中新增了一个LongAdder类，也是针对Java 7以前的AtomicLong进行的优化，解决的是CAS类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。</p><p>LongAdder中也是采用了类似的分段CAS操作，失败则自动迁移到下一个分段进行CAS的思路。</p><p>其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。</p><p>但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。大家看看下面的图：</p><p><img alt="image-20200526170441392" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5ynus807j30jz0phwmw.jpg" class="lazyload"></p><p>其实这就是分段加锁。你想，假如你现在iphone有1000个库存，那么你完全可以给拆成20个库存段，要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在redis之类的地方放20个库存key。</p><p>总之，就是把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。</p><p>接着，每秒1000个请求过来了，好！此时其实可以是自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。</p><p>bingo！这样就好了，同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存 -&gt; 判断库存是否充足 -&gt; 扣减库存。</p><p>这相当于什么呢？相当于一个20毫秒，可以并发处理掉20个下单请求，那么1秒，也就可以依次处理掉20 * 50  = 1000个对iphone的下单请求了。</p><p>一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：==就是如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了，此时咋办？==</p><p><strong>这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现。</strong></p><h2 id="Redis-3种过期策略？"><a href="#Redis-3种过期策略？" class="headerlink" title="Redis 3种过期策略？"></a>Redis 3种过期策略？</h2><h3 id="3种策略各自的特点"><a href="#3种策略各自的特点" class="headerlink" title="3种策略各自的特点"></a>3种策略各自的特点</h3><ul><li><strong>定时删除</strong><ul><li>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</li><li>优点：保证内存被尽快释放</li><li>缺点：<ul><li>若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</li><li>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</li><li>没人用</li></ul></li></ul></li><li><strong>惰性删除</strong><ul><li>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</li><li>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</li><li>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</li></ul></li><li><strong>定期删除</strong><ul><li>含义：每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作</li><li>优点：<ul><li>通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</li><li>定期删除过期key–处理”惰性删除”的缺点</li></ul></li><li>缺点<ul><li>在内存友好方面，不如”定时删除”</li><li>在CPU时间友好方面，不如”惰性删除”</li></ul></li><li>难点<ul><li>合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）</li></ul></li></ul></li></ul><p>看完上面三种策略后可以得出以下结论：<br>定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key</p><p>惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除</p><p>惰性删除为redis服务器内置策略</p><p>定期删除可以通过：</p><ul><li>第一、配置redis.conf 的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） </li><li>第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略</li></ul><h3 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h3><p>惰性删除+定期删除</p><ul><li>惰性删除流程<ul><li>在进行get或setnx等操作时，先检查key是否过期，</li><li>若过期，删除key，然后执行相应操作；</li><li>若没过期，直接执行相应操作</li></ul></li><li>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<ul><li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）</li><li>检查当前库中的指定个数个key（默认是每个库<strong>随机</strong>检查20个key，注意相当于该循环执行20次，循环体时下边的描述）</li><li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li><li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li><li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li></ul></li></ul><p>==最后就是如果的如果，定期没删，我也没查询，那可咋整？==</p><h2 id="Redis-的淘汰策略有哪些？"><a href="#Redis-的淘汰策略有哪些？" class="headerlink" title="Redis 的淘汰策略有哪些？"></a>Redis 的淘汰策略有哪些？</h2><p>我们通过配置redis.conf中的maxmemory这个值来开启内存淘汰功能。根据用户设置的逐出策略，选出待逐出的key，直到当前内存小于最大内存值为止。</p><h3 id="Redis-有六种淘汰策略"><a href="#Redis-有六种淘汰策略" class="headerlink" title="Redis 有六种淘汰策略"></a>Redis 有六种淘汰策略</h3><table><thead><tr><th align="left">策略</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">volatile-lru</td><td align="left">从已设置过期时间的 KV 集中优先对最近<strong>最少使用</strong>(less recently used)的数据淘汰</td></tr><tr><td align="left">volitile-ttl</td><td align="left">从已设置过期时间的 KV 集中优先对<strong>剩余时间短</strong>(time to live)的数据淘汰</td></tr><tr><td align="left">volitile-random</td><td align="left">从已设置过期时间的 KV 集中<strong>随机</strong>选择数据淘汰</td></tr><tr><td align="left">allkeys-lru</td><td align="left">从所有 KV 集中优先对<strong>最近最少使用</strong>(less recently used)的数据淘汰</td></tr><tr><td align="left">allKeys-random</td><td align="left">从所有 KV 集中<strong>随机选择</strong>数据淘汰</td></tr><tr><td align="left">noeviction</td><td align="left"><strong>不淘汰</strong>策略，若超过最大内存，返回错误信息</td></tr></tbody></table><h3 id="4-0-版本后增加以下两种"><a href="#4-0-版本后增加以下两种" class="headerlink" title="4.0 版本后增加以下两种"></a>4.0 版本后增加以下两种</h3><ul><li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li></ul><h3 id="手写一个LRU算法？"><a href="#手写一个LRU算法？" class="headerlink" title="手写一个LRU算法？"></a>手写一个LRU算法？</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxEntries;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> maxEntries)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这块就是设置一个hashmap的初始大小，同时最后一个true指的是让linkedhashmap按照访问顺序来进行排序，最近访问的放在头，最老访问的就在尾</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.maxEntries = maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个意思就是说当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol><li><p>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</p></li><li><p>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</p></li><li><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p></li></ol><h3 id="那他是单线程的，我们现在服务器都是多核的，那不是很浪费？"><a href="#那他是单线程的，我们现在服务器都是多核的，那不是很浪费？" class="headerlink" title="那他是单线程的，我们现在服务器都是多核的，那不是很浪费？"></a>那他是单线程的，我们现在服务器都是多核的，那不是很浪费？</h3><p>是的他是单线程的，但是，我们可以通过在单机开多个<strong>Redis实例</strong>嘛。</p><hr><h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><h4 id="全量同步-新增salve结点"><a href="#全量同步-新增salve结点" class="headerlink" title="全量同步(新增salve结点)"></a>全量同步(新增salve结点)</h4><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录(<strong>复制偏移量</strong>)到内存buffer(<strong>复制积压缓冲区</strong>)，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将<strong>RDB</strong>镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过<strong>AOF</strong>日志同步即可，有点类似数据库的binlog。</p><h4 id="部分重新同步-断线重连"><a href="#部分重新同步-断线重连" class="headerlink" title="部分重新同步(断线重连)"></a>部分重新同步(断线重连)</h4><p>部分重同步可以让我们断线后重连<strong>只需要同步缺失的数据</strong>，部分重同步功能由以下部分组成：</p><ul><li>主从服务器的<strong>复制偏移量</strong></li><li>主服务器的<strong>复制积压缓冲区</strong></li><li>服务器运行的ID(<strong>run ID</strong>)</li></ul><p>首先我们来解释一下上面的名词：</p><p>复制偏移量：执行复制的双方都会<strong>分别维护</strong>一个复制偏移量</p><ul><li>主服务器每次传播N个字节，就将自己的复制偏移量加上N</li><li>从服务器每次收到主服务器的N个字节，就将自己的复制偏移量加上N</li></ul><p>通过<strong>对比主从复制的偏移量</strong>，就很容易知道主从服务器的数据是否处于一致性的状态！</p><p><img alt="image-20200515094924540" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gesw9lel9ej30fi0p2jxj.jpg" class="lazyload"></p><p>那断线重连以后，从服务器向主服务器发送PSYNC命令，报告现在的偏移量是36，那么主服务器该对从服务器执行完整重同步还是部分重同步呢？？这就交由<strong>复制积压缓冲区</strong>来决定。</p><p>当主服务器进行命令传播时，不仅仅会将写命令发送给所有的从服务器，还会将写命令<strong>入队到复制积压缓冲区</strong>里面(这个大小可以调的)。如果复制积压缓冲区<strong>存在</strong>丢失的偏移量的数据，那就执行部分重同步，否则执行完整重同步。</p><p>服务器运行的ID(<strong>run ID</strong>)实际上就是用来比对ID是否相同。如果不相同，则说明从服务器断线之前复制的主服务器和当前连接的主服务器是两台服务器，这就会进行完整重同步。</p><h3 id="Redis高可用配置（主从、哨兵、集群）"><a href="#Redis高可用配置（主从、哨兵、集群）" class="headerlink" title="Redis高可用配置（主从、哨兵、集群）"></a>Redis高可用配置（主从、哨兵、集群）</h3><p>详见如下链接：</p><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/redis-collection/Redis(9)——集群入门实践教程.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/redis-collection/Redis(9)%E2%80%94%E2%80%94%E9%9B%86%E7%BE%A4%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B.md</a></p><p>介绍了Redis主从、哨兵、集群如何实践，及其原理。以下仅从面试热点进行梳理：</p></blockquote><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>在 <strong>哨兵系统</strong> 中，节点分为 <strong>数据节点</strong> 和 <strong>哨兵节点</strong>：前者存储数据，后者实现额外的控制功能。在 <strong>集群</strong> 中，没有数据节点与非数据节点之分：<strong>所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个 TCP 端口：</p><ul><li><strong>普通端口：</strong> 即我们在前面指定的端口 <em>(7000等)</em>。普通端口主要用于为客户端提供服务 <em>（与单机节点类似）</em>；但在节点间数据迁移时也会使用。</li><li><strong>集群端口：</strong> 端口号是普通端口 + 10000 <em>（10000是固定值，无法改变）</em>，如 <code>7000</code> 节点的集群端口为 <code>17000</code>。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li></ul><h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><p><a href="https://camo.githubusercontent.com/1f82de60e5ec7e3529eee05500b2f8dc425b0e86/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d353136656234613934363534353161362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/1f82de60e5ec7e3529eee05500b2f8dc425b0e86/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d353136656234613934363534353161362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" class="lazyload"></a></p><p><em>上图</em> 展示了 <strong>Redis Cluster</strong> 典型的架构图，集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p><a href="https://camo.githubusercontent.com/a7f2e3397b72776ba3243e4ef4c209cdf24e104a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d663635633731636136383131633633342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/a7f2e3397b72776ba3243e4ef4c209cdf24e104a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d663635633731636136383131633633342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" class="lazyload"></a></p><p>Redis 集群中内置了 <code>16384</code> (16<em>2^10^)个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 *</em>集群的配置信息<strong>，当客户端具体对某一个 <code>key</code> 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 <code>16384</code> **求余数</strong>，这样每个 <code>key</code> 都会对应一个编号在 <code>0-16383</code> 之间的哈希槽，<strong>Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</strong>。</p><h5 id="集群的主要作用"><a href="#集群的主要作用" class="headerlink" title="集群的主要作用"></a>集群的主要作用</h5><ol><li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……</li><li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li></ol><h4 id="数据分区方案简析"><a href="#数据分区方案简析" class="headerlink" title="数据分区方案简析"></a>数据分区方案简析</h4><h5 id="方案一：哈希值-节点数"><a href="#方案一：哈希值-节点数" class="headerlink" title="方案一：哈希值 % 节点数"></a>方案一：哈希值 % 节点数</h5><p>哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p><p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p><h5 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h5><p>一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 , 2^32^-1]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p><p><a href="https://camo.githubusercontent.com/4d3da71d2cd7d407dcec94f611221b0a6d79dc3e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d343065386132633039366338646139322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/4d3da71d2cd7d407dcec94f611221b0a6d79dc3e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d343065386132633039366338646139322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" class="lazyload"></a></p><p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p><p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p><h5 id="方案三：带有虚拟节点的一致性哈希分区"><a href="#方案三：带有虚拟节点的一致性哈希分区" class="headerlink" title="方案三：带有虚拟节点的一致性哈希分区"></a>方案三：带有虚拟节点的一致性哈希分区</h5><p>该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。==Redis 集群使用的便是该方案==，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个<strong>实际节点包含一定数量的槽</strong>，<strong>每个槽包含哈希值在一定范围内的数据</strong>。</p><p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)；</p><ul><li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li></ul><p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p><h4 id="节点通信机制简析"><a href="#节点通信机制简析" class="headerlink" title="节点通信机制简析"></a>节点通信机制简析</h4><p>集群的建立离不开节点之间的通信，例如我们上访在 <em>快速体验</em> 中刚启动六个集群节点之后通过 <code>redis-cli</code> 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 <code>CLUSTER MEET</code> 命令发送 <code>MEET</code> 消息完成的，下面我们展开详细说说。</p><h4 id="数据结构简析"><a href="#数据结构简析" class="headerlink" title="数据结构简析"></a>数据结构简析</h4><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p><p>节点为了存储集群状态而提供的数据结构中，最关键的是 <code>clusterNode</code> 和 <code>clusterState</code> 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。</p><h5 id="clusterNode-结构"><a href="#clusterNode-结构" class="headerlink" title="clusterNode 结构"></a>clusterNode 结构</h5><p><code>clusterNode</code> 结构保存了 <strong>一个节点的当前状态</strong>，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 <code>clusterNode</code> 结构记录自己的状态，并为集群内所有其他节点都创建一个 <code>clusterNode</code> 结构来记录节点状态。</p><p>下面列举了 <code>clusterNode</code> 的部分字段，并说明了字段的含义和作用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterNode &#123;</span><br><span class="line">    <span class="comment">//节点创建时间</span></span><br><span class="line">    mstime_t ctime;</span><br><span class="line">    <span class="comment">//节点id</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    <span class="comment">//节点的ip和端口号</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span></span><br><span class="line">    uint64_t configEpoch;</span><br><span class="line">    <span class="comment">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span></span><br><span class="line">    unsigned <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//节点中槽的数量</span></span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    …………</span><br><span class="line">&#125; clusterNode;</span><br></pre></td></tr></table></figure></div><p>除了上述字段，<code>clusterNode</code> 还包含节点连接、主从复制、故障发现和转移需要的信息等。</p><h5 id="clusterState-结构"><a href="#clusterState-结构" class="headerlink" title="clusterState 结构"></a>clusterState 结构</h5><p><code>clusterState</code> 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line">    <span class="comment">//自身节点</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line">    <span class="comment">//配置纪元</span></span><br><span class="line">    uint64_t currentEpoch;</span><br><span class="line">    <span class="comment">//集群状态：在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//集群中至少包含一个槽的节点数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//哈希表，节点名称-&gt;clusterNode节点指针</span></span><br><span class="line">    dict *nodes;</span><br><span class="line">    <span class="comment">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">    …………</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure></div><p>除此之外，<code>clusterState</code> 还包括故障转移、槽迁移等需要的信息。</p><h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p><h2 id="字典是如何实现的？Rehash了解吗？"><a href="#字典是如何实现的？Rehash了解吗？" class="headerlink" title="字典是如何实现的？Rehash了解吗？"></a>字典是如何实现的？Rehash了解吗？</h2><h3 id="先总体聊一下-Redis-中的字典"><a href="#先总体聊一下-Redis-中的字典" class="headerlink" title="先总体聊一下 Redis 中的字典"></a>先总体聊一下 Redis 中的字典</h3><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。<em>(存储在 RedisDb 数据结构中)</em></p><h3 id="说明字典内部结构和-rehash"><a href="#说明字典内部结构和-rehash" class="headerlink" title="说明字典内部结构和 rehash"></a>说明字典内部结构和 rehash</h3><p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个 <code>hashtable</code> 有值，但是在字典扩容缩容时，需要分配新的 <code>hashtable</code>，然后进行 <strong>渐进式搬迁</strong> <em>(rehash)</em>，这时候两个 <code>hashtable</code> 分别存储旧的和新的 <code>hashtable</code>，待搬迁结束后，旧的将被删除，新的 <code>hashtable</code> 取而代之。</p><p>渐进式哈希(rehashing)的机制来提高字典的缩放效率，避免 rehash 对服务器性能造成影响，渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p><p>即 redis中，每次插入键值对时，都会检查是否需要扩容。如果满足扩容条件，则进行扩容。</p><h3 id="扩缩容的条件"><a href="#扩缩容的条件" class="headerlink" title="扩缩容的条件"></a>扩缩容的条件</h3><p>正常情况下，当 hash 表中 <strong>元素的个数超过了哈希表的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了哈希表长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p><p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于哈希表数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p><hr><h2 id="数据结构篇"><a href="#数据结构篇" class="headerlink" title="数据结构篇"></a>数据结构篇</h2><h3 id="简述一下-Redis-常用数据结构及实现？"><a href="#简述一下-Redis-常用数据结构及实现？" class="headerlink" title="简述一下 Redis 常用数据结构及实现？"></a>简述一下 Redis 常用数据结构及实现？</h3><p>首先在 Redis 内部会使用一个 <strong>RedisObject</strong> 对象来表示所有的 <code>key</code> 和 <code>value</code>：</p><p>其次 Redis 为了 <strong>平衡空间和时间效率</strong>，针对 <code>value</code> 的具体类型在底层会采用不同的数据结构来实现，下图展示了他们之间的映射关系：</p><p>![image-20200509220059797](/Users/lilei/Library/Application Support/typora-user-images/image-20200509220059797.png)</p><p><code>String：</code></p><p>​        动态字符串，内部结构实现上类似于Java的ArrayList，纯 数字用long</p><p><code>List：</code></p><p>​        Redis 早期版本存储 list 列表数据结构使用的是<code>压缩列表 ziplist</code> 和普通的<code>双向链表 linkedlist</code>，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。</p><p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，<u>使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code></u>。</p><p><code>Hash：</code></p><p>​        HashMap。</p><p><code>Set：</code></p><p>​        Hashtable</p><p><code>ZSet：</code></p><p>​        zset的编码有<strong>ziplist</strong>和<strong>skiplist</strong>两种。<br>​         底层分别使用<strong>ziplist（压缩链表）</strong>和<strong>skiplist（跳表）</strong>实现。</p><p>当zset满足以下两个条件的时候，使用ziplist：</p><blockquote><ol><li>保存的元素少于128个</li><li>保存的所有元素大小都小于64字节</li></ol></blockquote><p>​        ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。</p><p>​        skiplist底层实现使用了两个数据结构，hash+跳表，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。跳跃列表的目的在于给元素 <code>score</code> 排序，根据score的范围获取元素列表。</p><p><code>GeoHash：</code></p><p>在使用 <strong>Redis</strong> 进行 <strong>Geo 查询</strong> 时，我们要时刻想到它的内部结构实际上只是一个 <strong>zset(skiplist)</strong>。通过 zset 的 <code>score</code> 排序就可以得到坐标附近的其他元素 <em>(实际情况要复杂一些，不过这样理解足够了)</em>，通过将 <code>score</code> 还原成坐标值就可以得到元素的原始坐标了。</p><p>当两个坐标元素的距离不是很远的时候，我们就可以简单利用 <strong>勾股定理</strong> 就能够得出他们之间的 <strong>距离</strong>。</p><h3 id="HyperLogLog-有了解吗？"><a href="#HyperLogLog-有了解吗？" class="headerlink" title="HyperLogLog 有了解吗？"></a>HyperLogLog 有了解吗？</h3><blockquote><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUyMTg0NDA2Ng==&mid=2247484012&idx=1&sn=3624989d388d17331e1f7ad78fc7a257&chksm=f9d5a661cea22f7781ed997d05afee8f28da52a0013691961915a2831780e481ae94b6e9a1ae&scene=21##wechat_redirect" target="_blank" rel="noopener">Redis(4)——神奇的HyperLoglog解决统计问题</a></li></ul></blockquote><h3 id="布隆过滤器有了解吗？"><a href="#布隆过滤器有了解吗？" class="headerlink" title="布隆过滤器有了解吗？"></a>布隆过滤器有了解吗？</h3><blockquote><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUyMTg0NDA2Ng==&mid=2247484022&idx=1&sn=a98c479b4cac96c6af45f219a7c0bde4&chksm=f9d5a67bcea22f6d03b30ce8660f3f3ded294390fd394e138a40a439d0f96d56c8dda2082203&scene=21##wechat_redirect" target="_blank" rel="noopener">Redis(5)——亿级数据过滤和布隆过滤器</a></li></ul></blockquote><h3 id="跳跃表是如何实现的？原理？"><a href="#跳跃表是如何实现的？原理？" class="headerlink" title="跳跃表是如何实现的？原理？"></a>跳跃表是如何实现的？原理？</h3><blockquote><p>“</p><p>这是 Redis 中比较重要的一个数据结构，<strong>建议阅读</strong> 之前写过的文章，里面详细介绍了原理和一些细节：</p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUyMTg0NDA2Ng==&mid=2247484000&idx=1&sn=a7e02adebea31535c3870cc514719493&chksm=f9d5a66dcea22f7b7cdf210993cbe6c057c0456967ac106d76c89fdd76ed5cb271c879a83f3e&scene=21##wechat_redirect" target="_blank" rel="noopener">Redis(2)——跳跃表</a></li></ul></blockquote><h3 id="GeoHash-了解吗？"><a href="#GeoHash-了解吗？" class="headerlink" title="GeoHash 了解吗？"></a>GeoHash 了解吗？</h3><blockquote><p>“</p><p><strong>建议阅读</strong> 之前的系列文章：</p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUyMTg0NDA2Ng==&mid=2247484027&idx=1&sn=6237212c01a009be9a5ca88e0e50a46d&chksm=f9d5a676cea22f603e06d1e61d6293985c8ddb063621b1cdf2696da2eaeb1681e307ef2a3f20&scene=21##wechat_redirect" target="_blank" rel="noopener">Redis(6)——GeoHash查找附近的人</a></li></ul></blockquote><h3 id="压缩列表了解吗？"><a href="#压缩列表了解吗？" class="headerlink" title="压缩列表了解吗？"></a>压缩列表了解吗？</h3><p>这是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，<strong>zset</strong> 和 <strong>hash</strong> 容器对象会在元素个数较少的时候，采用压缩列表（ziplist）进行存储。压缩列表是 <strong>一块连续的内存空间</strong>，元素之间紧挨着存储，没有任何冗余空隙。</p><blockquote><p>“</p><p>因为之前自己也没有学习过，所以找了一篇比较好比较容易理解的文章：</p><ul><li>图解Redis之数据结构篇——压缩列表 - <a href="https://mp.weixin.qq.com/s?__biz=MzU3OTk1MjMyMA==&mid=2247483700&idx=1&sn=8613dcc63a6419af2b941a64c2c58534&scene=21##wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg</a></li><li>这一篇稍微底层稍微硬核一点：<a href="http://www.web-lovers.com/redis-source-ziplist.html" target="_blank" rel="noopener">http://www.web-lovers.com/redis-source-ziplist.html</a></li></ul></blockquote><h3 id="快速列表-quicklist-了解吗？"><a href="#快速列表-quicklist-了解吗？" class="headerlink" title="快速列表 quicklist 了解吗？"></a>快速列表 quicklist 了解吗？</h3><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p><p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>。</p><blockquote><p>“</p><p>同上..建议阅读一下以下的文章：</p><ul><li>Redis列表list 底层原理 - <a href="https://zhuanlan.zhihu.com/p/102422311" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102422311</a></li></ul></blockquote><h3 id="Stream-结构有了解吗？"><a href="#Stream-结构有了解吗？" class="headerlink" title="Stream 结构有了解吗？"></a>Stream 结构有了解吗？</h3><p><strong>Redis Stream</strong> 从概念上来说，就像是一个 <strong>仅追加内容</strong> 的 <strong>消息链表</strong>，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：<strong>消费者组(Consumer Group)</strong> <em>(思路一致，实现不同)</em>：</p><p><img alt="img" data-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" class="lazyload"></p><p>上图就展示了一个典型的 <strong>Stream</strong> 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 <code>key</code>，在我们首次使用 <code>xadd</code> 指令追加消息时自动创建。我们对图中的一些概念做一下解释：</p><ul><li><strong>Consumer Group</strong>：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 <code>XREAD</code> 命令进行 <strong>独立消费</strong>，也可以多个消费者同时加入一个消费者组进行 <strong>组内消费</strong>。同一个消费者组内的消费者共享所有的 Stream 信息，<strong>同一条消息只会有一个消费者消费到</strong>，这样就可以应用在分布式的应用场景中来保证消息的唯一性。</li><li><strong>last_delivered_id</strong>：用来表示消费者组消费在 Stream 上 <strong>消费位置</strong> 的游标信息。每个消费者组都有一个 Stream 内 <strong>唯一的名称</strong>，消费者组不会自动创建，需要使用 <code>XGROUP CREATE</code> 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 <code>last_delivered_id</code> 这个变量。</li><li><strong>pending_ids</strong>：每个消费者内部都有的一个状态变量，用来表示 <strong>已经</strong> 被客户端 <strong>获取</strong>，但是 <strong>还没有 ack</strong> 的消息。记录的目的是为了 <strong>保证客户端至少消费了消息一次</strong>，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 <strong>PEL</strong> <em>(Pending Entries List)</em>。</li></ul><h4 id="Stream-消息太多怎么办？"><a href="#Stream-消息太多怎么办？" class="headerlink" title="Stream 消息太多怎么办？"></a>Stream 消息太多怎么办？</h4><p>很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。<code>xdel</code> 指令又不会删除消息，它只是给消息做了个标志位。</p><p>Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 <code>xadd</code> 的指令提供一个定长长度 <code>maxlen</code>，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; XADD mystream MAXLEN 2 * value 1</span><br><span class="line">1526654998691-0</span><br><span class="line">&gt; XADD mystream MAXLEN 2 * value 2</span><br><span class="line">1526654999635-0</span><br><span class="line">&gt; XADD mystream MAXLEN 2 * value 3</span><br><span class="line">1526655000369-0</span><br><span class="line">&gt; XLEN mystream</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line">1) 1) 1526654999635-0</span><br><span class="line">   2) 1) &quot;value&quot;</span><br><span class="line">      2) &quot;2&quot;</span><br><span class="line">2) 1) 1526655000369-0</span><br><span class="line">   2) 1) &quot;value&quot;</span><br><span class="line">      2) &quot;3&quot;</span><br></pre></td></tr></table></figure></div><p>如果使用 <code>MAXLEN</code> 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。<em>(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息)</em></p><p>另外使用 <code>MAXLEN</code> 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 <code>~</code> 的特殊命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD mystream MAXLEN ~ 1000 * ... entry fields here ...</span><br></pre></td></tr></table></figure></div><p>它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 <code>1000</code> 条数据，可能是 <code>1010</code> 也可能是 <code>1030</code>。</p><h4 id="PEL-是如何避免消息丢失的？"><a href="#PEL-是如何避免消息丢失的？" class="headerlink" title="PEL 是如何避免消息丢失的？"></a>PEL 是如何避免消息丢失的？</h4><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 <code>xreadgroup</code> 的起始消息 ID 不能为参数 <code>&gt;</code> ，而必须是任意有效的消息 ID，一般将参数设为 <code>0-0</code>，表示读取所有的 PEL 消息以及自 <code>last_delivered_id</code> 之后的新消息。</p><h4 id="和-Kafka-对比起来呢？"><a href="#和-Kafka-对比起来呢？" class="headerlink" title="和 Kafka 对比起来呢？"></a>和 Kafka 对比起来呢？</h4><p>Redis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 <strong>不能长时间存储大量数据</strong>。不过如果您想以 <strong>最小延迟</strong> 实时处理消息的话，您可以考虑 Redis，但是如果 <strong>消息很大并且应该重用数据</strong> 的话，则应该首先考虑使用 Kafka。</p><p>另外从某些角度来说，<code>Redis Stream</code> 也更适用于小型、廉价的应用程序，因为 <code>Kafka</code> 相对来说更难配置一些。</p><blockquote><p>“</p><p><strong>推荐阅读</strong> 之前的系列文章，里面 <strong>也对 Pub/ Sub 做了详细的描述</strong>：</p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUyMTg0NDA2Ng==&mid=2247484039&idx=1&sn=99866e4cc6c842dc6d50d68a362d53a8&chksm=f9d5a68acea22f9cf6d972c23809520137957bd26ce7e6c6cb4f4ed11ddcbbc9938c1a56eb46&scene=21##wechat_redirect" target="_blank" rel="noopener">Redis(8)——发布/订阅与Stream</a></li></ul></blockquote><script src="https://readmore.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'post-content',        blogId: '24566-1633176031733-929',        name: '简凡丶',        qrcode: 'https://codebear-images.oss-cn-beijing.aliyuncs.com/getqrcode.jpeg',        keyword: '666',    });</script>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略设计模式干掉if else!</title>
      <link href="/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E5%90%88Spring%E6%9B%BF%E6%8D%A2ifelse/"/>
      <url>/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E5%90%88Spring%E6%9B%BF%E6%8D%A2ifelse/</url>
      
        <content type="html"><![CDATA[<h2 id="在-Spring-Boot-中，如何干掉-if-else！"><a href="#在-Spring-Boot-中，如何干掉-if-else！" class="headerlink" title="在 Spring Boot 中，如何干掉 if else！"></a>在 Spring Boot 中，如何干掉 if else！</h2><ul><li>需求</li><li>传统实现</li><li>策略模式实现</li><li>ClassScanner：扫描工具类源码</li><li>总结</li></ul><hr><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>这里虚拟一个业务需求，让大家容易理解。假设有一个订单系统，里面的一个功能是根据订单的不同类型作出不同的处理。</p><p>订单实体：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3nRrlcicMHL9l2yciclelUU2Reswf6JErLXmxj94DjLGniaUibOM9Nvod9g/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>service接口：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3zZMobPBmbDY28PeS8swV0xrVOMhLMicgZz1cGpn7h6icp1GbqiaW0TAIA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h2 id="传统实现"><a href="#传统实现" class="headerlink" title="传统实现"></a>传统实现</h2><p>根据订单类型写一堆的if else：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3dJfeLzgdGXtE1Z3QmSqW4yvVYFEMQF0YPFHpehoZxeEcJUrEPviaiamQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h2 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h2><h3 id="调用：由控制器选择具体实现"><a href="#调用：由控制器选择具体实现" class="headerlink" title="调用：由控制器选择具体实现"></a>调用：由控制器选择具体实现</h3><p>利用策略模式，只需要两行即可实现业务逻辑：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ373vrSV8RkliaK66IJlegYc9Nv0vgSTmE8BcBQyFOkDStbG9sLL1Zbvg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>可以看到上面的方法中注入了HandlerContext，这是一个处理器上下文，用来保存不同的业务处理器，具体在下文会讲解。我们从中获取一个抽象的处理器AbstractHandler，调用其方法实现业务逻辑。</p><p>现在可以了解到，我们主要的业务逻辑是在处理器中实现的，因此有多少个订单类型，就对应有多少个处理器。以后需求变化，增加了订单类型，只需要添加相应的处理器就可以，上述OrderServiceV2Impl完全不需改动。</p><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><p>我们先看看业务处理器的写法：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3nXEV6MaJyiajbAQImbFXFFUzXQ82hF6z1TLjlcJSdmJm8ibIgqTEiay7A/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3ZBia9BYYXv8ypyqFibDvevDJhKpIX9w3ftuJMek4coZpuPxtAia5RCfxw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3YSzqaspTb5JKYYDEiblmHCKXTq2ibfZNpmjZVc3LFUYBNcB1uEsES0PA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>首先每个处理器都必须添加到spring容器中，因此需要加上@Component注解，其次需要加上一个自定义注解@HandlerType，用于标识该处理器对应哪个订单类型，最后就是继承AbstractHandler，实现自己的业务逻辑。</p><h3 id="自定义注解-HandlerType"><a href="#自定义注解-HandlerType" class="headerlink" title="自定义注解 @HandlerType"></a>自定义注解 @HandlerType</h3><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3Rp4ia6gfssmK3IgqlbkMTvI4pvoU6R3rGc0WkeAClDmbtCtdzIvS1Bg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h3 id="定义：抽象处理器-AbstractHandler"><a href="#定义：抽象处理器-AbstractHandler" class="headerlink" title="定义：抽象处理器 AbstractHandler"></a>定义：抽象处理器 AbstractHandler</h3><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3HJXjLDd151S3g9icwtJTzKOJM9SAaichozAaeke8DDiajFPgyJovhibMicg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h3 id="注入到Spring容器"><a href="#注入到Spring容器" class="headerlink" title="注入到Spring容器"></a>注入到Spring容器</h3><p>自定义注解和抽象处理器都很简单，那么如何将处理器注册到spring容器中呢？</p><p>具体思路是：</p><p>1、扫描指定包中标有@HandlerType的类；</p><p>2、将注解中的类型值作为key，对应的类作为value，保存在Map中；</p><p>3、以上面的map作为构造函数参数，初始化HandlerContext，将其注册到spring容器中；</p><p>我们将核心的功能封装在HandlerProcessor类中，完成上面的功能。</p><p><code>HandlerProcessor：</code></p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ3rxXoEPxFHNH8EVZbbtict0gZ4ibOxCVBAMkSW1G6TwOURxFAycG8xoeg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h2 id="ClassScanner：扫描工具类源码"><a href="#ClassScanner：扫描工具类源码" class="headerlink" title="ClassScanner：扫描工具类源码"></a>ClassScanner：扫描工具类源码</h2><p>HandlerProcessor需要实现BeanFactoryPostProcessor，在spring处理bean前，将自定义的bean注册到容器中。</p><p>核心工作已经完成，现在看看HandlerContext如何获取对应的处理器：</p><p>HandlerContext：</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupXel0UdaMtVlVTibgclNpKJ30wjjwEgiaNx0XdVpZkTjrqibnaAMO806VBT0T2f52aI9PE2fcDj2wYSw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p>BeanTool：获取bean工具类</p><p><code>#getInstance</code> 方法根据类型获取对应的class，然后根据class类型获取注册到spring中的bean。</p><p>最后请注意一点，HandlerProcessor和BeanTool必须能被扫描到，或者通过@Bean的方式显式的注册，才能在项目启动时发挥作用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用策略模式可以简化繁杂的if else代码，方便维护，而利用自定义注解和自注册的方式，可以方便应对需求的变更。本文只是提供一个大致的思路，还有很多细节可以灵活变化，例如使用枚举类型、或者静态常量，作为订单的类型，相信你能想到更多更好的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo</title>
      <link href="/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/"/>
      <url>/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://mp.weixin.qq.com/s/PdWRHgm83XwPYP08KnkIsw" target="_blank" rel="noopener">dubbo面试题</a></p></li><li><p><a href="https://juejin.im/post/5e9591dee51d4546cf7785ca?utm_source=gold_browser_extension" target="_blank" rel="noopener">分布式相关面试题</a></p></li><li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/dubbo.md" target="_blank" rel="noopener">Dubbo 总结：关于 Dubbo 的重要知识点</a></p></li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="为什么要用-Dubbo？"><a href="#为什么要用-Dubbo？" class="headerlink" title="为什么要用 Dubbo？"></a>为什么要用 Dubbo？</h3><ul><li>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架就出现了，Dubbo 也就这样产生了。</li></ul><h3 id="Dubbo-核心组件有哪些？"><a href="#Dubbo-核心组件有哪些？" class="headerlink" title="Dubbo 核心组件有哪些？"></a>Dubbo 核心组件有哪些？</h3><p><img alt="image-20200612152236892" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpj8vnukjj30sg0lr0wx.jpg" class="lazyload"></p><ul><li>Provider：暴露服务的服务提供方</li><li>Consumer：调用远程服务消费方</li><li>Registry：服务注册与发现注册中心</li><li>Monitor：监控中心和访问调用统计</li><li>Container：服务运行容器</li></ul><h3 id="Dubbo-服务器注册与发现的流程？"><a href="#Dubbo-服务器注册与发现的流程？" class="headerlink" title="Dubbo 服务器注册与发现的流程？"></a>Dubbo 服务器注册与发现的流程？</h3><ul><li>服务容器Container负责启动，加载，运行服务提供者。</li><li>服务提供者Provider在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者Consumer在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心Registry返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者Consumer和提供者Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。</li></ul><h3 id="说说-Dubbo-服务暴露的过程"><a href="#说说-Dubbo-服务暴露的过程" class="headerlink" title="说说 Dubbo 服务暴露的过程"></a>说说 Dubbo 服务暴露的过程</h3><p>dubbo采用的nio异步的通信，通信协议默认为 netty,当然也可以选择 mina,grizzy。在服务端（provider）在启动时主要是开启netty监听，在zookeeper上注册服务节点，处理消费者请求，返回处理后的消息给消费者，消费者使用服务时主要是订阅服务的节点，监听zookeeper节点目录，服务端的变化时zookeeper会推送给消费者，消费者重新缓存服务地址等。服务者、消费者、zookeeper三者之间都是长连接。</p><hr><h4 id="简易的暴露流程"><a href="#简易的暴露流程" class="headerlink" title="简易的暴露流程"></a>简易的暴露流程</h4><ol><li><p>Spring将dubbo标签解析，注入到ServiceConfig属性中</p></li><li><p>服务暴露的入口是：<code>ServiceConfig</code>的<code>export</code> 方法，里面判断是否延迟暴露，最终调用<code>doExport</code></p></li><li><p><code>doExport</code>会对解析完的配置再做一次检查，所有的检查通过之后，会调用 <code>doExportUrls</code> 方法，因为dubbo支持多通信协议时，都进行暴露，里面调用<code>doExportUrlsFor1Protocol</code></p></li><li><p><code>doExportUrlsFor1Protocol</code>中主要将所有的配置转化成map，然后将map转化成dubbo的统一URL，最终暴露的dubbo服务也就是这个统一的url，这个url也会注册到zookeeper的节点上。然后将所有服务的实现封装成一个<code>invoker</code>，并缓存起来，缓存里使用Invoker的url作为key。代码核心暴露的一行代码为：<strong>protocol.export(invoker);</strong> </p></li><li><p><code>RegistryProtocol.exprot</code>主要做两件事情：1、开启netty服务端并监听  。2、创建zookeeper服务临时节点。</p></li><li><p>启动注册是调用doRegister方法，不同协议重写了此方法。其实从上面已经可以看到 在zookeeper上面创建 节点了，默认不分组的情况下，服务结构如下：/dubbo/XXXXservice/consumers、providers<img alt="image-20200612172041457" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpmnqvwh9j30et03h0sz.jpg" class="lazyload"></p></li><li><p>服务端Server启动，监听端口。（请求来到时，根据请求信息生成key，到缓存查找Exporter，就找到了Invoker，就可以完成调用。）</p></li></ol><h4 id="结合源码"><a href="#结合源码" class="headerlink" title="结合源码"></a>结合源码</h4><p>下面看dubbo源码来看服务暴露的过程，服务暴露的入口为：<code>com.alibaba.dubbo.config.ServiceConfig</code>#<code>export</code> 方法，代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否延时暴露</span></span><br><span class="line"><span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(delay);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      doExport();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">  thread.setName(<span class="string">"DelayExportServiceThread"</span>);</span><br><span class="line">  thread.start();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//不延时暴露，则直接暴露</span></span><br><span class="line">  doExport();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上在代码无论是延时暴露或直接暴露调用的方法是：<code>doExport()</code>,doExport会对解析完的配置再做一次检查，核心代码大家可以查看dubbo的源码，下面列出一小部分</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     检查默认设置,如果xml中没有配置&lt;dubbo:provider</span></span><br><span class="line"><span class="comment">     主要是从系统环境变量中寻找是否有相应的provider的配置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> checkDefault();</span><br><span class="line"> <span class="comment">//下面设置的内容如果没有配置&lt;dubbo:provider时基本上都是Null</span></span><br><span class="line"> <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">         application = provider.getApplication();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">         registries = provider.getRegistries();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">         monitor = provider.getMonitor();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">         protocols = provider.getProtocols();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//registries一般都会配置</span></span><br><span class="line">     <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">         registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">         monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//application一般也会配置</span></span><br><span class="line">     <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">         registries = application.getRegistries();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">         monitor = application.getMonitor();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//是否泛化调用</span></span><br><span class="line"> <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">     interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">         generic = Boolean.TRUE.toString();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                 .getContextClassLoader());</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         检查即将暴露的接口的方法配置,检查方法是否在接口中存在</span></span><br><span class="line"><span class="comment">         一般不会配置所以一般情况下methods为null</span></span><br><span class="line"><span class="comment">         &lt;dubbo:service  &gt; &lt;dubbo:method /&gt; &lt;/dubbo:serivce&gt;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         检查接口的引用不为空,并且必须实现的是要暴露的接口</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     checkRef();</span><br><span class="line">     generic = Boolean.FALSE.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>所有的检查通过之后，会调用 ：<code>com.alibaba.dubbo.config.ServiceConfig</code>#<code>doExportUrls</code> 方法，因为dubbo支持多通信协议时，都进行暴露，所以在代码中可以看到</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    将注册协议转化成url</span></span><br><span class="line"><span class="comment">    registry://45.119.68.23:2181/com.alibaba.dubbo.registry.RegistryService?</span></span><br><span class="line"><span class="comment">    application=test-dubbo&amp;dubbo=2.5.3&amp;pid=7648&amp;registry=zookeeper×tamp=1462349748801</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//配置多通信协议时，都进行暴露</span></span><br><span class="line"><span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">    doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>doExportUrlsFor1Protocol</code>中主要将所有的配置转化成map，然后将map转化成dubbo的统一URL，最终暴露的dubbo服务也就是这个统一的url，这个url也会注册到zookeeper的节点上，部分代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将不为null的配置对象中的属性设置到 map 中</span></span><br><span class="line"><span class="comment">即将 xml 配置文件中的配置设置的值全转化成为map</span></span><br><span class="line"><span class="comment">&#123;side=provider, application=alijk-dubbo, accepts=1000,</span></span><br><span class="line"><span class="comment">dubbo=2.5.3, threads=100, pid=7236, interface=cn.eoncloud.account.sdk.export.AccountService,</span></span><br><span class="line"><span class="comment">threadpool=fixed, version=1.0.0, timeout=500, anyhost=true, timestamp=1462347843960&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appendParameters(map, application);</span><br><span class="line">appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">appendParameters(map, protocolConfig);</span><br><span class="line">appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将配置信息转化成 url ,主要根据之前map里的数据组装成url</span></span><br><span class="line"><span class="comment">调用 URL#buildString方法</span></span><br><span class="line"><span class="comment">dubbo://10.6.13.137:9998/cn.eoncloud.account.sdk.export.AccountService</span></span><br><span class="line"><span class="comment">?accepts=1000&amp;anyhost=true&amp;application=test-dubbo&amp;dubbo=2.5.3</span></span><br><span class="line"><span class="comment">&amp;interface=cn.eoncloud.account.sdk.export.AccountService</span></span><br><span class="line"><span class="comment">&amp;methods=getAccountName,getAllTest&amp;pid=7236&amp;revision=1.0.0&amp;side=provider</span></span><br><span class="line"><span class="comment">&amp;threadpool=fixed&amp;threads=100&amp;timeout=500×tamp=1462347843960&amp;version=1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">.<span class="title">hasExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">.<span class="title">getExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>()).<span class="title">getConfigurator</span>(<span class="title">url</span>).<span class="title">configure</span>(<span class="title">url</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</span><br><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line"><span class="comment">//com.alibaba.dubbo.registry.integration.RegistryProtocol#export 即将进行暴露</span></span><br><span class="line">Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br></pre></td></tr></table></figure></div><p>上面的代码核心暴露的一行代码为：protocol.export(invoker); 这个protocol的值为：RegistryProtocol，也就是暴露会跳到：RegistryProtocol.exprot中去处理，RegistryProtocol.exprot主要做两件事情：1、开启netty服务端  。2、创建zookeeper服务节点。下面来看RegistryProtocol.export 方法，代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">//export invoker doLocalExport调用dubboProtocol.export开启netty服务监听</span></span><br><span class="line">        <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">        <span class="comment">//registry provider</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">        <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">        <span class="comment">//调用zodoRegister的doRegister 创建zookeeper的服务节点</span></span><br><span class="line">        registry.register(registedProviderUrl);</span><br><span class="line">        <span class="comment">// 订阅override数据</span></span><br><span class="line">        <span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span></span><br><span class="line">        <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">        <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl);</span><br><span class="line">        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">        <span class="comment">//订阅</span></span><br><span class="line">        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">        <span class="comment">//保证每次export都返回一个新的exporter实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exporter&lt;T&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            exporter.unexport();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                registry.unregister(registedProviderUrl);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                overrideListeners.remove(overrideSubscribeUrl);</span><br><span class="line">                registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>上面的代码里有一段特别重要，关键性的代码在doLocalExport中：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line"><span class="comment">//此处protol为dubboProtocol</span></span><br><span class="line">exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;)protocol.export(invokerDelegete), originInvoker);</span><br></pre></td></tr></table></figure></div><p>从上面的代码中可以看到会调用dubboProtocol的export对服务进行暴露，这个export最终目的就是开启netty的监听，下面来看dubbo是如何一步一步开启netty的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find server. ip:port</span></span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        <span class="comment">//client 也可以暴露一个只有server可以调用的服务。</span></span><br><span class="line">        <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">        ExchangeServer server = serverMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//创建 Server</span></span><br><span class="line">        serverMap.put(key, createServer(url));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//server支持reset,配合override功能使用</span></span><br><span class="line">        server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认开启server关闭时发送readonly事件</span></span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">    <span class="comment">//默认开启heartbeat</span></span><br><span class="line">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line">    <span class="comment">//默认使用netty</span></span><br><span class="line">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; ! ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">str</span>))</span></span><br><span class="line">        throw new RpcException("Unsupported server type: " + str + ", url: " + url);</span><br><span class="line">    <span class="comment">//默认使用dubbo协议编码</span></span><br><span class="line">    url = url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME);</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//HeaderExchangeServer 在此处已经开启了Netty Server 进行监听</span></span><br><span class="line">        server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + url + <span class="string">") "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在上面的代码中：Exchangers.bind(url, requestHandler)  默认为：HeaderExchanger.bind()</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">//Transporters默认为NettyTransporter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>代码运行到这里可以看到传输方式了，dubbo默认采用的通信方式为 NettyTransporter ，再来看NettyTransporter.bind方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"netty"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>已经能看到NettyServer了，dubbo在暴露服务最终开启的netty服务监听，监听消费者发送的请求，通过反射调用方法得到结果通过 tcp/ip 网络传输返回给消费者。再进入到NettyServer中我们就能看到非常传统的开启Netty服务的代码了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">        ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">//最后一个参数为 NIO 最大工作线程数</span></span><br><span class="line">        ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">        <span class="comment">//netty server 启动器</span></span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    <span class="comment">// https://issues.jboss.org/browse/NETTY-365</span></span><br><span class="line">    <span class="comment">// https://issues.jboss.org/browse/NETTY-379</span></span><br><span class="line">    <span class="comment">// final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));</span></span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec() ,getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            <span class="comment">/*int idleTimeout = getIdleTimeout();</span></span><br><span class="line"><span class="comment">            if (idleTimeout &gt; 10000) &#123;</span></span><br><span class="line"><span class="comment">                pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建一个绑定到指定地址的新通道，也就是绑定IP、端口供客户端连接</span></span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面的代码执行完成后，netty的服务端就已经开启了，可以接收客户端的连接了，但客户端连接上来要怎么处理呢？消息接收、发送怎么处理呢？所有的处理都在上面代码的 NettyHandler类中，Nettyhandler继承了Netty包中的的SimpleChannelHandler</p><p>从前面知道,开启netty服务是在<code>RegistryProtocol.export</code> 的 <code>doLocalExport</code> 中，在开启了netty服务后，就是在zookeeper上注册服务节点了，消费者在消费服务时会根据消费的接口名找到对应的<strong>zookeeper节点目录</strong>，对目录进行监听，接收推送</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//registry provider</span></span><br><span class="line"><span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line"><span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line"><span class="comment">//调用zodoRegister的doRegister 创建zookeeper的服务节点</span></span><br><span class="line">registry.register(registedProviderUrl);</span><br><span class="line"><span class="comment">// 订阅override数据</span></span><br><span class="line"><span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span></span><br><span class="line"><span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line"><span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl);</span><br><span class="line">overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line">registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br></pre></td></tr></table></figure></div><p>dubbo服务在zookeeper上的节点注册是：<code>com.alibaba.dubbo.registry.support.FailbackRegistry</code>#<code>register</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.register(url);</span><br><span class="line">        failedRegistered.remove(url);</span><br><span class="line">        failedUnregistered.remove(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 向服务器端发送注册请求</span></span><br><span class="line">            doRegister(url);</span><br></pre></td></tr></table></figure></div><p>因为doRegister是一个抽象的方法，查看他的实现可以看到如下图：</p><p><img alt="image-20200612170609349" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpm8lvqxcj30rx057aaz.jpg" class="lazyload"></p><p>从上图可以看到doRegister实现有 dubbo、redis、zookeeper，这也是在我们配置时经常看到的 注册协议的配置 ，最为常用的就是 zookeeper了，所以再看ZookeeperRegistry的代码，看他的doRegistry干什么了如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>其实从上面已经可以看到 在zookeeper上面创建 节点了，默认不分组的情况下，服务结构如下：/dubbo/XXXXservice/consumers、providers</p><p>至此，dubbo的暴露基本上已经完成，开启了netty服务，注册了zookeeper的节点，就等着消费者连接上来使用了。</p><p>服务端Server启动，监听端口。（请求来到时，根据请求信息生成key，到缓存查找Exporter，就找到了Invoker，就可以完成调用。）</p><hr><h3 id="Dubbo-的整体架构设计有哪些分层"><a href="#Dubbo-的整体架构设计有哪些分层" class="headerlink" title="Dubbo 的整体架构设计有哪些分层?"></a>Dubbo 的整体架构设计有哪些分层?</h3><p><img alt="image-20200612152536404" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpjc4lhm1j30sb0l8dxf.jpg" class="lazyload"></p><ul><li>第一层：<strong>service层</strong>，接口层，给服务提供者和消费者来实现的</li><li>第二层：<strong>config层</strong>，配置层，主要是对dubbo进行各种配置的</li><li>第三层：<strong>proxy层</strong>，服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton</li><li>第四层：<strong>registry层</strong>，服务注册层，负责服务的注册与发现</li><li>第五层：<strong>cluster层</strong>，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li><li>第六层：<strong>monitor层</strong>，监控层，对rpc接口的调用次数和调用时间进行监控</li><li>第七层：<strong>protocol层</strong>，远程调用层，封装rpc调用</li><li>第八层：<strong>exchange层</strong>，信息交换层，封装请求响应模式，同步转异步</li><li>第九层：<strong>transport层</strong>，网络传输层，抽象mina和netty为统一接口</li><li>第十层：<strong>serialize层</strong>，数据序列化层，网络传输需要</li></ul><h3 id="Dubbo-有哪些注册中心？"><a href="#Dubbo-有哪些注册中心？" class="headerlink" title="Dubbo 有哪些注册中心？"></a>Dubbo 有哪些注册中心？</h3><ul><li>Multicast 注册中心：Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现,基于网络中组播传输实现。</li><li>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</li><li>Redis 注册中心：基于 Redis 实现，采用 key/map 存储，key 存储服务名和类型，map 中 key 存储服务 url，value 服务过期时间。基于 Redis 的发布/订阅模式通知数据变更。</li><li>Simple 注册中心。</li><li>推荐使用 Zookeeper 作为注册中心</li></ul><h2 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h2><h3 id="Dubbo-和-Spring-Cloud-有什么哪些区别？"><a href="#Dubbo-和-Spring-Cloud-有什么哪些区别？" class="headerlink" title="Dubbo 和 Spring Cloud 有什么哪些区别？"></a>Dubbo 和 Spring Cloud 有什么哪些区别？</h3><ul><li><p>两个没关联，如果硬要说区别，有以下几点。</p><p>1）通信方式不同</p><p>Dubbo 使用的是 RPC 通信，而 Spring Cloud 使用的是 HTTP RESTFul 方式。</p><p>2）组成部分不同</p><p><img alt="image-20200612160758890" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpkk2qjefj30if0dqq6j.jpg" class="lazyload"></p></li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="Dubbo集群提供了哪些负载均衡策略？"><a href="#Dubbo集群提供了哪些负载均衡策略？" class="headerlink" title="Dubbo集群提供了哪些负载均衡策略？"></a>Dubbo集群提供了哪些负载均衡策略？</h3><ul><li>Random LoadBalance: <code>随机</code>选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li><li>RoundRobin LoadBalance: <code>轮循</code>选取提供者策略，平均分布，但是存在请求累积的问题。</li><li>LeastActive LoadBalance: <code>最少活跃</code>调用策略，解决慢提供者接收更少的请求。</li><li>ConstantHash LoadBalance: <code>一致性 Hash</code> 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认为 Random 随机调用。</span><br></pre></td></tr></table></figure></div><h3 id="Dubbo的集群容错方案有哪些？6种"><a href="#Dubbo的集群容错方案有哪些？6种" class="headerlink" title="Dubbo的集群容错方案有哪些？6种"></a>Dubbo的集群容错方案有哪些？6种</h3><ul><li>Failfast Cluster：快速失败，只发起一次调用，<strong>失败立即报错</strong>。通常用于非幂等性的写操作，比如新增记录。</li><li>Failsafe Cluster：失败安全，出现异常时，<strong>直接忽略</strong>。通常用于<strong>写入审计日志</strong>等操作。</li><li>Failover Cluster：失败自动切换，当出现失败，<strong>重试</strong>其它服务器。通常用于读操作，但重试会带来更长延迟。</li><li>Failback Cluster：失败自动恢复，后台<strong>记录失败请求</strong>，<strong>定时重发</strong>。通常用于消息通知操作。</li><li>Forking Cluster：<strong>并行调用多个服务器，只要一个成功即返回</strong>。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。</li><li>Broadcast Cluster：<strong>广播调用</strong>所有消费者，逐个调用，<strong>任意一台报错则报错</strong> 。通常用于通知所有消费者更新缓存或日志等本地资源信息。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认的容错方案是 Failover Cluster。</span><br><span class="line">读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。</span><br><span class="line">写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。</span><br></pre></td></tr></table></figure></div><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Dubbo-如何优雅停机？"><a href="#Dubbo-如何优雅停机？" class="headerlink" title="Dubbo 如何优雅停机？"></a>Dubbo 如何优雅停机？</h3><ul><li>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</li></ul><h3 id="Dubbo-SPI-和-Java-SPI-区别？"><a href="#Dubbo-SPI-和-Java-SPI-区别？" class="headerlink" title="Dubbo SPI 和 Java SPI 区别？"></a>Dubbo SPI 和 Java SPI 区别？</h3><h4 id="SPI是什么"><a href="#SPI是什么" class="headerlink" title="SPI是什么"></a>SPI是什么</h4><p>SPI 全称为 Service Provider Interface，是一种<strong>服务发现机制</strong>。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。</p><p>整体机制图如下：</p><p><img alt="image-20200612154610708" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpjxeeqldj30wx0av0yt.jpg" class="lazyload"></p><p><code>总结：</code></p><p>SPI 全称为 Service Provider Interface，是一种<strong>服务提供接口</strong>。实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制，不需要改动Dubbo源码，动态根据配置文件加载需要的服务实现类。Dubbo在JDK SPI的基础上做了优化：</p><p>1、延迟加载，可以一次只加载自己想要加载的扩展实现。 </p><p>2、增加了对 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</p><ul><li><p>JDK SPI：</p><p>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了</p></li><li><p>DUBBO SPI：</p><p>1、对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</p><p>2、延迟加载，可以一次只加载自己想要加载的扩展实现。</p><p>3、增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</p><p>4、Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</p></li></ul><h3 id="服务调用是阻塞的吗？"><a href="#服务调用是阻塞的吗？" class="headerlink" title="服务调用是阻塞的吗？"></a>服务调用是阻塞的吗？</h3><ul><li>默认是阻塞的，可以异步调用，没有返回值的可以这么做。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</li></ul><h3 id="Dubbo-可以对结果进行缓存吗？"><a href="#Dubbo-可以对结果进行缓存吗？" class="headerlink" title="Dubbo 可以对结果进行缓存吗？"></a>Dubbo 可以对结果进行缓存吗？</h3><ul><li>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量&lt;dubbo:reference cache=“true” /&gt;</li><li>其实比普通的配置文件就多了一个标签 cache=“true”</li></ul><h3 id="Dubbo的管理控制台能做什么？"><a href="#Dubbo的管理控制台能做什么？" class="headerlink" title="Dubbo的管理控制台能做什么？"></a>Dubbo的管理控制台能做什么？</h3><p>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡等管理功能。</p><h2 id="在使用过程中都遇到了些什么问题？"><a href="#在使用过程中都遇到了些什么问题？" class="headerlink" title="在使用过程中都遇到了些什么问题？"></a>在使用过程中都遇到了些什么问题？</h2><p>1、Dubbo 的设计目的是为了满足高并发小数据量的 rpc 调用，在大数据量下的性能表现并不好，建议使用 rmi 或 webservice 协议。</p><p>2、dubbo 缺省会在启动时检查依赖是否可用，不可用就抛出异常，阻止 spring 初始化完成，check 属性默认为 true。</p><p>测试时有些服务不关心或者出现了循环依赖，将 check 设置为 false</p><h2 id="Dubbo-中的序列化"><a href="#Dubbo-中的序列化" class="headerlink" title="Dubbo 中的序列化"></a>Dubbo 中的序列化</h2><p>Dubbo 中支持的序列化方式：</p><ul><li>dubbo 序列化：阿里尚未开发成熟的高效 java 序列化实现，阿里不建议在生产环境使用它</li><li>hessian2 序列化：hessian 是一种跨语言的高效二进制序列化方式。但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式</li><li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自己实现的简单 json 库，但其实现都不是特别成熟，而且 json 这种文本序列化性能一般不如上面两种二进制序列化。</li><li>java 序列化：主要是采用 JDK 自带的 Java 序列化实现，性能很不理想。</li></ul><p>在通常情况下，这四种主要序列化方式的性能从上到下依次递减。对于 dubbo RPC 这种追求高性能的远程调用方式来说，实际上只有 1、2 两种高效序列化方式比较般配，而第 1 个 dubbo 序列化由于还不成熟，所以实际只剩下 2 可用，所以 dubbo RPC 默认采用 hessian2 序列化。</p><p>最近几年，各种新的高效序列化方式层出不穷，不断刷新序列化性能的上限，最典型的包括：</p><ul><li>专门针对 Java 语言的：Kryo，FST 等等</li><li>跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack 等等</li></ul><p>其中，Kryo 是一种非常成熟的序列化实现，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。而 FST 是一种较新的序列化实现，目前还缺乏足够多的成熟使用案例。</p><p><strong>在面向生产环境的应用中，目前更优先选择 Kryo。</strong></p><p>具体实现：</p><p><a href="https://www.jianshu.com/p/4317532e779a" target="_blank" rel="noopener">https://www.jianshu.com/p/4317532e779a</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
