<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Spring技术总结 | BestBear</title><meta name="description" content="Spring技术总结"><meta name="keywords" content="Spring"><meta name="author" content="简凡丶"><meta name="copyright" content="简凡丶"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring技术总结"><meta name="twitter:description" content="Spring技术总结"><meta name="twitter:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Spring技术总结"><meta property="og:url" content="http://yoursite.com/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="BestBear"><meta property="og:description" content="Spring技术总结"><meta property="og:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
<<<<<<< HEAD
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/"><link rel="prev" title="消息队列面试总结" href="http://yoursite.com/2020/05/19/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><link rel="next" title="网络相关基础" href="http://yoursite.com/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
=======
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/"><link rel="prev" title="消息队列面试总结" href="http://yoursite.com/2020/05/19/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><link rel="next" title="RocketMQ 削峰实战！" href="http://yoursite.com/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ%E5%89%8A%E5%B3%B0%E5%AE%9E%E6%88%98/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
>>>>>>> a0d224c9e48905812a4abe95535b10e8eedc3562
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BestBear</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/01/13/ViKAkpCRr5xde1j.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#写在前面的话"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">写在前面的话</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#引用"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">引用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#什么是-Spring-框架"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">什么是 Spring 框架?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#列举一些重要的Spring模块？"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">列举一些重要的Spring模块？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring-创建对象的三种方式"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Spring 创建对象的三种方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#通过构造方法创建"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">通过构造方法创建</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实例工厂"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">实例工厂</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#静态工厂"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">静态工厂</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#谈谈自己对于-Spring-IoC-和-AOP-的理解"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">谈谈自己对于 Spring IoC 和 AOP 的理解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#IoC"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">IoC</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AOP"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">AOP</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#动态代理原理"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">动态代理原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java-SDK代理与cglib代理比较"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">Java SDK代理与cglib代理比较</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring-中的-bean-的作用域有哪些"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Spring 中的 bean 的作用域有哪些?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#scope-属性"><span class="toc_mobile_items-number">8.0.0.1.</span> <span class="toc_mobile_items-text">scope 属性</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring-中的单例-bean-的线程安全问题了解吗？"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Spring 中的单例 bean 的线程安全问题了解吗？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring-中的-bean-生命周期（ioc加载过程）"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">Spring 中的 bean 生命周期（ioc加载过程）?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring循环依赖能否启动成功？"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">Spring循环依赖能否启动成功？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#三级缓存"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">三级缓存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单例Bean"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">单例Bean</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么Spring不能解决构造器的循环依赖？"><span class="toc_mobile_items-number">11.3.</span> <span class="toc_mobile_items-text">为什么Spring不能解决构造器的循环依赖？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么多实例Bean不能解决循环依赖？"><span class="toc_mobile_items-number">11.4.</span> <span class="toc_mobile_items-text">为什么多实例Bean不能解决循环依赖？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring-框架中用到了哪些设计模式？"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">Spring 框架中用到了哪些设计模式？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#将一个类声明为Spring的-bean-的注解有哪些"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">将一个类声明为Spring的 bean 的注解有哪些?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#AOP-1"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">AOP</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AOP-主要应用场景有："><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text">AOP 主要应用场景有：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#AOP使用哪种动态代理"><span class="toc_mobile_items-number">15.2.</span> <span class="toc_mobile_items-text">AOP使用哪种动态代理?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#jdk动态代理"><span class="toc_mobile_items-number">15.3.</span> <span class="toc_mobile_items-text">jdk动态代理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#动态代理与静态代理区别"><span class="toc_mobile_items-number">15.4.</span> <span class="toc_mobile_items-text">动态代理与静态代理区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CGLIB与JDK动态代理区别"><span class="toc_mobile_items-number">15.5.</span> <span class="toc_mobile_items-text">CGLIB与JDK动态代理区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#SpringMVC-工作原理了解吗"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text">SpringMVC 工作原理了解吗?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SpringMVC中重要组件"><span class="toc_mobile_items-number">16.1.</span> <span class="toc_mobile_items-text">SpringMVC中重要组件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SpringMVC请求流程"><span class="toc_mobile_items-number">16.2.</span> <span class="toc_mobile_items-text">SpringMVC请求流程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#介绍一下-SpringBootApplication注解"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text">介绍一下@SpringBootApplication注解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#SpringBoot-的自动配置是如何实现的"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text">SpringBoot 的自动配置是如何实现的?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#SpringBoot启动流程（敖丙）"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text">SpringBoot启动流程（敖丙）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text">参考</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#写在前面的话"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用"><span class="toc-number">2.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是-Spring-框架"><span class="toc-number">3.</span> <span class="toc-text">什么是 Spring 框架?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列举一些重要的Spring模块？"><span class="toc-number">4.</span> <span class="toc-text">列举一些重要的Spring模块？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-创建对象的三种方式"><span class="toc-number">5.</span> <span class="toc-text">Spring 创建对象的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过构造方法创建"><span class="toc-number">5.1.</span> <span class="toc-text">通过构造方法创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例工厂"><span class="toc-number">5.2.</span> <span class="toc-text">实例工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态工厂"><span class="toc-number">5.3.</span> <span class="toc-text">静态工厂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谈谈自己对于-Spring-IoC-和-AOP-的理解"><span class="toc-number">6.</span> <span class="toc-text">谈谈自己对于 Spring IoC 和 AOP 的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC"><span class="toc-number">6.1.</span> <span class="toc-text">IoC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">6.2.</span> <span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代理原理"><span class="toc-number">7.</span> <span class="toc-text">动态代理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-SDK代理与cglib代理比较"><span class="toc-number">7.1.</span> <span class="toc-text">Java SDK代理与cglib代理比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-中的-bean-的作用域有哪些"><span class="toc-number">8.</span> <span class="toc-text">Spring 中的 bean 的作用域有哪些?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#scope-属性"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">scope 属性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-中的单例-bean-的线程安全问题了解吗？"><span class="toc-number">9.</span> <span class="toc-text">Spring 中的单例 bean 的线程安全问题了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-中的-bean-生命周期（ioc加载过程）"><span class="toc-number">10.</span> <span class="toc-text">Spring 中的 bean 生命周期（ioc加载过程）?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring循环依赖能否启动成功？"><span class="toc-number">11.</span> <span class="toc-text">Spring循环依赖能否启动成功？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三级缓存"><span class="toc-number">11.1.</span> <span class="toc-text">三级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例Bean"><span class="toc-number">11.2.</span> <span class="toc-text">单例Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么Spring不能解决构造器的循环依赖？"><span class="toc-number">11.3.</span> <span class="toc-text">为什么Spring不能解决构造器的循环依赖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么多实例Bean不能解决循环依赖？"><span class="toc-number">11.4.</span> <span class="toc-text">为什么多实例Bean不能解决循环依赖？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？"><span class="toc-number">12.</span> <span class="toc-text">Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-框架中用到了哪些设计模式？"><span class="toc-number">13.</span> <span class="toc-text">Spring 框架中用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将一个类声明为Spring的-bean-的注解有哪些"><span class="toc-number">14.</span> <span class="toc-text">将一个类声明为Spring的 bean 的注解有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP-1"><span class="toc-number">15.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-主要应用场景有："><span class="toc-number">15.1.</span> <span class="toc-text">AOP 主要应用场景有：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP使用哪种动态代理"><span class="toc-number">15.2.</span> <span class="toc-text">AOP使用哪种动态代理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk动态代理"><span class="toc-number">15.3.</span> <span class="toc-text">jdk动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理与静态代理区别"><span class="toc-number">15.4.</span> <span class="toc-text">动态代理与静态代理区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGLIB与JDK动态代理区别"><span class="toc-number">15.5.</span> <span class="toc-text">CGLIB与JDK动态代理区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC-工作原理了解吗"><span class="toc-number">16.</span> <span class="toc-text">SpringMVC 工作原理了解吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC中重要组件"><span class="toc-number">16.1.</span> <span class="toc-text">SpringMVC中重要组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC请求流程"><span class="toc-number">16.2.</span> <span class="toc-text">SpringMVC请求流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍一下-SpringBootApplication注解"><span class="toc-number">17.</span> <span class="toc-text">介绍一下@SpringBootApplication注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot-的自动配置是如何实现的"><span class="toc-number">18.</span> <span class="toc-text">SpringBoot 的自动配置是如何实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot启动流程（敖丙）"><span class="toc-number">19.</span> <span class="toc-text">SpringBoot启动流程（敖丙）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">20.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Spring技术总结</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-05-12<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-11-09</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/Spring/">Spring</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 16 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>网上Java的资料零零散散，甚至有一些错误，作者希望能结合自己的实际开发经验和面试经验，对Spring知识体系进行系统梳理。</p>
<p>本文参考主要【引用】中的内容，并结合自己的日常积累，欢迎留言交流指正。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><p><strong>注：本文主要参考</strong></p>
</li>
<li><p>链接：<a href="https://www.jianshu.com/p/e1848e2aa7c3" target="_blank" rel="noopener">https://www.jianshu.com/p/e1848e2aa7c3</a></p>
</li>
</ul>
<h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h2><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：<a href="https://spring.io/。" target="_blank" rel="noopener">https://spring.io/。</a></p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p>
<ul>
<li>IOC/DI（控制反转，Dependency Injection，依赖注入）</li>
<li>AOP（Aspect Oriented Programming，面向切面编程）</li>
</ul>
<h2 id="列举一些重要的Spring模块？"><a href="#列举一些重要的Spring模块？" class="headerlink" title="列举一些重要的Spring模块？"></a>列举一些重要的Spring模块？</h2><p>下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img alt="image-20200512174528926" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gept5vphtlj30fe0b6tcu.jpg" class="lazyload"></p>
<ul>
<li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IOC 依赖注入功能。</li>
<li><strong>Spring Aspects</strong> ：该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向方面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h2 id="Spring-创建对象的三种方式"><a href="#Spring-创建对象的三种方式" class="headerlink" title="Spring 创建对象的三种方式"></a>Spring 创建对象的三种方式</h2><h3 id="通过构造方法创建"><a href="#通过构造方法创建" class="headerlink" title="通过构造方法创建"></a>通过构造方法创建</h3><p>无参构造创建:默认情况.</p>
<p>有参构造创建:需要明确配置</p>
<p>需要在类中提供有参构造方法</p>
<p>在 applicationContext.xml 中设置调用哪个构造方法创建对象</p>
<p>如果设定的条件匹配多个构造方法执行最后的构造方法</p>
<p> index : 参数的索引,从 0 开始</p>
<p>name: 参数名</p>
<p>type:类型(区分开关键字和封装类 int 和Integer)</p>
<p><img alt="&lt;bean id— &quot;peo&quot;  refi}l bean  String  value  &lt;constructor-arg index=&quot;O&quot; name= &quot;id&quot; type=&quot;int&quot;  value= &quot;123  &lt;constructor-arg &quot; name= &quot;name&quot;  type= &quot;java. lang.String &quot; value= &quot; " data-src="file:////Users/hepeitan/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/1F1E534F-4653-F642-94E2-2161574E0DB5.png" class="lazyload"></p>
<h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><p>工厂设计模式:帮助创建类对象.一个工厂可以生产多个对象.</p>
<p>实例工厂:需要先创建工厂,才能生产对象</p>
<p>实现步骤:必须要有一个实例工厂</p>
<p><img alt="mau  aldoad 3!lqnd  } ,AucnoeFldoad ssep 3!lqnd " data-src="file:////Users/hepeitan/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/A5CFC417-F152-684B-82FE-FF22186B2533.png" class="lazyload"></p>
<p>在 applicationContext.xml 中配置工厂对象和需要创建的对象</p>
<p><img alt="&lt; ea &quot;  class &quot;com.bjsxt.pojo.PeopLeFactory&quot;&gt;&lt;/—  &lt;bean  id— &quot;peol &quot;  factory-bean  &quot;factory &quot;  factory- method— &quot;newrnstance &quot; bean &gt; " data-src="file:////Users/hepeitan/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/029DC20C-769F-8D49-8739-3E4C68781972.png" class="lazyload"></p>
<h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><p>不需要创建工厂,快速创建对象.</p>
<p>实现步骤：</p>
<p>编写一个静态工厂(在方法上添加static)</p>
<p><img alt="mau  aldoad 311as 3!lqnd  } ,AucnoeFldoad ssep 3!lqnd " data-src="file:////Users/hepeitan/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/853A1076-8F63-9E46-BEE5-618B18F86FBB.png" class="lazyload"></p>
<p>在applicationContext.xml 中</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"peo2"</span> <span class="attr">class</span>=<span class="string">"com.bjsxt.pojo.PeopleFactory"</span> <span class="attr">factory-method</span>=<span class="string">"newInstance"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div>





<h2 id="谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="谈谈自己对于 Spring IoC 和 AOP 的理解"></a>谈谈自己对于 Spring IoC 和 AOP 的理解</h2><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p>
<p>IoC 完成的事情原先由程序员主动通过 new 实例化对象事情,转交给 Spring 负责. </p>
<p>IoC 最大的作用:<code>解耦</code>. 程序员不需要管理对象.解除了对象管理和程序员之间的耦合.</p>
<p>DI：当一个类(A)中需要依赖另一个类()对象时,把 B 赋值给 A 的过程就叫做依赖注入. </p>
<p><strong>Spring IOC的初始化过程：</strong> </p>
<p><img alt="image-20200512175046188" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1geptbathsuj30jo01gwek.jpg" class="lazyload"></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img alt="image-20200512202505951" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepxruoqm3j30jx09r76q.jpg" class="lazyload"></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="动态代理原理"><a href="#动态代理原理" class="headerlink" title="动态代理原理"></a>动态代理原理</h2><p>静态代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。</p>
<p>每一个类都需要创建代理对象会很麻烦，而动态代理就是在运行时通过反射机制动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为。</p>
<h3 id="Java-SDK代理与cglib代理比较"><a href="#Java-SDK代理与cglib代理比较" class="headerlink" title="Java SDK代理与cglib代理比较"></a>Java SDK代理与cglib代理比较</h3><p><code>JDK代理</code>面向的是一组接口，它为这些接口动态创建了一个实现类。</p>
<p><code>cglib代理</code>面向的是一个具体的类，它动态创建了一个新类，继承了该类，重写了其方法。</p>
<p><code>JDK代理</code>的是对象，需要先有一个实际对象，自定义的InvocationHandler引用该对象，然后创建一个代理类和代理对象，客户端访问的是代理对象，代理对象最后再调用实际对象的方法。</p>
<p><code>cglib代理</code>的是类，创建的对象只有一个。</p>
<p>如果目的都是为一个类的方法增强功能，Java SDK要求该类必须有接口，且只能处理接口中的方法，cglib没有这个限制。</p>
<h2 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h2><p>Spring定义了多种Bean作用域，可以基于这些作用域创建bean，包括：</p>
<ul>
<li><strong>单例</strong>（Singleton）：在整个应用中，只创建bean的一个实例。</li>
<li><strong>原型</strong>（Prototype）：多例,每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li>
<li><strong>会话</strong>（Session）：在Web应用中，为每个会话创建一个bean实例。</li>
<li><strong>请求</strong>（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li>
</ul>
<p>在代码里看起来是这样的：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIsBean</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></div>

<p>XML版本：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"BEANID"</span> <span class="attr">class</span> = <span class="string">"net.itxm.beans"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在默认情况下，Spring应用上下文中所有bean都是作为以<code>单例</code>（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。</p>
<p>在大多数情况下，单例bean是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p>
<h5 id="scope-属性"><a href="#scope-属性" class="headerlink" title="scope 属性"></a>scope 属性</h5><ol>
<li><bean>的属性</bean></li>
<li>作用:控制对象有效范围(单例,多例等)</li>
<li><bean>标签对应的对象默认是单例的.无论获取多少次,都是同一个对象</bean></li>
<li>scope 可取值</li>
</ol>
<ul>
<li>singleton 默认值,单例</li>
<li>prototype 多例,每次获取重新实例化</li>
<li>request 每次请求重新实例化</li>
<li>session      每个会话对象内,对象是单例的.</li>
<li>application      在application 对象内是单例</li>
<li>global    session  spring推 出 的 , 依 赖 于spring-webmvc-portle类似于session</li>
</ul>
<h2 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<ul>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中。</li>
</ul>
<h2 id="Spring-中的-bean-生命周期（ioc加载过程）"><a href="#Spring-中的-bean-生命周期（ioc加载过程）" class="headerlink" title="Spring 中的 bean 生命周期（ioc加载过程）?"></a>Spring 中的 bean 生命周期（ioc加载过程）?</h2><p>1、扫描Spring配置文件，根据标签的解析结果生成beanDefinition，并将所有的bd存放在map中。</p>
<p>2、遍历map，对beanDefinition进行validate校验，包括bean作用域、是不是懒加载的。</p>
<p>3、得到bean所对应的class对象，推断构造方法。</p>
<p>4、通过反射实例化这个对象</p>
<p>5、提前暴露一个Bean工厂将BeanFactory容器实例传入</p>
<p>6、填充属性–自动注入</p>
<p>7、Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean</p>
<ul>
<li>如果bean实现了<code>BeanNameAware</code>接口，Spring将bean的ID传递给<strong>setBean-Name()</strong>方法；</li>
<li>如果bean实现了<code>BeanFactoryAware</code>接口，Spring将调用<strong>setBeanFactory()</strong>方法，将BeanFactory容器实例传入；</li>
<li>如果bean实现了<code>ApplicationContextAware</code>接口，Spring将调用<strong>setApplicationContext()</strong>方法，将bean所在的应用上下文的引用传入进来；</li>
</ul>
<p>8、BeanPostProcessor：前置方法-aop</p>
<p>9、InitializingBean和init-method：执行我们自己定义的初始化方法</p>
<p>10、BeanPostProcessor：后置方法-aop</p>
<p>11、将Bean放到单例池中</p>
<p>12、使用</p>
<p>13、destroy：bean的销毁</p>
<h2 id="Spring循环依赖能否启动成功？"><a href="#Spring循环依赖能否启动成功？" class="headerlink" title="Spring循环依赖能否启动成功？"></a>Spring循环依赖能否启动成功？</h2><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a><strong>三级缓存</strong></h3><ul>
<li>Spring能够轻松的解决属性的循环依赖正式用到了三级缓存，在AbstractBeanFactory中有详细的注释。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**一级缓存，用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**二级缓存 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**三级缓存 存放 bean 工厂对象，用于解决循环依赖*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。</li>
<li>二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean</li>
<li>三级缓存：singletonFactories，三级缓存，存放实例化完成的Bean工厂。</li>
<li>创建bean的时候Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取，如果还是获取不到就从三级缓存singletonFactories中取（Bean调用构造函数进行实例化后，即使属性还未填充，就可以通过三级缓存向外提前暴露依赖的引用值（提前曝光），根据对象引用能定位到堆中的对象，其原理是基于Java的引用传递），取到后从三级缓存移动到了二级缓存完全初始化之后将自己放入到一级缓存中供其他使用。</li>
</ul>
<h3 id="单例Bean"><a href="#单例Bean" class="headerlink" title="单例Bean"></a>单例Bean</h3><p>可以<strong>启动成功</strong>，Spring利用三级缓存，在实例化一个bean的时候，是首先递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性。</p>
<h3 id="为什么Spring不能解决构造器的循环依赖？"><a href="#为什么Spring不能解决构造器的循环依赖？" class="headerlink" title="为什么Spring不能解决构造器的循环依赖？"></a>为什么Spring不能解决构造器的循环依赖？</h3><p>因为加入singletonFactories三级缓存的前提是执行了构造器，在Bean调用构造器实例化之前，一二三级缓存并没有Bean的任何相关信息，在实例化之后才放入三级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。</p>
<p><code>构造器循环依赖解决办法：</code>在构造函数中使用@Lazy注解延迟加载。在注入依赖时，先注入代理对象，当首次使用时再创建对象说明：一种互斥的关系而非层次递进的关系，故称为三个Map而非三级缓存的缘由 完成注入；</p>
<h3 id="为什么多实例Bean不能解决循环依赖？"><a href="#为什么多实例Bean不能解决循环依赖？" class="headerlink" title="为什么多实例Bean不能解决循环依赖？"></a>为什么多实例Bean不能解决循环依赖？</h3><p>多实例Bean是每次创建都会调用doGetBean方法，而不是去缓存里面找，根本没有使用一二三级缓存，肯定不能解决循环依赖。</p>
<h2 id="Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？"><a href="#Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？" class="headerlink" title="Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？"></a>Spring启动时，存在Id相同，但不同类的bean可以启动成功吗？</h2><p><a href="https://blog.csdn.net/zgmzyr/article/details/39380477" target="_blank" rel="noopener">https://blog.csdn.net/zgmzyr/article/details/39380477</a></p>
<p>spring启动时有id或name优先按id或name进行注入，没有按class进行注入</p>
<p>spring对<code>同一配置文件</code>中相同<strong>id或者name</strong>的两个或以上的bean时，做直接抛异常的处理，而对<code>不同配置文件</code>中相同id或者名称的bean，只会在打印日志级别为info的信息，信息内容大概为”Overriding bean definition for bean xxx : replacing xxx with beanDefinition “.</p>
<p>那么最终spring容器只会实例化后面的这个bean，后者将前者覆盖了。这种情况下，要排查问题很困难。</p>
<p>那么如何解决这个问题呢?靠程序员自律？绝对不定义重复名称的bean？我觉得这个是非常不靠谱的,因为项目依赖可能比较复杂,开发人员不尽相同.所以我认为只有通过在程序中引入一种报错机制才能解决这个问题。</p>
<p>上次在调试spring源代码时，无意中发现DefaultListableBeanFactory类有一个<code>allowBeanDefinitionOverriding</code>属性,其默认值为true.</p>
<p>想到只要将其值更改为false时就可能可以解决上面的问题，即存在id或者name相同的bean时，不是打印出相关信息，而是直接抛异常，这样就可以迫使开发人员必须解决id或者name重复的问题后才能成功启动容器。</p>
<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">《面试官:“谈谈Spring中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等</li>
<li><strong>装饰器模式</strong>： 依赖注入就需要使用BeanWrapper。</li>
<li><strong>策略模式</strong>： Bean的实例化的时候决定采用何种方式初始化bean实例</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。Advice（通知）的类型有：BeforeAdvice、AfterReturningAdvice、ThrowSadvice 等。每个类型 Advice（通知）都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。Spring 需要将每个 Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对 Advice 进行转换。</li>
<li>……</li>
</ul>
<h2 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些?"></a>将一个类声明为Spring的 bean 的注解有哪些?</h2><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code>注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于拿个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h2 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h2><h3 id="AOP-主要应用场景有："><a href="#AOP-主要应用场景有：" class="headerlink" title="AOP 主要应用场景有："></a><strong>AOP 主要应用场景有：</strong></h3><ul>
<li>记录日志</li>
<li>监控性能</li>
<li>权限控制</li>
<li>事务管理</li>
</ul>
<h3 id="AOP使用哪种动态代理"><a href="#AOP使用哪种动态代理" class="headerlink" title="AOP使用哪种动态代理?"></a><strong>AOP使用哪种动态代理?</strong></h3><ul>
<li>当bean的是实现中存在接口或者是Proxy的子类，—jdk动态代理；不存在接口，spring会采用CGLIB来生成代理对象；</li>
<li>JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。</li>
<li>Proxy 利用 InvocationHandler（定义横切逻辑） 接口动态创建 目标类的代理对象。</li>
</ul>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a><strong>jdk动态代理</strong></h3><ul>
<li>通过bind方法建立代理与真实对象关系，通过Proxy.newProxyInstance（target）生成代理对象</li>
<li>代理对象通过反射invoke方法实现调用真实对象的方法</li>
</ul>
<h3 id="动态代理与静态代理区别"><a href="#动态代理与静态代理区别" class="headerlink" title="动态代理与静态代理区别"></a><strong>动态代理与静态代理区别</strong></h3><ul>
<li>静态代理，程序运行前代理类的.class文件就存在了；</li>
<li>动态代理：在程序运行时利用反射动态创建代理对象&lt;复用性，易用性，更加集中都调用invoke&gt;</li>
</ul>
<h3 id="CGLIB与JDK动态代理区别"><a href="#CGLIB与JDK动态代理区别" class="headerlink" title="CGLIB与JDK动态代理区别"></a><strong>CGLIB与JDK动态代理区别</strong></h3><ul>
<li>Jdk必须提供接口才能使用；</li>
<li>CGLIB不需要，只要一个非抽象类就能实现动态代理</li>
</ul>
<h2 id="SpringMVC-工作原理了解吗"><a href="#SpringMVC-工作原理了解吗" class="headerlink" title="SpringMVC 工作原理了解吗?"></a>SpringMVC 工作原理了解吗?</h2><h3 id="SpringMVC中重要组件"><a href="#SpringMVC中重要组件" class="headerlink" title="SpringMVC中重要组件"></a>SpringMVC中重要组件</h3><ol>
<li>DispatcherServlet : 前端控制器,接收所有请求(如果配置@WebServlte(“/“)     不包含jsp) </li>
<li>HandlerMapping:     解析请求格式的.判断希望要执行哪个具体的方法. </li>
<li>HandlerAdapter: 负责调用具体的方法. </li>
<li>ViewResovler:视图解析器.解析结果,准备跳转到具体的物理视图</li>
</ol>
<h3 id="SpringMVC请求流程"><a href="#SpringMVC请求流程" class="headerlink" title="SpringMVC请求流程"></a>SpringMVC请求流程</h3><p><img alt="image-20200512213852945" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gepzwm3m0sj30sf0bxaf4.jpg" class="lazyload"></p>
<p><img alt="0shrwj.png" data-src="https://s1.ax1x.com/2020/10/10/0shrwj.png" class="lazyload"> </p>
<p>参考： </p>
<p><a href="https://www.cnblogs.com/sunniest/p/4555801.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunniest/p/4555801.html</a></p>
<h2 id="介绍一下-SpringBootApplication注解"><a href="#介绍一下-SpringBootApplication注解" class="headerlink" title="介绍一下@SpringBootApplication注解"></a>介绍一下@SpringBootApplication注解</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure;</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters &#x3D; &#123;</span><br><span class="line">		@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line">		@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line">package org.springframework.boot;</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看出大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>注解的集合。根据 SpringBoot官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的bean，注解默认会扫描该类所在的包下所有的类。</li>
<li><code>@Configuration</code>：允许在上下文中注册额外的bean或导入其他配置类</li>
</ul>
<h2 id="SpringBoot-的自动配置是如何实现的"><a href="#SpringBoot-的自动配置是如何实现的" class="headerlink" title="SpringBoot 的自动配置是如何实现的?"></a>SpringBoot 的自动配置是如何实现的?</h2><ul>
<li>@EnableAutoConfiguration找到META-INF/spring.factories（需要创建的bean在里面）配置文件</li>
<li>读取每个starter中的spring.factories文件，将配置的所有EnableAutoConﬁguration的值加入到了容器中；</li>
<li>根据Condition注解判断其中的类是否需要加载</li>
<li>将要加载的类通过Configration进行加载，利用@ConfigerationProperties注解，将配置文件中的信息加载进来。</li>
</ul>
<p><code>@EnableAutoConfiguration</code>是启动自动配置的关键，源码如下(建议自己打断点调试，走一遍基本的流程)：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>以WebSecurityEnablerConfiguration为例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(WebSecurityConfigurerAdapter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">name</span> </span>= BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityEnablerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>WebSecurityEnablerConfiguration</code>类中使用<code>@ConditionalOnBean</code>指定了容器中必须还有<code>WebSecurityConfigurerAdapter</code> 类或其实现类。所以，一般情况下 Spring Security 配置类都会去实现 <code>WebSecurityConfigurerAdapter</code>，这样自动将配置就完成了。</p>
<p>更多内容可以参考这篇文章：<a href="https://sylvanassun.github.io/2018/01/08/2018-01-08-spring_boot_auto_configure/" target="_blank" rel="noopener">https://sylvanassun.github.io/2018/01/08/2018-01-08-spring_boot_auto_configure/</a></p>
<h2 id="SpringBoot启动流程（敖丙）"><a href="#SpringBoot启动流程（敖丙）" class="headerlink" title="SpringBoot启动流程（敖丙）"></a>SpringBoot启动流程（敖丙）</h2><ul>
<li><p>new springApplication对象，利用spi机制加载applicationContextInitializer， applicationLister接口实例（META-INF/spring.factories）；</p>
</li>
<li><p>调run方法准备Environment，加载应用上下文（applicationContext），发布事件 很多通过lister实现</p>
</li>
<li><p>创建spring容器， refreshContext（） ，实现starter自动化配置，spring.factories文件加载， bean实例化</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Spring 技术内幕》</li>
<li><a href="http://www.cnblogs.com/wmyskxz/p/8820371.html" target="_blank" rel="noopener">http://www.cnblogs.com/wmyskxz/p/8820371.html</a></li>
<li><a href="https://www.journaldev.com/2696/spring-interview-questions-and-answers" target="_blank" rel="noopener">https://www.journaldev.com/2696/spring-interview-questions-and-answers</a></li>
<li><a href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/" target="_blank" rel="noopener">https://www.edureka.co/blog/interview-questions/spring-interview-questions/</a></li>
<li><a href="https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/" target="_blank" rel="noopener">https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/</a></li>
<li><a href="http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/" target="_blank" rel="noopener">http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/</a></li>
<li><a href="https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired" target="_blank" rel="noopener">https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired</a></li>
</ul>
<<<<<<< HEAD
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">简凡丶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/">http://yoursite.com/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">BestBear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring    </a></div><div class="post_share"><div class="social-share" data-image="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/19/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><img class="prev_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>消息队列面试总结</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"><img class="next_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>网络相关基础</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
=======
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">简凡丶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/">http://yoursite.com/2020/05/12/2.%20Spring/Spring%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">BestBear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring    </a></div><div class="post_share"><div class="social-share" data-image="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/19/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><img class="prev_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>消息队列面试总结</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ%E5%89%8A%E5%B3%B0%E5%AE%9E%E6%88%98/"><img class="next_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>RocketMQ 削峰实战！</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
>>>>>>> a0d224c9e48905812a4abe95535b10e8eedc3562
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'POlJROSsMvr6BdUPhPaqFdlj-gzGzoHsz',
  appKey:'JhPOeqEkpBUGVUNuYYxRCvUt',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 简凡丶</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.5,"jsonPath":"/live2d_models/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":30,"vOffset":20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":0.6,"opacityOnHover":0.2},"log":false});</script></body></html>