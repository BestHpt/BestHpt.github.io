<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Dubbo | BestBear</title><meta name="description" content="Dubbo"><meta name="keywords" content="Dubbo"><meta name="author" content="简凡丶"><meta name="copyright" content="简凡丶"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Dubbo"><meta name="twitter:description" content="Dubbo"><meta name="twitter:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Dubbo"><meta property="og:url" content="http://yoursite.com/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/"><meta property="og:site_name" content="BestBear"><meta property="og:description" content="Dubbo"><meta property="og:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/"><link rel="prev" title="策略设计模式干掉if else!" href="http://yoursite.com/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E5%90%88Spring%E6%9B%BF%E6%8D%A2ifelse/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BestBear</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/01/13/ViKAkpCRr5xde1j.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Dubbo"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Dubbo</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考链接"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">参考链接</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#基础知识"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">基础知识</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么要用-Dubbo？"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">为什么要用 Dubbo？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo-核心组件有哪些？"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">Dubbo 核心组件有哪些？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo-服务器注册与发现的流程？"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">Dubbo 服务器注册与发现的流程？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#说说-Dubbo-服务暴露的过程"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">说说 Dubbo 服务暴露的过程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#简易的暴露流程"><span class="toc_mobile_items-number">3.4.1.</span> <span class="toc_mobile_items-text">简易的暴露流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#结合源码"><span class="toc_mobile_items-number">3.4.2.</span> <span class="toc_mobile_items-text">结合源码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo-的整体架构设计有哪些分层"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">Dubbo 的整体架构设计有哪些分层?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo-有哪些注册中心？"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">Dubbo 有哪些注册中心？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分布式框架"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">分布式框架</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo-和-Spring-Cloud-有什么哪些区别？"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">Dubbo 和 Spring Cloud 有什么哪些区别？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#集群"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">集群</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo集群提供了哪些负载均衡策略？"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">Dubbo集群提供了哪些负载均衡策略？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo的集群容错方案有哪些？6种"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">Dubbo的集群容错方案有哪些？6种</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#其他"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">其他</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo-如何优雅停机？"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">Dubbo 如何优雅停机？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo-SPI-和-Java-SPI-区别？"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">Dubbo SPI 和 Java SPI 区别？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#SPI是什么"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">SPI是什么</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#服务调用是阻塞的吗？"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">服务调用是阻塞的吗？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo-可以对结果进行缓存吗？"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">Dubbo 可以对结果进行缓存吗？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Dubbo的管理控制台能做什么？"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text">Dubbo的管理控制台能做什么？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#在使用过程中都遇到了些什么问题？"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">在使用过程中都遇到了些什么问题？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Dubbo-中的序列化"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Dubbo 中的序列化</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo"><span class="toc-number">1.</span> <span class="toc-text">Dubbo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">2.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">3.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用-Dubbo？"><span class="toc-number">3.1.</span> <span class="toc-text">为什么要用 Dubbo？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-核心组件有哪些？"><span class="toc-number">3.2.</span> <span class="toc-text">Dubbo 核心组件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-服务器注册与发现的流程？"><span class="toc-number">3.3.</span> <span class="toc-text">Dubbo 服务器注册与发现的流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说说-Dubbo-服务暴露的过程"><span class="toc-number">3.4.</span> <span class="toc-text">说说 Dubbo 服务暴露的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简易的暴露流程"><span class="toc-number">3.4.1.</span> <span class="toc-text">简易的暴露流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结合源码"><span class="toc-number">3.4.2.</span> <span class="toc-text">结合源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-的整体架构设计有哪些分层"><span class="toc-number">3.5.</span> <span class="toc-text">Dubbo 的整体架构设计有哪些分层?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-有哪些注册中心？"><span class="toc-number">3.6.</span> <span class="toc-text">Dubbo 有哪些注册中心？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式框架"><span class="toc-number">4.</span> <span class="toc-text">分布式框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-和-Spring-Cloud-有什么哪些区别？"><span class="toc-number">4.1.</span> <span class="toc-text">Dubbo 和 Spring Cloud 有什么哪些区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集群"><span class="toc-number">5.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo集群提供了哪些负载均衡策略？"><span class="toc-number">5.1.</span> <span class="toc-text">Dubbo集群提供了哪些负载均衡策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo的集群容错方案有哪些？6种"><span class="toc-number">5.2.</span> <span class="toc-text">Dubbo的集群容错方案有哪些？6种</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">6.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-如何优雅停机？"><span class="toc-number">6.1.</span> <span class="toc-text">Dubbo 如何优雅停机？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-SPI-和-Java-SPI-区别？"><span class="toc-number">6.2.</span> <span class="toc-text">Dubbo SPI 和 Java SPI 区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SPI是什么"><span class="toc-number">6.2.1.</span> <span class="toc-text">SPI是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务调用是阻塞的吗？"><span class="toc-number">6.3.</span> <span class="toc-text">服务调用是阻塞的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo-可以对结果进行缓存吗？"><span class="toc-number">6.4.</span> <span class="toc-text">Dubbo 可以对结果进行缓存吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dubbo的管理控制台能做什么？"><span class="toc-number">6.5.</span> <span class="toc-text">Dubbo的管理控制台能做什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在使用过程中都遇到了些什么问题？"><span class="toc-number">7.</span> <span class="toc-text">在使用过程中都遇到了些什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-中的序列化"><span class="toc-number">8.</span> <span class="toc-text">Dubbo 中的序列化</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Dubbo</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-01-15<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-10-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.7k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 21 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/PdWRHgm83XwPYP08KnkIsw" target="_blank" rel="noopener">dubbo面试题</a></p>
</li>
<li><p><a href="https://juejin.im/post/5e9591dee51d4546cf7785ca?utm_source=gold_browser_extension" target="_blank" rel="noopener">分布式相关面试题</a></p>
</li>
<li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/dubbo.md" target="_blank" rel="noopener">Dubbo 总结：关于 Dubbo 的重要知识点</a></p>
</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="为什么要用-Dubbo？"><a href="#为什么要用-Dubbo？" class="headerlink" title="为什么要用 Dubbo？"></a>为什么要用 Dubbo？</h3><ul>
<li>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架就出现了，Dubbo 也就这样产生了。</li>
</ul>
<h3 id="Dubbo-核心组件有哪些？"><a href="#Dubbo-核心组件有哪些？" class="headerlink" title="Dubbo 核心组件有哪些？"></a>Dubbo 核心组件有哪些？</h3><p><img alt="image-20200612152236892" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpj8vnukjj30sg0lr0wx.jpg" class="lazyload"></p>
<ul>
<li>Provider：暴露服务的服务提供方</li>
<li>Consumer：调用远程服务消费方</li>
<li>Registry：服务注册与发现注册中心</li>
<li>Monitor：监控中心和访问调用统计</li>
<li>Container：服务运行容器</li>
</ul>
<h3 id="Dubbo-服务器注册与发现的流程？"><a href="#Dubbo-服务器注册与发现的流程？" class="headerlink" title="Dubbo 服务器注册与发现的流程？"></a>Dubbo 服务器注册与发现的流程？</h3><ul>
<li>服务容器Container负责启动，加载，运行服务提供者。</li>
<li>服务提供者Provider在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者Consumer在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心Registry返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者Consumer和提供者Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。</li>
</ul>
<h3 id="说说-Dubbo-服务暴露的过程"><a href="#说说-Dubbo-服务暴露的过程" class="headerlink" title="说说 Dubbo 服务暴露的过程"></a>说说 Dubbo 服务暴露的过程</h3><p>dubbo采用的nio异步的通信，通信协议默认为 netty,当然也可以选择 mina,grizzy。在服务端（provider）在启动时主要是开启netty监听，在zookeeper上注册服务节点，处理消费者请求，返回处理后的消息给消费者，消费者使用服务时主要是订阅服务的节点，监听zookeeper节点目录，服务端的变化时zookeeper会推送给消费者，消费者重新缓存服务地址等。服务者、消费者、zookeeper三者之间都是长连接。</p>
<hr>
<h4 id="简易的暴露流程"><a href="#简易的暴露流程" class="headerlink" title="简易的暴露流程"></a>简易的暴露流程</h4><ol>
<li><p>Spring将dubbo标签解析，注入到ServiceConfig属性中</p>
</li>
<li><p>服务暴露的入口是：<code>ServiceConfig</code>的<code>export</code> 方法，里面判断是否延迟暴露，最终调用<code>doExport</code></p>
</li>
<li><p><code>doExport</code>会对解析完的配置再做一次检查，所有的检查通过之后，会调用 <code>doExportUrls</code> 方法，因为dubbo支持多通信协议时，都进行暴露，里面调用<code>doExportUrlsFor1Protocol</code></p>
</li>
<li><p><code>doExportUrlsFor1Protocol</code>中主要将所有的配置转化成map，然后将map转化成dubbo的统一URL，最终暴露的dubbo服务也就是这个统一的url，这个url也会注册到zookeeper的节点上。然后将所有服务的实现封装成一个<code>invoker</code>，并缓存起来，缓存里使用Invoker的url作为key。代码核心暴露的一行代码为：<strong>protocol.export(invoker);</strong> </p>
</li>
<li><p><code>RegistryProtocol.exprot</code>主要做两件事情：1、开启netty服务端并监听  。2、创建zookeeper服务临时节点。</p>
</li>
<li><p>启动注册是调用doRegister方法，不同协议重写了此方法。其实从上面已经可以看到 在zookeeper上面创建 节点了，默认不分组的情况下，服务结构如下：/dubbo/XXXXservice/consumers、providers<img alt="image-20200612172041457" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpmnqvwh9j30et03h0sz.jpg" class="lazyload"></p>
</li>
<li><p>服务端Server启动，监听端口。（请求来到时，根据请求信息生成key，到缓存查找Exporter，就找到了Invoker，就可以完成调用。）</p>
</li>
</ol>
<h4 id="结合源码"><a href="#结合源码" class="headerlink" title="结合源码"></a>结合源码</h4><p>下面看dubbo源码来看服务暴露的过程，服务暴露的入口为：<code>com.alibaba.dubbo.config.ServiceConfig</code>#<code>export</code> 方法，代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否延时暴露</span></span><br><span class="line"><span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(delay);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      doExport();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">  thread.setName(<span class="string">"DelayExportServiceThread"</span>);</span><br><span class="line">  thread.start();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//不延时暴露，则直接暴露</span></span><br><span class="line">  doExport();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>上在代码无论是延时暴露或直接暴露调用的方法是：<code>doExport()</code>,doExport会对解析完的配置再做一次检查，核心代码大家可以查看dubbo的源码，下面列出一小部分</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     检查默认设置,如果xml中没有配置&lt;dubbo:provider</span></span><br><span class="line"><span class="comment">     主要是从系统环境变量中寻找是否有相应的provider的配置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> checkDefault();</span><br><span class="line"> <span class="comment">//下面设置的内容如果没有配置&lt;dubbo:provider时基本上都是Null</span></span><br><span class="line"> <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">         application = provider.getApplication();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">         registries = provider.getRegistries();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">         monitor = provider.getMonitor();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">         protocols = provider.getProtocols();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//registries一般都会配置</span></span><br><span class="line">     <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">         registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">         monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//application一般也会配置</span></span><br><span class="line">     <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">         registries = application.getRegistries();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">         monitor = application.getMonitor();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//是否泛化调用</span></span><br><span class="line"> <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">     interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">         generic = Boolean.TRUE.toString();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                 .getContextClassLoader());</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         检查即将暴露的接口的方法配置,检查方法是否在接口中存在</span></span><br><span class="line"><span class="comment">         一般不会配置所以一般情况下methods为null</span></span><br><span class="line"><span class="comment">         &lt;dubbo:service  &gt; &lt;dubbo:method /&gt; &lt;/dubbo:serivce&gt;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         检查接口的引用不为空,并且必须实现的是要暴露的接口</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     checkRef();</span><br><span class="line">     generic = Boolean.FALSE.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>



<p>所有的检查通过之后，会调用 ：<code>com.alibaba.dubbo.config.ServiceConfig</code>#<code>doExportUrls</code> 方法，因为dubbo支持多通信协议时，都进行暴露，所以在代码中可以看到</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    将注册协议转化成url</span></span><br><span class="line"><span class="comment">    registry://45.119.68.23:2181/com.alibaba.dubbo.registry.RegistryService?</span></span><br><span class="line"><span class="comment">    application=test-dubbo&amp;dubbo=2.5.3&amp;pid=7648&amp;registry=zookeeper×tamp=1462349748801</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//配置多通信协议时，都进行暴露</span></span><br><span class="line"><span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">    doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><code>doExportUrlsFor1Protocol</code>中主要将所有的配置转化成map，然后将map转化成dubbo的统一URL，最终暴露的dubbo服务也就是这个统一的url，这个url也会注册到zookeeper的节点上，部分代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将不为null的配置对象中的属性设置到 map 中</span></span><br><span class="line"><span class="comment">	即将 xml 配置文件中的配置设置的值全转化成为map</span></span><br><span class="line"><span class="comment">	&#123;side=provider, application=alijk-dubbo, accepts=1000,</span></span><br><span class="line"><span class="comment">		dubbo=2.5.3, threads=100, pid=7236, interface=cn.eoncloud.account.sdk.export.AccountService,</span></span><br><span class="line"><span class="comment">		threadpool=fixed, version=1.0.0, timeout=500, anyhost=true, timestamp=1462347843960&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appendParameters(map, application);</span><br><span class="line">appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">appendParameters(map, protocolConfig);</span><br><span class="line">appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	将配置信息转化成 url ,主要根据之前map里的数据组装成url</span></span><br><span class="line"><span class="comment">	调用 URL#buildString方法</span></span><br><span class="line"><span class="comment">	dubbo://10.6.13.137:9998/cn.eoncloud.account.sdk.export.AccountService</span></span><br><span class="line"><span class="comment">	?accepts=1000&amp;anyhost=true&amp;application=test-dubbo&amp;dubbo=2.5.3</span></span><br><span class="line"><span class="comment">	&amp;interface=cn.eoncloud.account.sdk.export.AccountService</span></span><br><span class="line"><span class="comment">	&amp;methods=getAccountName,getAllTest&amp;pid=7236&amp;revision=1.0.0&amp;side=provider</span></span><br><span class="line"><span class="comment">	&amp;threadpool=fixed&amp;threads=100&amp;timeout=500×tamp=1462347843960&amp;version=1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">		.<span class="title">hasExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">	url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">			.<span class="title">getExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>()).<span class="title">getConfigurator</span>(<span class="title">url</span>).<span class="title">configure</span>(<span class="title">url</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</span><br><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line"><span class="comment">//com.alibaba.dubbo.registry.integration.RegistryProtocol#export 即将进行暴露</span></span><br><span class="line">Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br></pre></td></tr></table></figure></div>



<p>上面的代码核心暴露的一行代码为：protocol.export(invoker); 这个protocol的值为：RegistryProtocol，也就是暴露会跳到：RegistryProtocol.exprot中去处理，RegistryProtocol.exprot主要做两件事情：1、开启netty服务端  。2、创建zookeeper服务节点。下面来看RegistryProtocol.export 方法，代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">//export invoker doLocalExport调用dubboProtocol.export开启netty服务监听</span></span><br><span class="line">        <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">        <span class="comment">//registry provider</span></span><br><span class="line">        <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">        <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">        <span class="comment">//调用zodoRegister的doRegister 创建zookeeper的服务节点</span></span><br><span class="line">        registry.register(registedProviderUrl);</span><br><span class="line">        <span class="comment">// 订阅override数据</span></span><br><span class="line">        <span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span></span><br><span class="line">        <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">        <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl);</span><br><span class="line">        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">        <span class="comment">//订阅</span></span><br><span class="line">        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">        <span class="comment">//保证每次export都返回一个新的exporter实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exporter&lt;T&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            	<span class="keyword">try</span> &#123;</span><br><span class="line">            		exporter.unexport();</span><br><span class="line">            	&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                	logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	registry.unregister(registedProviderUrl);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                	logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                	overrideListeners.remove(overrideSubscribeUrl);</span><br><span class="line">                	registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                	logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<p>上面的代码里有一段特别重要，关键性的代码在doLocalExport中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line"><span class="comment">//此处protol为dubboProtocol</span></span><br><span class="line">exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;)protocol.export(invokerDelegete), originInvoker);</span><br></pre></td></tr></table></figure></div>



<p>从上面的代码中可以看到会调用dubboProtocol的export对服务进行暴露，这个export最终目的就是开启netty的监听，下面来看dubbo是如何一步一步开启netty的</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find server. ip:port</span></span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        <span class="comment">//client 也可以暴露一个只有server可以调用的服务。</span></span><br><span class="line">        <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">        	ExchangeServer server = serverMap.get(key);</span><br><span class="line">        	<span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//创建 Server</span></span><br><span class="line">        		serverMap.put(key, createServer(url));</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">//server支持reset,配合override功能使用</span></span><br><span class="line">        		server.reset(url);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认开启server关闭时发送readonly事件</span></span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">    <span class="comment">//默认开启heartbeat</span></span><br><span class="line">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line">    <span class="comment">//默认使用netty</span></span><br><span class="line">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; ! ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">str</span>))</span></span><br><span class="line">        throw new RpcException("Unsupported server type: " + str + ", url: " + url);</span><br><span class="line">    <span class="comment">//默认使用dubbo协议编码</span></span><br><span class="line">    url = url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME);</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//HeaderExchangeServer 在此处已经开启了Netty Server 进行监听</span></span><br><span class="line">        server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + url + <span class="string">") "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的代码中：Exchangers.bind(url, requestHandler)  默认为：HeaderExchanger.bind()</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">//Transporters默认为NettyTransporter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<p>代码运行到这里可以看到传输方式了，dubbo默认采用的通信方式为 NettyTransporter ，再来看NettyTransporter.bind方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"netty"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>已经能看到NettyServer了，dubbo在暴露服务最终开启的netty服务监听，监听消费者发送的请求，通过反射调用方法得到结果通过 tcp/ip 网络传输返回给消费者。再进入到NettyServer中我们就能看到非常传统的开启Netty服务的代码了</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">        ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">//最后一个参数为 NIO 最大工作线程数</span></span><br><span class="line">        ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">        <span class="comment">//netty server 启动器</span></span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    <span class="comment">// https://issues.jboss.org/browse/NETTY-365</span></span><br><span class="line">    <span class="comment">// https://issues.jboss.org/browse/NETTY-379</span></span><br><span class="line">    <span class="comment">// final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));</span></span><br><span class="line">    bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec() ,getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            <span class="comment">/*int idleTimeout = getIdleTimeout();</span></span><br><span class="line"><span class="comment">            if (idleTimeout &gt; 10000) &#123;</span></span><br><span class="line"><span class="comment">                pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">            <span class="keyword">return</span> pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建一个绑定到指定地址的新通道，也就是绑定IP、端口供客户端连接</span></span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面的代码执行完成后，netty的服务端就已经开启了，可以接收客户端的连接了，但客户端连接上来要怎么处理呢？消息接收、发送怎么处理呢？所有的处理都在上面代码的 NettyHandler类中，Nettyhandler继承了Netty包中的的SimpleChannelHandler</p>
<p>从前面知道,开启netty服务是在<code>RegistryProtocol.export</code> 的 <code>doLocalExport</code> 中，在开启了netty服务后，就是在zookeeper上注册服务节点了，消费者在消费服务时会根据消费的接口名找到对应的<strong>zookeeper节点目录</strong>，对目录进行监听，接收推送</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//registry provider</span></span><br><span class="line"><span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line"><span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line"><span class="comment">//调用zodoRegister的doRegister 创建zookeeper的服务节点</span></span><br><span class="line">registry.register(registedProviderUrl);</span><br><span class="line"><span class="comment">// 订阅override数据</span></span><br><span class="line"><span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span></span><br><span class="line"><span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line"><span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl);</span><br><span class="line">overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line">registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br></pre></td></tr></table></figure></div>

<p>dubbo服务在zookeeper上的节点注册是：<code>com.alibaba.dubbo.registry.support.FailbackRegistry</code>#<code>register</code></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.register(url);</span><br><span class="line">        failedRegistered.remove(url);</span><br><span class="line">        failedUnregistered.remove(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 向服务器端发送注册请求</span></span><br><span class="line">            doRegister(url);</span><br></pre></td></tr></table></figure></div>

<p>因为doRegister是一个抽象的方法，查看他的实现可以看到如下图：</p>
<p><img alt="image-20200612170609349" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpm8lvqxcj30rx057aaz.jpg" class="lazyload"></p>
<p>从上图可以看到doRegister实现有 dubbo、redis、zookeeper，这也是在我们配置时经常看到的 注册协议的配置 ，最为常用的就是 zookeeper了，所以再看ZookeeperRegistry的代码，看他的doRegistry干什么了如下</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>其实从上面已经可以看到 在zookeeper上面创建 节点了，默认不分组的情况下，服务结构如下：/dubbo/XXXXservice/consumers、providers</p>
<p>至此，dubbo的暴露基本上已经完成，开启了netty服务，注册了zookeeper的节点，就等着消费者连接上来使用了。</p>
<p>服务端Server启动，监听端口。（请求来到时，根据请求信息生成key，到缓存查找Exporter，就找到了Invoker，就可以完成调用。）</p>
<hr>
<h3 id="Dubbo-的整体架构设计有哪些分层"><a href="#Dubbo-的整体架构设计有哪些分层" class="headerlink" title="Dubbo 的整体架构设计有哪些分层?"></a>Dubbo 的整体架构设计有哪些分层?</h3><p><img alt="image-20200612152536404" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpjc4lhm1j30sb0l8dxf.jpg" class="lazyload"></p>
<ul>
<li>第一层：<strong>service层</strong>，接口层，给服务提供者和消费者来实现的</li>
<li>第二层：<strong>config层</strong>，配置层，主要是对dubbo进行各种配置的</li>
<li>第三层：<strong>proxy层</strong>，服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton</li>
<li>第四层：<strong>registry层</strong>，服务注册层，负责服务的注册与发现</li>
<li>第五层：<strong>cluster层</strong>，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li>
<li>第六层：<strong>monitor层</strong>，监控层，对rpc接口的调用次数和调用时间进行监控</li>
<li>第七层：<strong>protocol层</strong>，远程调用层，封装rpc调用</li>
<li>第八层：<strong>exchange层</strong>，信息交换层，封装请求响应模式，同步转异步</li>
<li>第九层：<strong>transport层</strong>，网络传输层，抽象mina和netty为统一接口</li>
<li>第十层：<strong>serialize层</strong>，数据序列化层，网络传输需要</li>
</ul>
<h3 id="Dubbo-有哪些注册中心？"><a href="#Dubbo-有哪些注册中心？" class="headerlink" title="Dubbo 有哪些注册中心？"></a>Dubbo 有哪些注册中心？</h3><ul>
<li>Multicast 注册中心：Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现,基于网络中组播传输实现。</li>
<li>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</li>
<li>Redis 注册中心：基于 Redis 实现，采用 key/map 存储，key 存储服务名和类型，map 中 key 存储服务 url，value 服务过期时间。基于 Redis 的发布/订阅模式通知数据变更。</li>
<li>Simple 注册中心。</li>
<li>推荐使用 Zookeeper 作为注册中心</li>
</ul>
<h2 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h2><h3 id="Dubbo-和-Spring-Cloud-有什么哪些区别？"><a href="#Dubbo-和-Spring-Cloud-有什么哪些区别？" class="headerlink" title="Dubbo 和 Spring Cloud 有什么哪些区别？"></a>Dubbo 和 Spring Cloud 有什么哪些区别？</h3><ul>
<li><p>两个没关联，如果硬要说区别，有以下几点。</p>
<p>1）通信方式不同</p>
<p>Dubbo 使用的是 RPC 通信，而 Spring Cloud 使用的是 HTTP RESTFul 方式。</p>
<p>2）组成部分不同</p>
<p><img alt="image-20200612160758890" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpkk2qjefj30if0dqq6j.jpg" class="lazyload"></p>
</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="Dubbo集群提供了哪些负载均衡策略？"><a href="#Dubbo集群提供了哪些负载均衡策略？" class="headerlink" title="Dubbo集群提供了哪些负载均衡策略？"></a>Dubbo集群提供了哪些负载均衡策略？</h3><ul>
<li>Random LoadBalance: <code>随机</code>选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li>
<li>RoundRobin LoadBalance: <code>轮循</code>选取提供者策略，平均分布，但是存在请求累积的问题。</li>
<li>LeastActive LoadBalance: <code>最少活跃</code>调用策略，解决慢提供者接收更少的请求。</li>
<li>ConstantHash LoadBalance: <code>一致性 Hash</code> 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认为 Random 随机调用。</span><br></pre></td></tr></table></figure></div>



<h3 id="Dubbo的集群容错方案有哪些？6种"><a href="#Dubbo的集群容错方案有哪些？6种" class="headerlink" title="Dubbo的集群容错方案有哪些？6种"></a>Dubbo的集群容错方案有哪些？6种</h3><ul>
<li>Failfast Cluster：快速失败，只发起一次调用，<strong>失败立即报错</strong>。通常用于非幂等性的写操作，比如新增记录。</li>
<li>Failsafe Cluster：失败安全，出现异常时，<strong>直接忽略</strong>。通常用于<strong>写入审计日志</strong>等操作。</li>
<li>Failover Cluster：失败自动切换，当出现失败，<strong>重试</strong>其它服务器。通常用于读操作，但重试会带来更长延迟。</li>
<li>Failback Cluster：失败自动恢复，后台<strong>记录失败请求</strong>，<strong>定时重发</strong>。通常用于消息通知操作。</li>
<li>Forking Cluster：<strong>并行调用多个服务器，只要一个成功即返回</strong>。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。</li>
<li>Broadcast Cluster：<strong>广播调用</strong>所有消费者，逐个调用，<strong>任意一台报错则报错</strong> 。通常用于通知所有消费者更新缓存或日志等本地资源信息。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认的容错方案是 Failover Cluster。</span><br><span class="line">读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。</span><br><span class="line">写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。</span><br></pre></td></tr></table></figure></div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Dubbo-如何优雅停机？"><a href="#Dubbo-如何优雅停机？" class="headerlink" title="Dubbo 如何优雅停机？"></a>Dubbo 如何优雅停机？</h3><ul>
<li>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</li>
</ul>
<h3 id="Dubbo-SPI-和-Java-SPI-区别？"><a href="#Dubbo-SPI-和-Java-SPI-区别？" class="headerlink" title="Dubbo SPI 和 Java SPI 区别？"></a>Dubbo SPI 和 Java SPI 区别？</h3><h4 id="SPI是什么"><a href="#SPI是什么" class="headerlink" title="SPI是什么"></a>SPI是什么</h4><p>SPI 全称为 Service Provider Interface，是一种<strong>服务发现机制</strong>。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。</p>
<p>整体机制图如下：</p>
<p><img alt="image-20200612154610708" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpjxeeqldj30wx0av0yt.jpg" class="lazyload"></p>
<p><code>总结：</code></p>
<p>SPI 全称为 Service Provider Interface，是一种<strong>服务提供接口</strong>。实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制，不需要改动Dubbo源码，动态根据配置文件加载需要的服务实现类。Dubbo在JDK SPI的基础上做了优化：</p>
<p>1、延迟加载，可以一次只加载自己想要加载的扩展实现。 </p>
<p>2、增加了对 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</p>
<ul>
<li><p>JDK SPI：</p>
<p>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了</p>
</li>
<li><p>DUBBO SPI：</p>
<p>1、对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</p>
<p>2、延迟加载，可以一次只加载自己想要加载的扩展实现。</p>
<p>3、增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</p>
<p>4、Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</p>
</li>
</ul>
<h3 id="服务调用是阻塞的吗？"><a href="#服务调用是阻塞的吗？" class="headerlink" title="服务调用是阻塞的吗？"></a>服务调用是阻塞的吗？</h3><ul>
<li>默认是阻塞的，可以异步调用，没有返回值的可以这么做。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</li>
</ul>
<h3 id="Dubbo-可以对结果进行缓存吗？"><a href="#Dubbo-可以对结果进行缓存吗？" class="headerlink" title="Dubbo 可以对结果进行缓存吗？"></a>Dubbo 可以对结果进行缓存吗？</h3><ul>
<li>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量&lt;dubbo:reference cache=“true” /&gt;</li>
<li>其实比普通的配置文件就多了一个标签 cache=“true”</li>
</ul>
<h3 id="Dubbo的管理控制台能做什么？"><a href="#Dubbo的管理控制台能做什么？" class="headerlink" title="Dubbo的管理控制台能做什么？"></a>Dubbo的管理控制台能做什么？</h3><p>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡等管理功能。</p>
<h2 id="在使用过程中都遇到了些什么问题？"><a href="#在使用过程中都遇到了些什么问题？" class="headerlink" title="在使用过程中都遇到了些什么问题？"></a>在使用过程中都遇到了些什么问题？</h2><p>1、Dubbo 的设计目的是为了满足高并发小数据量的 rpc 调用，在大数据量下的性能表现并不好，建议使用 rmi 或 webservice 协议。</p>
<p>2、dubbo 缺省会在启动时检查依赖是否可用，不可用就抛出异常，阻止 spring 初始化完成，check 属性默认为 true。</p>
<p>测试时有些服务不关心或者出现了循环依赖，将 check 设置为 false</p>
<h2 id="Dubbo-中的序列化"><a href="#Dubbo-中的序列化" class="headerlink" title="Dubbo 中的序列化"></a>Dubbo 中的序列化</h2><p>Dubbo 中支持的序列化方式：</p>
<ul>
<li>dubbo 序列化：阿里尚未开发成熟的高效 java 序列化实现，阿里不建议在生产环境使用它</li>
<li>hessian2 序列化：hessian 是一种跨语言的高效二进制序列化方式。但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式</li>
<li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自己实现的简单 json 库，但其实现都不是特别成熟，而且 json 这种文本序列化性能一般不如上面两种二进制序列化。</li>
<li>java 序列化：主要是采用 JDK 自带的 Java 序列化实现，性能很不理想。</li>
</ul>
<p>在通常情况下，这四种主要序列化方式的性能从上到下依次递减。对于 dubbo RPC 这种追求高性能的远程调用方式来说，实际上只有 1、2 两种高效序列化方式比较般配，而第 1 个 dubbo 序列化由于还不成熟，所以实际只剩下 2 可用，所以 dubbo RPC 默认采用 hessian2 序列化。</p>
<p>最近几年，各种新的高效序列化方式层出不穷，不断刷新序列化性能的上限，最典型的包括：</p>
<ul>
<li>专门针对 Java 语言的：Kryo，FST 等等</li>
<li>跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack 等等</li>
</ul>
<p>其中，Kryo 是一种非常成熟的序列化实现，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。而 FST 是一种较新的序列化实现，目前还缺乏足够多的成熟使用案例。</p>
<p><strong>在面向生产环境的应用中，目前更优先选择 Kryo。</strong></p>
<p>具体实现：</p>
<p><a href="https://www.jianshu.com/p/4317532e779a" target="_blank" rel="noopener">https://www.jianshu.com/p/4317532e779a</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">简凡丶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/">http://yoursite.com/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">BestBear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dubbo/">Dubbo    </a></div><div class="post_share"><div class="social-share" data-image="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-full"><a href="/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E5%90%88Spring%E6%9B%BF%E6%8D%A2ifelse/"><img class="prev_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>策略设计模式干掉if else!</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'POlJROSsMvr6BdUPhPaqFdlj-gzGzoHsz',
  appKey:'JhPOeqEkpBUGVUNuYYxRCvUt',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 简凡丶</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.5,"jsonPath":"/live2d_models/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":30,"vOffset":20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":0.6,"opacityOnHover":0.2},"log":false});</script></body></html>