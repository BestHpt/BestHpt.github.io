<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>海量数据处理 | BestBear</title><meta name="description" content="海量数据处理"><meta name="keywords" content="算法"><meta name="author" content="简凡丶"><meta name="copyright" content="简凡丶"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="海量数据处理"><meta name="twitter:description" content="海量数据处理"><meta name="twitter:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta property="og:type" content="article"><meta property="og:title" content="海量数据处理"><meta property="og:url" content="http://yoursite.com/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"><meta property="og:site_name" content="BestBear"><meta property="og:description" content="海量数据处理"><meta property="og:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"><link rel="prev" title="分布式事务" href="http://yoursite.com/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><link rel="next" title="网络相关基础" href="http://yoursite.com/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BestBear</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/01/13/ViKAkpCRr5xde1j.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重要思想"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">重要思想</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#单位换算"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">单位换算</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何从大量的-URL-中找出相同的-URL？"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">如何从大量的 URL 中找出相同的 URL？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">解答思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何从大量数据中找出高频词？"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">如何从大量数据中找出高频词？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-1"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路-1"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">解答思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结-1"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何找出某一天访问百度网站最多的-IP？"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">如何找出某一天访问百度网站最多的 IP？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-2"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路-2"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">解答思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结-2"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何在大量的数据中找出不重复的整数？"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">如何在大量的数据中找出不重复的整数？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-3"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路-3"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">解答思路</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法一：分治法"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">方法一：分治法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法二：位图法"><span class="toc_mobile_items-number">6.2.2.</span> <span class="toc_mobile_items-text">方法二：位图法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结-3"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何在大量数据中判断一个数是否存在？"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">如何在大量数据中判断一个数是否存在？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-4"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路-4"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">解答思路</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法一：分治法-1"><span class="toc_mobile_items-number">7.2.1.</span> <span class="toc_mobile_items-text">方法一：分治法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法二：位图法-1"><span class="toc_mobile_items-number">7.2.2.</span> <span class="toc_mobile_items-text">方法二：位图法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结-4"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何查询最热门的查询串？"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">如何查询最热门的查询串？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-5"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路-5"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">解答思路</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法一：分治法-2"><span class="toc_mobile_items-number">8.2.1.</span> <span class="toc_mobile_items-text">方法一：分治法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法二：HashMap-法"><span class="toc_mobile_items-number">8.2.2.</span> <span class="toc_mobile_items-text">方法二：HashMap 法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法三：前缀树法"><span class="toc_mobile_items-number">8.2.3.</span> <span class="toc_mobile_items-text">方法三：前缀树法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结-5"><span class="toc_mobile_items-number">8.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何统计不同电话号码的个数？"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">如何统计不同电话号码的个数？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-6"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路-6"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">解答思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结-6"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何按照-query-的频度排序？"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">如何按照 query 的频度排序？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-7"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路-7"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text">解答思路</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法一：HashMap-法"><span class="toc_mobile_items-number">10.2.1.</span> <span class="toc_mobile_items-text">方法一：HashMap 法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法二：分治法"><span class="toc_mobile_items-number">10.2.2.</span> <span class="toc_mobile_items-text">方法二：分治法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结-7"><span class="toc_mobile_items-number">10.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何从-5-亿个数中找出中位数？"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">如何从 5 亿个数中找出中位数？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-8"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解答思路-8"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">解答思路</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法一：双堆法"><span class="toc_mobile_items-number">11.2.1.</span> <span class="toc_mobile_items-text">方法一：双堆法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#方法二：分治法-1"><span class="toc_mobile_items-number">11.2.2.</span> <span class="toc_mobile_items-text">方法二：分治法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#方法总结-8"><span class="toc_mobile_items-number">11.3.</span> <span class="toc_mobile_items-text">方法总结</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#重要思想"><span class="toc-number">1.</span> <span class="toc-text">重要思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单位换算"><span class="toc-number">2.</span> <span class="toc-text">单位换算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何从大量的-URL-中找出相同的-URL？"><span class="toc-number">3.</span> <span class="toc-text">如何从大量的 URL 中找出相同的 URL？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述"><span class="toc-number">3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路"><span class="toc-number">3.2.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结"><span class="toc-number">3.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何从大量数据中找出高频词？"><span class="toc-number">4.</span> <span class="toc-text">如何从大量数据中找出高频词？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-1"><span class="toc-number">4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路-1"><span class="toc-number">4.2.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结-1"><span class="toc-number">4.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何找出某一天访问百度网站最多的-IP？"><span class="toc-number">5.</span> <span class="toc-text">如何找出某一天访问百度网站最多的 IP？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-2"><span class="toc-number">5.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路-2"><span class="toc-number">5.2.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结-2"><span class="toc-number">5.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何在大量的数据中找出不重复的整数？"><span class="toc-number">6.</span> <span class="toc-text">如何在大量的数据中找出不重复的整数？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-3"><span class="toc-number">6.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路-3"><span class="toc-number">6.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一：分治法"><span class="toc-number">6.2.1.</span> <span class="toc-text">方法一：分治法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二：位图法"><span class="toc-number">6.2.2.</span> <span class="toc-text">方法二：位图法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结-3"><span class="toc-number">6.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何在大量数据中判断一个数是否存在？"><span class="toc-number">7.</span> <span class="toc-text">如何在大量数据中判断一个数是否存在？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-4"><span class="toc-number">7.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路-4"><span class="toc-number">7.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一：分治法-1"><span class="toc-number">7.2.1.</span> <span class="toc-text">方法一：分治法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二：位图法-1"><span class="toc-number">7.2.2.</span> <span class="toc-text">方法二：位图法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结-4"><span class="toc-number">7.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何查询最热门的查询串？"><span class="toc-number">8.</span> <span class="toc-text">如何查询最热门的查询串？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-5"><span class="toc-number">8.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路-5"><span class="toc-number">8.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一：分治法-2"><span class="toc-number">8.2.1.</span> <span class="toc-text">方法一：分治法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二：HashMap-法"><span class="toc-number">8.2.2.</span> <span class="toc-text">方法二：HashMap 法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法三：前缀树法"><span class="toc-number">8.2.3.</span> <span class="toc-text">方法三：前缀树法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结-5"><span class="toc-number">8.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何统计不同电话号码的个数？"><span class="toc-number">9.</span> <span class="toc-text">如何统计不同电话号码的个数？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-6"><span class="toc-number">9.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路-6"><span class="toc-number">9.2.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结-6"><span class="toc-number">9.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何按照-query-的频度排序？"><span class="toc-number">10.</span> <span class="toc-text">如何按照 query 的频度排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-7"><span class="toc-number">10.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路-7"><span class="toc-number">10.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一：HashMap-法"><span class="toc-number">10.2.1.</span> <span class="toc-text">方法一：HashMap 法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二：分治法"><span class="toc-number">10.2.2.</span> <span class="toc-text">方法二：分治法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结-7"><span class="toc-number">10.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何从-5-亿个数中找出中位数？"><span class="toc-number">11.</span> <span class="toc-text">如何从 5 亿个数中找出中位数？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-8"><span class="toc-number">11.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解答思路-8"><span class="toc-number">11.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一：双堆法"><span class="toc-number">11.2.1.</span> <span class="toc-text">方法一：双堆法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二：分治法-1"><span class="toc-number">11.2.2.</span> <span class="toc-text">方法二：分治法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法总结-8"><span class="toc-number">11.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">海量数据处理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-01-15<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-10-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">4.6k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 15 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="重要思想"><a href="#重要思想" class="headerlink" title="重要思想"></a>重要思想</h2><p>1、分治法，hash运算将有相同特征的值放到同一个文件中</p>
<p>2、bitMap位图法，求解数据重复问题</p>
<p>3、使用堆排序，解决topN问题，PriorityQueue是堆实现的</p>
<p>4、HashMap统计有限key的value次数，HashSet去重</p>
<h2 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h2><p>1 <strong>GB</strong> ≈ 10^3^ <strong>MB</strong> ≈ 10^6^ <strong>KB</strong> ≈ 10^9^ <strong>字节</strong> ≈ 8<em>10^9^ *</em>Bit**</p>
<p>1个bit存储一个数字</p>
<p>40亿个数 40<em>10^8^÷8\</em>10^9^=5G</p>
<h2 id="如何从大量的-URL-中找出相同的-URL？"><a href="#如何从大量的-URL-中找出相同的-URL？" class="headerlink" title="如何从大量的 URL 中找出相同的 URL？"></a>如何从大量的 URL 中找出相同的 URL？</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p>
<h3 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个 URL 占 64B，那么 50 亿个 URL占用的空间大小约为 320GB。</p>
<blockquote>
<p>5, 000, 000, 000 * 64B ≈ 5GB * 64 = 320GB</p>
</blockquote>
<p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p>
<p><strong>思路如下</strong>：</p>
<p>==特点：通过hash运算将有相同特征的值放到同一个文件中==</p>
<p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code> ，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p>
<p>接着遍历 ai( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p>
<h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><ol>
<li>分而治之，进行哈希取余；</li>
<li>对每个子文件进行 HashSet 统计。</li>
</ol>
<hr>
<h2 id="如何从大量数据中找出高频词？"><a href="#如何从大量数据中找出高频词？" class="headerlink" title="如何从大量数据中找出高频词？"></a>如何从大量数据中找出高频词？</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p>
<h3 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h3><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p>
<p><strong>思路如下</strong>：</p>
<p>==特点：通过hash运算将有相同特征的值放到同一个文件中==</p>
<p>首先遍历大文件，对遍历到的每个词x，执行 <code>hash(x) % 5000</code> ，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p>
<p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code> ；若存在，则执行 <code>map.put(x, map.get(x)+1)</code> ，将该词频数加 1。</p>
<p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p>
<p>PriorityQueue底层由小顶堆实现，通过重写compare转变成大顶堆。</p>
<h3 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h3><ol>
<li>分而治之，进行哈希取余；</li>
<li>使用 HashMap 统计频数；</li>
<li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li>
</ol>
<hr>
<h2 id="如何找出某一天访问百度网站最多的-IP？"><a href="#如何找出某一天访问百度网站最多的-IP？" class="headerlink" title="如何找出某一天访问百度网站最多的 IP？"></a>如何找出某一天访问百度网站最多的 IP？</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p>
<h3 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h3><p>==特点：通过hash运算将有相同特征的值放到同一个文件中==</p>
<p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p>
<blockquote>
<p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p>
</blockquote>
<h3 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h3><ol>
<li>分而治之，进行哈希取余；</li>
<li>使用 HashMap 统计频数；</li>
<li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li>
</ol>
<hr>
<h2 id="如何在大量的数据中找出不重复的整数？"><a href="#如何在大量的数据中找出不重复的整数？" class="headerlink" title="如何在大量的数据中找出不重复的整数？"></a>如何在大量的数据中找出不重复的整数？</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。</p>
<h3 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。</p>
<h4 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。</p>
<p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。</p>
<p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：</p>
<pre><code>0 0 0 0 0 0 0 0</code></pre><p>然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：</p>
<pre><code>0 0 0 0 1 0 1 0</code></pre><p>依次遍历，结束后，位数组是这样的：</p>
<pre><code>0 1 1 0 1 1 1 0</code></pre><p>每个为 1 的位，它的下标都表示了一个数：</p>
<pre><code>for i in range(8):
    if bits[i] == 1:
        print(i)</code></pre><p>这样我们其实就已经实现了排序。</p>
<p>对于整数相关的算法的求解，<strong>位图法</strong>是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。</p>
<p><strong>那么对于这道题</strong>，我们用 2 个 bit 来表示各个数字的状态：</p>
<ul>
<li>00 表示这个数字没出现过；</li>
<li>01 表示这个数字出现过一次（即为题目所找的不重复整数）；</li>
<li>10 表示这个数字出现了多次。</li>
</ul>
<p>那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：</p>
<p>遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</p>
<h3 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p>
<hr>
<h2 id="如何在大量数据中判断一个数是否存在？"><a href="#如何在大量数据中判断一个数是否存在？" class="headerlink" title="如何在大量数据中判断一个数是否存在？"></a>如何在大量数据中判断一个数是否存在？</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？</p>
<h3 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h3><h4 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。</p>
<h4 id="方法二：位图法-1"><a href="#方法二：位图法-1" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h4><p>40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4, 000, 000, 000b≈512M。</p>
<p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p>
<h3 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h3><p><strong>判断数字是否存在、判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p>
<hr>
<h2 id="如何查询最热门的查询串？"><a href="#如何查询最热门的查询串？" class="headerlink" title="如何查询最热门的查询串？"></a>如何查询最热门的查询串？</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过 255 字节。</p>
<p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p>
<h3 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h3><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。</p>
<h4 id="方法一：分治法-2"><a href="#方法一：分治法-2" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h4><p>分治法依然是一个非常实用的方法。</p>
<p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。</p>
<p>方法可行，但不是最好，下面介绍其他方法。</p>
<h4 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h4><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4表示整数占用的4个字节）。由此可见，1G 的内存空间完全够用。</p>
<p><strong>思路如下</strong>：</p>
<p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code> 。</p>
<p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p>
<p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code> 。</p>
<h4 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h4><p>方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p>
<p><strong>思路如下</strong>：</p>
<p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p>
<p>最后依然使用小顶堆来对字符串的出现次数进行排序。</p>
<h3 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h3><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p>
<hr>
<h2 id="如何统计不同电话号码的个数？"><a href="#如何统计不同电话号码的个数？" class="headerlink" title="如何统计不同电话号码的个数？"></a>如何统计不同电话号码的个数？</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p>
<h3 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h3><p>这道题本质还是求解<strong>数据重复</strong>的问题，对于这类问题，一般首先考虑位图法。</p>
<p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p>
<p><strong>思路如下</strong>：</p>
<p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p>
<h3 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h3><p>求解数据重复问题，记得考虑位图法。</p>
<h2 id="如何按照-query-的频度排序？"><a href="#如何按照-query-的频度排序？" class="headerlink" title="如何按照 query 的频度排序？"></a>如何按照 query 的频度排序？</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</p>
<h3 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h3><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。</p>
<h4 id="方法一：HashMap-法"><a href="#方法一：HashMap-法" class="headerlink" title="方法一：HashMap 法"></a>方法一：HashMap 法</h4><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。</p>
<h4 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h4><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 <code>hash(query) % 10</code> 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。</p>
<p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。</p>
<h3 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h3><ul>
<li>内存若够，直接读入进行排序；</li>
<li>内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li>
</ul>
<h2 id="如何从-5-亿个数中找出中位数？"><a href="#如何从-5-亿个数中找出中位数？" class="headerlink" title="如何从 5 亿个数中找出中位数？"></a>如何从 5 亿个数中找出中位数？</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 <code>(N+1)/2</code> 个数；当样本数为偶数时，中位数为 第 <code>N/2</code> 个数与第 <code>1+N/2</code> 个数的均值。</p>
<h3 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h3><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 <code>O(NlogN)</code> 。这里使用其他方法。</p>
<h4 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h4><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p>
<p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。</p>
<pre><code>class MedianFinder {

    private PriorityQueue&lt;Integer&gt; maxHeap;
    private PriorityQueue&lt;Integer&gt; minHeap;

    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());
        minHeap = new PriorityQueue&lt;&gt;(Integer::compareTo);
    }

    public void addNum(int num) {
        if (maxHeap.isEmpty() || maxHeap.peek() &gt; num) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }

        int size1 = maxHeap.size();
        int size2 = minHeap.size();
        if (size1 - size2 &gt; 1) {
            minHeap.offer(maxHeap.poll());
        } else if (size2 - size1 &gt; 1) {
            maxHeap.offer(minHeap.poll());
        }
    }

    public double findMedian() {
        int size1 = maxHeap.size();
        int size2 = minHeap.size();

        return size1 == size2 
            ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2
            : (size1 &gt; size2 ? maxHeap.peek() : minHeap.peek());
    }
}</code></pre><blockquote>
<p>见 LeetCode No.295：<a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">https://leetcode.com/problems/find-median-from-data-stream/</a></p>
</blockquote>
<p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法<strong>适用于数据量较小的情况</strong>。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。</p>
<h4 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h4><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。</p>
<p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。</p>
<p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。</p>
<blockquote>
<p><strong>提示</strong>，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。</p>
</blockquote>
<p>对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</p>
<blockquote>
<p><strong>注意</strong>，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。</p>
</blockquote>
<h3 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h3><p>分治法，真香！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">简凡丶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">http://yoursite.com/2020/01/15/8.%20%E7%AE%97%E6%B3%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">BestBear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法    </a></div><div class="post_share"><div class="social-share" data-image="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img class="prev_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>分布式事务</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/"><img class="next_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>网络相关基础</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'POlJROSsMvr6BdUPhPaqFdlj-gzGzoHsz',
  appKey:'JhPOeqEkpBUGVUNuYYxRCvUt',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 简凡丶</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.5,"jsonPath":"/live2d_models/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":30,"vOffset":20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":0.6,"opacityOnHover":0.2},"log":false});</script></body></html>