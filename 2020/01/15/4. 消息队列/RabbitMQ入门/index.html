<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>RabbitMQ 入门 | BestBear</title><meta name="description" content="RabbitMQ 入门"><meta name="keywords" content="消息队列"><meta name="author" content="简凡丶"><meta name="copyright" content="简凡丶"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="RabbitMQ 入门"><meta name="twitter:description" content="RabbitMQ 入门"><meta name="twitter:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ 入门"><meta property="og:url" content="http://yoursite.com/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%85%A5%E9%97%A8/"><meta property="og:site_name" content="BestBear"><meta property="og:description" content="RabbitMQ 入门"><meta property="og:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%85%A5%E9%97%A8/"><link rel="prev" title="全局异常处理" href="http://yoursite.com/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"><link rel="next" title="redis工具类" href="http://yoursite.com/2020/01/15/3.%20redis/redisUtil/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BestBear</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/01/13/ViKAkpCRr5xde1j.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">33</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#RabbitMQ-入门全攻略"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">RabbitMQ 入门全攻略</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#目录"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">目录</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#RabbitMQ-介绍"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">RabbitMQ 介绍</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#RabbitMQ-简介"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">RabbitMQ 简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#RabbitMQ-核心概念"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">RabbitMQ 核心概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Producer-和-Consumer"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">Producer 和 Consumer</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Exchange-交换器"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">Exchange(交换器)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#channel"><span class="toc_mobile_items-number">3.2.3.</span> <span class="toc_mobile_items-text">channel</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Queue-消息队列"><span class="toc_mobile_items-number">3.2.4.</span> <span class="toc_mobile_items-text">Queue(消息队列)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Broker（消息中间件的服务节点）"><span class="toc_mobile_items-number">3.2.5.</span> <span class="toc_mobile_items-text">Broker（消息中间件的服务节点）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#vhost-虚拟主机"><span class="toc_mobile_items-number">3.2.6.</span> <span class="toc_mobile_items-text">vhost(虚拟主机)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Exchange-Types-交换器类型"><span class="toc_mobile_items-number">3.2.7.</span> <span class="toc_mobile_items-text">Exchange Types(交换器类型)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#①-fanout（广播）"><span class="toc_mobile_items-number">3.2.7.1.</span> <span class="toc_mobile_items-text">① fanout（广播）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#②-direct（精准定向）"><span class="toc_mobile_items-number">3.2.7.2.</span> <span class="toc_mobile_items-text">② direct（精准定向）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#③-topic（模糊类型）"><span class="toc_mobile_items-number">3.2.7.3.</span> <span class="toc_mobile_items-text">③ topic（模糊类型）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#④-headers-不推荐"><span class="toc_mobile_items-number">3.2.7.4.</span> <span class="toc_mobile_items-text">④ headers(不推荐)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">3.2.8.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#安装-RabbitMq"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">安装 RabbitMq</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#安装-erlang"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">安装 erlang</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#安装-RabbitMQ"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">安装 RabbitMQ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建Virtual-Hosts"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">创建Virtual Hosts</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#管理界面中的功能"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">管理界面中的功能</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#学习五种队列"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">学习五种队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#简单队列"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">简单队列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#导入RabbitMQ的客户端依赖"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">导入RabbitMQ的客户端依赖</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#获取MQ的连接"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">获取MQ的连接</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#生产者发送消息到队列"><span class="toc_mobile_items-number">5.1.3.</span> <span class="toc_mobile_items-text">生产者发送消息到队列</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#WorkQueue-轮询分发"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">WorkQueue(轮询分发)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#生产者"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">生产者</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#消费者1"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">消费者1</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#消费者2"><span class="toc_mobile_items-number">5.2.3.</span> <span class="toc_mobile_items-text">消费者2</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#测试及结果分析"><span class="toc_mobile_items-number">5.2.4.</span> <span class="toc_mobile_items-text">测试及结果分析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Work模式的“能者多劳”"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">Work模式的“能者多劳”</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#消息的确认模式"><span class="toc_mobile_items-number">5.3.1.</span> <span class="toc_mobile_items-text">消息的确认模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#订阅模式-fanout-Exchange"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">订阅模式(fanout Exchange)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#路由模式-diect-Exchange"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">路由模式(diect Exchange)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Topic-主题-通配符模式"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text">Topic(主题\通配符模式)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Spring集成RabbitMQ"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Spring集成RabbitMQ</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#SpringBoot集成RabbitMQ"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">SpringBoot集成RabbitMQ</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#引入rabbitmq"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">引入rabbitmq</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#简单队列-1"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">简单队列</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-1"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">总结:</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-入门全攻略"><span class="toc-number">1.</span> <span class="toc-text">RabbitMQ 入门全攻略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#目录"><span class="toc-number">2.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-介绍"><span class="toc-number">3.</span> <span class="toc-text">RabbitMQ 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-简介"><span class="toc-number">3.1.</span> <span class="toc-text">RabbitMQ 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-核心概念"><span class="toc-number">3.2.</span> <span class="toc-text">RabbitMQ 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Producer-和-Consumer"><span class="toc-number">3.2.1.</span> <span class="toc-text">Producer 和 Consumer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exchange-交换器"><span class="toc-number">3.2.2.</span> <span class="toc-text">Exchange(交换器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel"><span class="toc-number">3.2.3.</span> <span class="toc-text">channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue-消息队列"><span class="toc-number">3.2.4.</span> <span class="toc-text">Queue(消息队列)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Broker（消息中间件的服务节点）"><span class="toc-number">3.2.5.</span> <span class="toc-text">Broker（消息中间件的服务节点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vhost-虚拟主机"><span class="toc-number">3.2.6.</span> <span class="toc-text">vhost(虚拟主机)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exchange-Types-交换器类型"><span class="toc-number">3.2.7.</span> <span class="toc-text">Exchange Types(交换器类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#①-fanout（广播）"><span class="toc-number">3.2.7.1.</span> <span class="toc-text">① fanout（广播）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#②-direct（精准定向）"><span class="toc-number">3.2.7.2.</span> <span class="toc-text">② direct（精准定向）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#③-topic（模糊类型）"><span class="toc-number">3.2.7.3.</span> <span class="toc-text">③ topic（模糊类型）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#④-headers-不推荐"><span class="toc-number">3.2.7.4.</span> <span class="toc-text">④ headers(不推荐)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">3.2.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装-RabbitMq"><span class="toc-number">4.</span> <span class="toc-text">安装 RabbitMq</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装-erlang"><span class="toc-number">4.1.</span> <span class="toc-text">安装 erlang</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装-RabbitMQ"><span class="toc-number">4.2.</span> <span class="toc-text">安装 RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Virtual-Hosts"><span class="toc-number">4.3.</span> <span class="toc-text">创建Virtual Hosts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管理界面中的功能"><span class="toc-number">4.4.</span> <span class="toc-text">管理界面中的功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习五种队列"><span class="toc-number">5.</span> <span class="toc-text">学习五种队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单队列"><span class="toc-number">5.1.</span> <span class="toc-text">简单队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#导入RabbitMQ的客户端依赖"><span class="toc-number">5.1.1.</span> <span class="toc-text">导入RabbitMQ的客户端依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取MQ的连接"><span class="toc-number">5.1.2.</span> <span class="toc-text">获取MQ的连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生产者发送消息到队列"><span class="toc-number">5.1.3.</span> <span class="toc-text">生产者发送消息到队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WorkQueue-轮询分发"><span class="toc-number">5.2.</span> <span class="toc-text">WorkQueue(轮询分发)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生产者"><span class="toc-number">5.2.1.</span> <span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消费者1"><span class="toc-number">5.2.2.</span> <span class="toc-text">消费者1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消费者2"><span class="toc-number">5.2.3.</span> <span class="toc-text">消费者2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试及结果分析"><span class="toc-number">5.2.4.</span> <span class="toc-text">测试及结果分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Work模式的“能者多劳”"><span class="toc-number">5.3.</span> <span class="toc-text">Work模式的“能者多劳”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#消息的确认模式"><span class="toc-number">5.3.1.</span> <span class="toc-text">消息的确认模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#订阅模式-fanout-Exchange"><span class="toc-number">5.4.</span> <span class="toc-text">订阅模式(fanout Exchange)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由模式-diect-Exchange"><span class="toc-number">5.5.</span> <span class="toc-text">路由模式(diect Exchange)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic-主题-通配符模式"><span class="toc-number">5.6.</span> <span class="toc-text">Topic(主题\通配符模式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring集成RabbitMQ"><span class="toc-number">6.</span> <span class="toc-text">Spring集成RabbitMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot集成RabbitMQ"><span class="toc-number">7.</span> <span class="toc-text">SpringBoot集成RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引入rabbitmq"><span class="toc-number">7.1.</span> <span class="toc-text">引入rabbitmq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单队列-1"><span class="toc-number">7.2.</span> <span class="toc-text">简单队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-1"><span class="toc-number">8.</span> <span class="toc-text">总结:</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">RabbitMQ 入门</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-01-15<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-10-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.9k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 29 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="RabbitMQ-入门全攻略"><a href="#RabbitMQ-入门全攻略" class="headerlink" title="RabbitMQ 入门全攻略"></a>RabbitMQ 入门全攻略</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p>
<h2 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h2><p>这部分参考了 《RabbitMQ实战指南》这本书的第 1 章和第 2 章。</p>
<h3 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h3><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>
<ul>
<li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们将 RabbitMQ 核心概念的时候详细介绍到。</li>
<li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>
<li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li>
<li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>
<li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li>
</ul>
<h3 id="RabbitMQ-核心概念"><a href="#RabbitMQ-核心概念" class="headerlink" title="RabbitMQ 核心概念"></a>RabbitMQ 核心概念</h3><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p>
<p>下面再来看看图1—— RabbitMQ 的整体模型架构。</p>
<p><a href="https://camo.githubusercontent.com/e4dfa61a9297b9a679fe5f66ad1543787c759770/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f39363338383534362e6a7067" target="_blank" rel="noopener"><img alt="图1-RabbitMQ 的整体模型架构" data-src="https://camo.githubusercontent.com/e4dfa61a9297b9a679fe5f66ad1543787c759770/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f39363338383534362e6a7067" class="lazyload"></a></p>
<p>下面我会一一介绍上图中的一些概念。</p>
<h4 id="Producer-和-Consumer"><a href="#Producer-和-Consumer" class="headerlink" title="Producer 和 Consumer"></a>Producer 和 Consumer</h4><ul>
<li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li>
<li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li>
</ul>
<p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p>
<h4 id="Exchange-交换器"><a href="#Exchange-交换器" class="headerlink" title="Exchange(交换器)"></a>Exchange(交换器)</h4><p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p>
<p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。</p>
<p><strong>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)</strong>，<strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的Exchange转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p>
<p>Exchange(交换器) 示意图如下：</p>
<p><a href="https://camo.githubusercontent.com/f8c9661d91d632c2744bea0649333a5d0f2ce898/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f32343030373839392e6a7067" target="_blank" rel="noopener"><img alt="Exchange(交换器) 示意图" data-src="https://camo.githubusercontent.com/f8c9661d91d632c2744bea0649333a5d0f2ce898/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f32343030373839392e6a7067" class="lazyload"></a></p>
<p>生产者将消息发给交换器的时候，一般会指定一个 <code>RoutingKey(路由键)</code>*<em>，用来指定这个消息的路由规则，而这个 *</em>RoutingKey 需要与交换器类型和绑定键(<code>BindingKey</code>)联合使用才能最终生效。</p>
<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p>
<p>Binding(绑定) 示意图：</p>
<p><a href="https://camo.githubusercontent.com/effb1066045c449b5439ef94412bef331e912644/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37303535333133342e6a7067" target="_blank" rel="noopener"><img alt="Binding(绑定) 示意图" data-src="https://camo.githubusercontent.com/effb1066045c449b5439ef94412bef331e912644/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37303535333133342e6a7067" class="lazyload"></a></p>
<p>生产者将消息发送给交换器时，==需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中==。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>简单理解：==信道是connection基于NIO的优化升级，实现连接复用==。</p>
<p>一个应用程序中有很多个线程需要从RabbitMQ 中消费消息，或者生产消息，那么必然需要建立很多个Connection ，也就是许多个TCP 连接。然而对于操作系统而言，建立和销毁TCP 连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。RabbitMQ 采用类似NIO’ (Non-blocking 1/0) 的做法，选择TCP 连接复用，不仅可以减少性能开销，同时也便于管理。</p>
<p>每个线程把持一个信道，所以信道复用了Connection 的TCP 连接。同时RabbitMQ 可以确保每个线程的私密性，就像拥有独立的连接一样。当每个信道的流量不是很大时，复用单一的Connection 可以在产生性能瓶颈的情况下有效地节省TCP 连接资源。但是当信道本身的流量很大时，这时候多个信道复用一个Connection 就会产生性能瓶颈，进而使整体的流量被限制了。此时就需要开辟多个Connection ，将这些信道均摊到这些Connection 中， 至于这些相关的调优策略需要根据业务自身的实际情况进行调节。</p>
<p><strong>RabbitMQ 为什么需要信道？为什么不是TCP直接通信？</strong></p>
<ol>
<li><p>TCP的创建和销毁，开销大，创建需要三次握手，销毁需要四次分手</p>
</li>
<li><p>如果不使用信道，那么引用程序就会使用TCP的方式连接到rabbitmq，高峰时每秒成千上万条连接会造成资源的巨大浪费(一条tcp消耗资源，成千上万的tcp会非常消耗资源)，而且操作系统每秒处理TCP连接数量也是有限的，必定会造成性能瓶颈</p>
</li>
<li><p>信道的原理是一条线程一条信道，多条线程多条信道共同使用一条TCP连接。一条TCP连接可以容纳无限的信道，及时每秒造成成千上万的请求也不会造成性能瓶颈</p>
</li>
</ol>
<h4 id="Queue-消息队列"><a href="#Queue-消息队列" class="headerlink" title="Queue(消息队列)"></a>Queue(消息队列)</h4><p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p>
<p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。</p>
<p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p>
<h4 id="Broker（消息中间件的服务节点）"><a href="#Broker（消息中间件的服务节点）" class="headerlink" title="Broker（消息中间件的服务节点）"></a>Broker（消息中间件的服务节点）</h4><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>
<p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p>
<p><a href="https://camo.githubusercontent.com/6f3125fb04c98886209d26d4e904ce4c4c7343ad/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f36373935323932322e6a7067" target="_blank" rel="noopener"><img alt="消息队列的运转过程" data-src="https://camo.githubusercontent.com/6f3125fb04c98886209d26d4e904ce4c4c7343ad/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f36373935323932322e6a7067" class="lazyload"></a></p>
<p>这样图1中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p>
<h4 id="vhost-虚拟主机"><a href="#vhost-虚拟主机" class="headerlink" title="vhost(虚拟主机)"></a>vhost(虚拟主机)</h4><p>虚拟主机，一个消息代理（Broker）里可以开设多个虚拟主机（vhost），用作不同用户的权限分离。可以理解为一个子数据库</p>
<h4 id="Exchange-Types-交换器类型"><a href="#Exchange-Types-交换器类型" class="headerlink" title="Exchange Types(交换器类型)"></a>Exchange Types(交换器类型)</h4><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p>
<h5 id="①-fanout（广播）"><a href="#①-fanout（广播）" class="headerlink" title="① fanout（广播）"></a>① fanout（广播）</h5><p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来<code>广播</code>消息。</p>
<h5 id="②-direct（精准定向）"><a href="#②-direct（精准定向）" class="headerlink" title="② direct（精准定向）"></a>② direct（精准定向）</h5><p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p>
<p><a href="https://camo.githubusercontent.com/7177328efe9e95372a9b7fb8b51022312d2e601b/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f33373030383032312e6a7067" target="_blank" rel="noopener"><img alt="direct 类型交换器" data-src="https://camo.githubusercontent.com/7177328efe9e95372a9b7fb8b51022312d2e601b/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f33373030383032312e6a7067" class="lazyload"></a></p>
<p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为”Info”或者”debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p>
<p>direct 类型常用在<code>处理有优先级的任务</code>，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>
<h5 id="③-topic（模糊类型）"><a href="#③-topic（模糊类型）" class="headerlink" title="③ topic（模糊类型）"></a>③ topic（模糊类型）</h5><p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li>
<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>
<li>BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/ad72829eb75cde62383a48361e3a77708a80f955/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37333834332e6a7067" target="_blank" rel="noopener"><img alt="topic 类型交换器" data-src="https://camo.githubusercontent.com/ad72829eb75cde62383a48361e3a77708a80f955/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f37333834332e6a7067" class="lazyload"></a></p>
<p>以上图为例：</p>
<ul>
<li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queuel 和 Queue2;</li>
<li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “java.rabbitmq.demo” 的消息只会路由到Queuel中；</li>
<li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li>
</ul>
<h5 id="④-headers-不推荐"><a href="#④-headers-不推荐" class="headerlink" title="④ headers(不推荐)"></a>④ headers(不推荐)</h5><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)’对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、信道才是rabbit通信本质，生产者和消费者都是通过信道完成消息生产消费的。</p>
<p>2、交换器本质是一张路由查询表（名称和队列id，类似于hash表），这是一个虚拟出来的东西，并不存在真实的交换器。</p>
<p>3、消息的生命周期：生产者生产消息A 交由信道，信道通过消息（消息由载体和标签）的标签（路由键）放到交换器发送到队列上（其实就是查询匹配，一旦匹配到了规则，信道就直接和队列产生连接，然后将消息发送过去）</p>
<p>4、Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。</p>
<h2 id="安装-RabbitMq"><a href="#安装-RabbitMq" class="headerlink" title="安装 RabbitMq"></a>安装 RabbitMq</h2><p>通过 Docker 安装非常方便，只需要几条命令就好了，我这里是只说一下常规安装方法。</p>
<p>前面提到了 RabbitMQ 是由 Erlang语言编写的，也正因如此，在安装RabbitMQ 之前需要安装 Erlang。</p>
<p>注意：在安装 RabbitMQ 的时候需要注意 RabbitMQ 和 Erlang 的版本关系，如果不注意的话会导致出错，两者对应关系如下:</p>
<p><a href="https://camo.githubusercontent.com/4c0efb8ab3642847c70512cdd91e3aac49c4ef52/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f5261626269744d512d45726c616e672e706e67" target="_blank" rel="noopener"><img alt="RabbitMQ 和 Erlang 的版本关系" data-src="https://camo.githubusercontent.com/4c0efb8ab3642847c70512cdd91e3aac49c4ef52/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f5261626269744d512d45726c616e672e706e67" class="lazyload"></a></p>
<h3 id="安装-erlang"><a href="#安装-erlang" class="headerlink" title="安装 erlang"></a>安装 erlang</h3><p><strong>1 下载 erlang 安装包</strong></p>
<p>在官网下载然后上传到 Linux 上或者直接使用下面的命令下载对应的版本。</p>
<pre><code class="powershell">[root@SnailClimb local]#wget http://erlang.org/download/otp_src_19.3.tar.gz</code></pre>
<p>erlang 官网下载：<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">http://www.erlang.org/downloads</a></p>
<p><strong>2 解压 erlang 安装包</strong></p>
<pre><code>[root@SnailClimb local]#tar -xvzf otp_src_19.3.tar.gz</code></pre><p><strong>3 删除 erlang 安装包</strong></p>
<pre><code>[root@SnailClimb local]#rm -rf otp_src_19.3.tar.gz</code></pre><p><strong>4 安装 erlang 的依赖工具</strong></p>
<pre><code class="shell">[root@SnailClimb local]#yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel</code></pre>
<p><strong>5 进入erlang 安装包解压文件对 erlang 进行安装环境的配置</strong></p>
<p>新建一个文件夹</p>
<pre><code class="shell">[root@SnailClimb local]# mkdir /usr/local/erlang</code></pre>
<p>对 erlang 进行安装环境的配置</p>
<pre><code class="shell">[root@SnailClimb otp_src_19.3]# 
./configure --prefix=/usr/local/erlang --without-javac</code></pre>
<p><strong>6 编译安装</strong></p>
<pre><code class="shell">[root@SnailClimb otp_src_19.3]# 
make &amp;&amp; make install</code></pre>
<p><strong>7 验证一下 erlang 是否安装成功了</strong></p>
<pre><code>[root@SnailClimb otp_src_19.3]# ./bin/erl</code></pre><p>运行下面的语句输出“hello world”</p>
<pre><code> io:format(&quot;hello world~n&quot;, []).</code></pre><p><a href="https://camo.githubusercontent.com/30edcba9ad0d03b29f5e35991f758378d18a4a73/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f34393537303534312e6a7067" target="_blank" rel="noopener"><img alt="输出“hello world”" data-src="https://camo.githubusercontent.com/30edcba9ad0d03b29f5e35991f758378d18a4a73/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f34393537303534312e6a7067" class="lazyload"></a></p>
<p>大功告成，我们的 erlang 已经安装完成。</p>
<p><strong>8 配置 erlang 环境变量</strong></p>
<pre><code>[root@SnailClimb etc]# vim profile</code></pre><p>追加下列环境变量到文件末尾</p>
<pre><code>#erlang
ERL_HOME=/usr/local/erlang
PATH=$ERL_HOME/bin:$PATH
export ERL_HOME PATH</code></pre><p>运行下列命令使配置文件<code>profile</code>生效</p>
<pre><code>[root@SnailClimb etc]# source /etc/profile</code></pre><p>输入 erl 查看 erlang 环境变量是否配置正确</p>
<pre><code>[root@SnailClimb etc]# erl</code></pre><p><a href="https://camo.githubusercontent.com/6762285cc92cf37942eaa086269654106518e087/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f36323530343234362e6a7067" target="_blank" rel="noopener"><img alt="输入 erl 查看 erlang 环境变量是否配置正确" data-src="https://camo.githubusercontent.com/6762285cc92cf37942eaa086269654106518e087/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f36323530343234362e6a7067" class="lazyload"></a></p>
<h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><p><strong>1. 下载rpm</strong></p>
<pre><code>wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.8/rabbitmq-server-3.6.8-1.el7.noarch.rpm</code></pre><p>或者直接在官网下载</p>
<p><a href="https://www.rabbitmq.com/install-rpm.html" target="_blank" rel="noopener">https://www.rabbitmq.com/install-rpm.html</a></p>
<p><strong>2. 安装rpm</strong></p>
<pre><code>rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
# 安装socat
yum -y install socat 
##此时会报错没有socat包或是找不到socat包，解决方法安装centos的epel的扩展源
yum -y install epel-release  
##之后重新安装socat
yum -y install socat</code></pre><p>紧接着执行：</p>
<pre><code>yum install rabbitmq-server-3.6.8-1.el7.noarch.rpm</code></pre><p>中途需要你输入”y”才能继续安装。</p>
<p><strong>3 开启 web 管理插件</strong></p>
<pre><code>rabbitmq-plugins enable rabbitmq_management</code></pre><p>可能会遇到如下错误：</p>
<p><img alt="image-20200523105232373" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf271s1sjsj317m0bc42d.jpg" class="lazyload"></p>
<p>重启解决</p>
<p>service rabbitmq-server restart </p>
<p>4 设置开机启动</p>
<pre><code>chkconfig rabbitmq-server on</code></pre><p>5 启动服务</p>
<pre><code>service rabbitmq-server start</code></pre><p>6 查看服务状态</p>
<pre><code>service rabbitmq-server status</code></pre><p><strong>7. 访问 RabbitMQ 控制台</strong></p>
<p>浏览器访问：<a href="http://xn--ip-0p3ck01akcu41v:15672/" target="_blank" rel="noopener">http://你的ip地址:15672/</a></p>
<p>默认用户名和密码： guest/guest;但是需要注意的是：guestuest用户只是被容许从localhost访问。官网文档描述如下：</p>
<pre><code>“guest” user can only connect via localhost</code></pre><p><strong>解决远程访问 RabbitMQ 远程访问密码错误</strong></p>
<p>新建用户并授权</p>
<pre><code>[root@SnailClimb rabbitmq]# rabbitmqctl add_user root root
Creating user &quot;root&quot; ...
[root@SnailClimb rabbitmq]# rabbitmqctl set_user_tags root administrator

Setting tags for user &quot;root&quot; to [administrator] ...
[root@SnailClimb rabbitmq]# 
[root@SnailClimb rabbitmq]# rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
Setting permissions for user &quot;root&quot; in vhost &quot;/&quot; ...</code></pre><p>再次访问:<a href="http://xn--ip-0p3ck01akcu41v:15672/" target="_blank" rel="noopener">http://你的ip地址:15672/</a> ,输入用户名和密码：root root</p>
<p><a href="https://camo.githubusercontent.com/7baff40cce00e7196515229aed0cfada49e186bb/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f34353833353333322e6a7067" target="_blank" rel="noopener"><img alt="RabbitMQ控制台" data-src="https://camo.githubusercontent.com/7baff40cce00e7196515229aed0cfada49e186bb/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31322f34353833353333322e6a7067" class="lazyload"></a></p>
<h3 id="创建Virtual-Hosts"><a href="#创建Virtual-Hosts" class="headerlink" title="创建Virtual Hosts"></a>创建Virtual Hosts</h3><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2gws378yj31gt0hxdh0.jpg" class="lazyload"></p>
<p>选中Admin用户，设置权限：</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2gwxsgi1j31fy0mvgmh.jpg" class="lazyload">看到权限已加：</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2gx47a7ij31f70m1q46.jpg" class="lazyload"></p>
<h3 id="管理界面中的功能"><a href="#管理界面中的功能" class="headerlink" title="管理界面中的功能"></a>管理界面中的功能</h3><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2gx9cfevj30nq0da0th.jpg" class="lazyload"></p>
<h2 id="学习五种队列"><a href="#学习五种队列" class="headerlink" title="学习五种队列"></a>学习五种队列</h2><h3 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h3><p><img alt="image-20200523163811355" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2h1cyledj30j806g3yy.jpg" class="lazyload"></p>
<p>P：消息的生产者<br>C：消息的消费者<br>红色：队列</p>
<p>生产者将消息发送到队列，消费者从队列中获取消息。</p>
<p>生产者一一对应消费者</p>
<h4 id="导入RabbitMQ的客户端依赖"><a href="#导入RabbitMQ的客户端依赖" class="headerlink" title="导入RabbitMQ的客户端依赖"></a>导入RabbitMQ的客户端依赖</h4><pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
   &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
   &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h4 id="获取MQ的连接"><a href="#获取MQ的连接" class="headerlink" title="获取MQ的连接"></a>获取MQ的连接</h4><pre><code class="java">package com.zpc.rabbitmq.util;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;

public class ConnectionUtil {

    public static Connection getConnection() throws Exception {
        //定义连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置服务地址
        factory.setHost(&quot;localhost&quot;);
        //端口
        factory.setPort(5672);
        //设置账号信息，用户名、密码、vhost
        factory.setVirtualHost(&quot;testhost&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;admin&quot;);
        // 通过工程获取连接
        Connection connection = factory.newConnection();
        return connection;
    }
}
</code></pre>
<h4 id="生产者发送消息到队列"><a href="#生产者发送消息到队列" class="headerlink" title="生产者发送消息到队列"></a>生产者发送消息到队列</h4><pre><code class="java">public class Send {

    private final static String QUEUE_NAME = &quot;q_test_01&quot;;

    public static void main(String[] argv) throws Exception {
        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        // 从连接中创建通道
        Channel channel = connection.createChannel();

        // 声明（创建）队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 消息内容
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
        System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);
        //关闭通道和连接
        channel.close();
        connection.close();
    }
}</code></pre>
<p>管理工具中查看消息</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2p37jt4aj30ro0dmwf3.jpg" class="lazyload"></p>
<p>点击上面的队列名称，查询具体的队列中的信息：</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2p3ehzytj30n10h7mxl.jpg" class="lazyload"></p>
<p>消费者从队列中获取消息</p>
<pre><code class="java">public class Recv {

    private final static String QUEUE_NAME = &quot;q_test_01&quot;;

    public static void main(String[] argv) throws Exception {

        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        // 从连接中创建通道
        Channel channel = connection.createChannel();
        // 声明队列（队列连接到信道上）
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 声明consumer
        DefaultConsumer consumer=new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String msg = new String(body);
                System.out.println(msg);
            }
        };

        //  启动消费者监听队列
        channel.basicConsume(QUEUE_NAME, true, consumer);
    }
}</code></pre>
<h3 id="WorkQueue-轮询分发"><a href="#WorkQueue-轮询分发" class="headerlink" title="WorkQueue(轮询分发)"></a>WorkQueue(轮询分发)</h3><p><img alt="image-20200524085511793" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf399wtve5j30js08agn8.jpg" class="lazyload"></p>
<p>一个生产者、2个消费者。一个消息只能被一个消费者获取。</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>向队列中发送50条消息。</p>
<pre><code class="java">public class WorkSend {

    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;

    public static void main(String[] argv) throws Exception {
        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        for (int i = 0; i &lt; 50; i++) {
            // 消息内容
            String message = &quot;&quot; + i;
            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
            System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);

            Thread.sleep(i * 10);
        }

        channel.close();
        connection.close();
    }
}</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="java">public class WorkRecv1 {
    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;

    public static void main(String[] argv) throws Exception {

        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 定义一个消费者
        Consumer consumer=new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String msg = new String(body);
                System.out.println(&quot;[1] Recv msg : &quot; + msg);

                try {
                    // 模拟处理消息，花费2S
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    System.out.println(&quot;[1] done!&quot;);
                }
            }
        };

        //  启动消费者监听队列
        channel.basicConsume(QUEUE_NAME, true, consumer);
    }
}</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="java">public class WorkRecv2 {
    private final static String QUEUE_NAME = &quot;test_queue_work&quot;;

    public static void main(String[] argv) throws Exception {

        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 定义一个消费者
        Consumer consumer=new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String msg = new String(body);
                System.out.println(&quot;[2] Recv msg : &quot; + msg);

                try {
                    // 模拟处理消息，花费1S
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    System.out.println(&quot;[2] done!&quot;);
                }
            }
        };

        //  启动消费者监听队列
        channel.basicConsume(QUEUE_NAME, true, consumer);
    }
}</code></pre>
<h4 id="测试及结果分析"><a href="#测试及结果分析" class="headerlink" title="测试及结果分析"></a>测试及结果分析</h4><p>测试结果：<br>    1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。<br>    2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。</p>
<p>其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。<br>RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即<code>轮询（round-robin）分发</code>消息。</p>
<p>怎样才能做到按照每个消费者的能力分配消息呢？</p>
<p>​        联合使用 Qos 和 Acknowledge 就可以做到。<br>​        <code>basicQos方法</code>设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 <code>prefetchCount</code> 参数就是用来限制这批未确认消息数量的。设为1时，<strong>队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息</strong>。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。</p>
<p>2个概念</p>
<p><code>轮询分发</code> ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。</p>
<p><code>公平分发</code> ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。</p>
<p>为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。<br>还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。</p>
<h3 id="Work模式的“能者多劳”"><a href="#Work模式的“能者多劳”" class="headerlink" title="Work模式的“能者多劳”"></a>Work模式的“能者多劳”</h3><p>打开上述代码的注释：</p>
<pre><code class="java">// 同一时刻服务器只会发一条消息给消费者
channel.basicQos(1);

//开启这行 表示使用手动确认模式
channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);

// 监听队列，false表示手动返回完成状态，true表示自动
channel.basicConsume(QUEUE_NAME, false, consumer);</code></pre>
<p>测试：<br>消费者1比消费者2获取的消息更多。</p>
<h4 id="消息的确认模式"><a href="#消息的确认模式" class="headerlink" title="消息的确认模式"></a>消息的确认模式</h4><p>消费者从队列中获取消息，服务端如何知道消息已经被消费呢？</p>
<p>模式1：自动确认<br>只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。<br>模式2：手动确认<br>消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。</p>
<p>手动模式：</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4glg31ixj30o50bfgma.jpg" class="lazyload"></p>
<p>自动模式：</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4glk5mlrj30nk088wev.jpg" class="lazyload"></p>
<h3 id="订阅模式-fanout-Exchange"><a href="#订阅模式-fanout-Exchange" class="headerlink" title="订阅模式(fanout Exchange)"></a>订阅模式(fanout Exchange)</h3><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4glwdnkjj30da05ajrh.jpg" class="lazyload"></p>
<p>解读：<br>1、1个生产者，多个消费者<br>2、每一个消费者都有自己的一个队列<br>3、生产者没有将消息直接发送到队列，而是发送到了交换机<br>4、每个队列都要绑定到交换机<br>5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的<br>注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4ngyyrtdj30cl08m0t2.jpg" class="lazyload"></p>
<p>5.6.2.消息的生产者（看作是后台系统）<br>向交换机中发送消息。</p>
<pre><code class="java">package com.zpc.rabbitmq.subscribe;

import com.zpc.rabbitmq.util.ConnectionUtil;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;

public class Send {

    private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;

    public static void main(String[] argv) throws Exception {
        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明exchange
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);

        // 消息内容
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
        System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);

        channel.close();
        connection.close();
    }
}
</code></pre>
<p>注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。<br>5.6.3.消费者1（看作是前台系统）</p>
<pre><code class="java">package com.zpc.rabbitmq.subscribe;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.QueueingConsumer;

import com.zpc.rabbitmq.util.ConnectionUtil;

public class Recv {

    private final static String QUEUE_NAME = &quot;test_queue_work1&quot;;

    private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;

    public static void main(String[] argv) throws Exception {

        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 绑定队列到交换机
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);

        // 同一时刻服务器只会发一条消息给消费者
        channel.basicQos(1);

        // 定义队列的消费者
        QueueingConsumer consumer = new QueueingConsumer(channel);
        // 监听队列，手动返回完成
        channel.basicConsume(QUEUE_NAME, false, consumer);

        // 获取消息
        while (true) {
            QueueingConsumer.Delivery delivery = consumer.nextDelivery();
            String message = new String(delivery.getBody());
            System.out.println(&quot; [Recv] Received &#39;&quot; + message + &quot;&#39;&quot;);
            Thread.sleep(10);

            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        }
    }
}
</code></pre>
<p>5.6.4.消费者2（看作是搜索系统）</p>
<pre><code class="java">package com.zpc.rabbitmq.subscribe;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.QueueingConsumer;

import com.zpc.rabbitmq.util.ConnectionUtil;

public class Recv2 {

    private final static String QUEUE_NAME = &quot;test_queue_work2&quot;;

    private final static String EXCHANGE_NAME = &quot;test_exchange_fanout&quot;;

    public static void main(String[] argv) throws Exception {

        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 绑定队列到交换机
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);

        // 同一时刻服务器只会发一条消息给消费者
        channel.basicQos(1);

        // 定义队列的消费者
        QueueingConsumer consumer = new QueueingConsumer(channel);
        // 监听队列，手动返回完成
        channel.basicConsume(QUEUE_NAME, false, consumer);

        // 获取消息
        while (true) {
            QueueingConsumer.Delivery delivery = consumer.nextDelivery();
            String message = new String(delivery.getBody());
            System.out.println(&quot; [Recv2] Received &#39;&quot; + message + &quot;&#39;&quot;);
            Thread.sleep(10);

            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        }
    }
}</code></pre>
<p>测试<br>测试结果：<br>同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</p>
<p>在管理工具中查看队列和交换机的绑定关系：</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nmbp25lj30t90lk0tg.jpg" class="lazyload"></p>
<h3 id="路由模式-diect-Exchange"><a href="#路由模式-diect-Exchange" class="headerlink" title="路由模式(diect Exchange)"></a>路由模式(diect Exchange)</h3><p>交换机根据匹配规则路由到指定符合的队列中</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4noqkxcsj30cl07ijrn.jpg" class="lazyload"></p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4np44hdjj30ut093taa.jpg" class="lazyload"></p>
<p>生产者</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nq1mleij30q60cjgmg.jpg" class="lazyload"></p>
<p>消费者1(假设是前台系统)</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nq89ipmj30p40emdgt.jpg" class="lazyload"></p>
<p>消费2（假设是搜索系统）</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nr21netj30oi0eojse.jpg" class="lazyload"></p>
<h3 id="Topic-主题-通配符模式"><a href="#Topic-主题-通配符模式" class="headerlink" title="Topic(主题\通配符模式)"></a>Topic(主题\通配符模式)</h3><p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nshrcitj30u702zdfq.jpg" class="lazyload"></p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nsp7itfj30f9087t9w.jpg" class="lazyload"></p>
<p>同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。</p>
<p><img alt="这里写图片描述" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4nsy77jbj30sw07f75m.jpg" class="lazyload"></p>
<p>生产者</p>
<pre><code class="java">public class Send {

    private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;

    public static void main(String[] argv) throws Exception {
        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明exchange
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);

        // 消息内容
        String message = &quot;Hello World!!&quot;;
        channel.basicPublish(EXCHANGE_NAME, &quot;routekey.1&quot;, null, message.getBytes());
        System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);

        channel.close();
        connection.close();
    }
}
</code></pre>
<p>消费者1（前台系统）</p>
<pre><code class="java">public class Recv {

    private final static String QUEUE_NAME = &quot;test_queue_topic_work_1&quot;;

    private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;

    public static void main(String[] argv) throws Exception {

        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 绑定队列到交换机
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;routekey.*&quot;);

        // 同一时刻服务器只会发一条消息给消费者
        channel.basicQos(1);

        // 定义队列的消费者
        QueueingConsumer consumer = new QueueingConsumer(channel);
        // 监听队列，手动返回完成
        channel.basicConsume(QUEUE_NAME, false, consumer);

        // 获取消息
        while (true) {
            QueueingConsumer.Delivery delivery = consumer.nextDelivery();
            String message = new String(delivery.getBody());
            System.out.println(&quot; [Recv_x] Received &#39;&quot; + message + &quot;&#39;&quot;);
            Thread.sleep(10);

            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        }
    }
}
</code></pre>
<p>消费者2（搜索系统）</p>
<pre><code class="java">public class Recv2 {

    private final static String QUEUE_NAME = &quot;test_queue_topic_work_2&quot;;

    private final static String EXCHANGE_NAME = &quot;test_exchange_topic&quot;;

    public static void main(String[] argv) throws Exception {

        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();

        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 绑定队列到交换机
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*&quot;);

        // 同一时刻服务器只会发一条消息给消费者
        channel.basicQos(1);

        // 定义队列的消费者
        QueueingConsumer consumer = new QueueingConsumer(channel);
        // 监听队列，手动返回完成
        channel.basicConsume(QUEUE_NAME, false, consumer);

        // 获取消息
        while (true) {
            QueueingConsumer.Delivery delivery = consumer.nextDelivery();
            String message = new String(delivery.getBody());
            System.out.println(&quot; [Recv2_x] Received &#39;&quot; + message + &quot;&#39;&quot;);
            Thread.sleep(10);

            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        }
    }
}</code></pre>
<h2 id="Spring集成RabbitMQ"><a href="#Spring集成RabbitMQ" class="headerlink" title="Spring集成RabbitMQ"></a>Spring集成RabbitMQ</h2><p>参考链接,这里不做演示:</p>
<p><a href="https://blog.csdn.net/hellozpc/article/details/81436980" target="_blank" rel="noopener">https://blog.csdn.net/hellozpc/article/details/81436980</a></p>
<h2 id="SpringBoot集成RabbitMQ"><a href="#SpringBoot集成RabbitMQ" class="headerlink" title="SpringBoot集成RabbitMQ"></a>SpringBoot集成RabbitMQ</h2><h3 id="引入rabbitmq"><a href="#引入rabbitmq" class="headerlink" title="引入rabbitmq"></a>引入rabbitmq</h3><p>1、配置pom文件，主要是添加spring-boot-starter-amqp的支持</p>
<pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>2、配置application.properties文件,配置rabbitmq的安装地址、端口以及账户信息,数据库信息</p>
<pre><code class="properties">spring.application.name=spirng-boot-rabbitmq
spring.rabbitmq.host=172.16.219.215
spring.rabbitmq.port=5672
spring.rabbitmq.username=root
spring.rabbitmq.password=root
spring.rabbitmq.virtual-host=testhost</code></pre>
<h3 id="简单队列-1"><a href="#简单队列-1" class="headerlink" title="简单队列"></a>简单队列</h3><p>1、配置队列</p>
<pre><code class="java">import org.springframework.amqp.core.Queue;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration
public class RabbitConfig {

    @Bean
    public Queue helloQueue() {
        return new Queue(&quot;hello3&quot;);
    }

    @Bean
    public Queue neoQueue() {
        return new Queue(&quot;neo&quot;);
    }

    @Bean
    public Queue objectQueue() {
        return new Queue(&quot;object&quot;);
    }

}</code></pre>
<p>2、发送者</p>
<pre><code class="java">package com.neo.rabbit.hello;

import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class HelloSender {

    @Autowired
    private AmqpTemplate rabbitTemplate;

    public void send()   {
        String context = &quot;hello &quot; + new Date();
        System.out.println(&quot;Sender : &quot; + context);
        this.rabbitTemplate.convertAndSend(&quot;hello3&quot;, context);

    }

}</code></pre>
<p>3、消费者</p>
<pre><code class="java">package com.neo.rabbit.hello;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;


@Component
@RabbitListener(queues = &quot;hello3&quot;)
public class HelloReceiver {

    @RabbitHandler
    public void process(String hello) {
        System.out.println(&quot;Receiver  : &quot; + hello);
    }
}</code></pre>
<p>4、测试</p>
<pre><code class="java">package com.neo.rabbitmq;

import com.neo.rabbit.hello.HelloSender;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
public class HelloTest {

    @Autowired
    private HelloSender helloSender;

    @Test
    public void hello() throws Exception {
        helloSender.send();
        // 等待三秒，使消费者确定可以消费到数据
        Thread.sleep(3000);
        System.out.println(&quot;exit&quot;);
    }
}</code></pre>
<p><strong>其他见自己的工程spring-boot-rabbitmq</strong></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h2><p>常用队列形式:</p>
<p>1、1对1</p>
<ul>
<li>简单队列: sender –&gt; queue –&gt; consumer</li>
<li>exchange的diect模式:sender –&gt; exchange –&gt; queue –&gt; consumer</li>
</ul>
<p>2、1对多</p>
<ul>
<li>简单队列: sender –&gt; queue –&gt; 多个consumer(默认轮询)</li>
<li>简单队列: sender –&gt; queue –&gt; 多个consumer(能者多劳,关闭自动ack)</li>
<li>exchange的订阅模式(fanout Exchange)</li>
<li>exchange的Topic(主题\通配符模式)</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">简凡丶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%85%A5%E9%97%A8/">http://yoursite.com/2020/01/15/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">BestBear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列    </a></div><div class="post_share"><div class="social-share" data-image="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"><img class="prev_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>全局异常处理</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/15/3.%20redis/redisUtil/"><img class="next_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>redis工具类</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/15/4. 消息队列/RocketMQ削峰实战/" title="RocketMQ 削峰实战！"><img class="relatedPosts_cover lazyload"data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-15</div><div class="relatedPosts_title">RocketMQ 削峰实战！</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/19/4. 消息队列/消息队列/" title="消息队列面试总结"><img class="relatedPosts_cover lazyload"data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-19</div><div class="relatedPosts_title">消息队列面试总结</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'POlJROSsMvr6BdUPhPaqFdlj-gzGzoHsz',
  appKey:'JhPOeqEkpBUGVUNuYYxRCvUt',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 简凡丶</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.5,"jsonPath":"/live2d_models/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":30,"vOffset":20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":0.6,"opacityOnHover":0.2},"log":false});</script></body></html>