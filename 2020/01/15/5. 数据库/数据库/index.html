<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>数据库 | BestBear</title><meta name="description" content="数据库"><meta name="keywords" content="数据库"><meta name="author" content="简凡丶"><meta name="copyright" content="简凡丶"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据库"><meta name="twitter:description" content="数据库"><meta name="twitter:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta property="og:type" content="article"><meta property="og:title" content="数据库"><meta property="og:url" content="http://yoursite.com/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"><meta property="og:site_name" content="BestBear"><meta property="og:description" content="数据库"><meta property="og:image" content="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/"><link rel="prev" title="网络相关基础" href="http://yoursite.com/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/"><link rel="next" title="Dubbo" href="http://yoursite.com/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BestBear</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/01/13/ViKAkpCRr5xde1j.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数据库三范式"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">数据库三范式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#count-1-、count-与count-列名-的区别"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">count(1)、count(*)与count(列名)的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#存储引擎"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">存储引擎</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#查看表的存储引擎"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">查看表的存储引擎</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#MyISAM和InnoDB区别"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">MyISAM和InnoDB区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#索引篇"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">索引篇</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引的数据结构-底层实现"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">索引的数据结构(底层实现)?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#B树和B-树区别"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">B树和B+树区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Hash索引和B-树所有有什么区别或者说优劣呢"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">Hash索引和B+树所有有什么区别或者说优劣呢?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么不对表中的每一个列创建一个索引呢？"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">为什么不对表中的每一个列创建一个索引呢？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么索引能提高查询速度"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">为什么索引能提高查询速度</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#先从-MySQL-的基本存储结构说起"><span class="toc_mobile_items-number">4.5.1.</span> <span class="toc_mobile_items-text">先从 MySQL 的基本存储结构说起</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#使用索引之后"><span class="toc_mobile_items-number">4.5.2.</span> <span class="toc_mobile_items-text">使用索引之后</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引类型"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">索引类型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主键索引-Primary-Key"><span class="toc_mobile_items-number">4.6.1.</span> <span class="toc_mobile_items-text">主键索引(Primary Key)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二级索引-辅助索引"><span class="toc_mobile_items-number">4.6.2.</span> <span class="toc_mobile_items-text">二级索引(辅助索引)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#聚集索引与非聚集索引"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">聚集索引与非聚集索引</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#聚集索引"><span class="toc_mobile_items-number">4.7.1.</span> <span class="toc_mobile_items-text">聚集索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#非聚集索引"><span class="toc_mobile_items-number">4.7.2.</span> <span class="toc_mobile_items-text">非聚集索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#非聚集索引一定回表查询吗-覆盖索引"><span class="toc_mobile_items-number">4.7.3.</span> <span class="toc_mobile_items-text">非聚集索引一定回表查询吗(覆盖索引)?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#覆盖索引"><span class="toc_mobile_items-number">4.7.4.</span> <span class="toc_mobile_items-text">覆盖索引</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引创建原则"><span class="toc_mobile_items-number">4.8.</span> <span class="toc_mobile_items-text">索引创建原则</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#最左前缀原则"><span class="toc_mobile_items-number">4.8.1.</span> <span class="toc_mobile_items-text">最左前缀原则</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#注意避免冗余索引"><span class="toc_mobile_items-number">4.8.2.</span> <span class="toc_mobile_items-text">注意避免冗余索引</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引不适合哪些场景"><span class="toc_mobile_items-number">4.9.</span> <span class="toc_mobile_items-text">索引不适合哪些场景</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一条SQL语句执行得很慢的原因有哪些？"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">一条SQL语句执行得很慢的原因有哪些？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#大多数情况是正常的，只是偶尔会出现很慢的情况。"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">大多数情况是正常的，只是偶尔会出现很慢的情况。</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#数据库在刷新脏页（flush）我也无奈啊"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">数据库在刷新脏页（flush）我也无奈啊</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#拿不到锁我能怎么办"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">拿不到锁我能怎么办</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#没用到索引"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">没用到索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#呵呵，数据库自己选错索引了"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">呵呵，数据库自己选错索引了</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一条SQL语句在MySQL中如何执行的"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">一条SQL语句在MySQL中如何执行的</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#MySQL高性能优化建议"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">MySQL高性能优化建议</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据库基本设计规范"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">数据库基本设计规范</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#所有表必须使用-Innodb-存储引擎"><span class="toc_mobile_items-number">7.1.1.</span> <span class="toc_mobile_items-text">所有表必须使用 Innodb 存储引擎</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#数据库和表的字符集统一使用-UTF8"><span class="toc_mobile_items-number">7.1.2.</span> <span class="toc_mobile_items-text">数据库和表的字符集统一使用 UTF8</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#尽量控制单表数据量的大小-建议控制在-500-万以内。"><span class="toc_mobile_items-number">7.1.3.</span> <span class="toc_mobile_items-text">尽量控制单表数据量的大小,建议控制在 500 万以内。</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#禁止从开发环境-测试环境直接连接生成环境数据库"><span class="toc_mobile_items-number">7.1.4.</span> <span class="toc_mobile_items-text">禁止从开发环境,测试环境直接连接生成环境数据库</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据库字段设计规范"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">数据库字段设计规范</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#优先选择符合存储需要的最小的数据类型"><span class="toc_mobile_items-number">7.2.1.</span> <span class="toc_mobile_items-text">优先选择符合存储需要的最小的数据类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#尽可能把所有列定义为-NOT-NULL"><span class="toc_mobile_items-number">7.2.2.</span> <span class="toc_mobile_items-text">尽可能把所有列定义为 NOT NULL</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-同财务相关的金额类数据必须使用-decimal-类型"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">6. 同财务相关的金额类数据必须使用 decimal 类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引设计规范"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">索引设计规范</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#限制每张表上的索引数量-建议单张表索引不超过-5-个"><span class="toc_mobile_items-number">7.4.1.</span> <span class="toc_mobile_items-text">限制每张表上的索引数量,建议单张表索引不超过 5 个</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#每个Innodb表必须有个主键"><span class="toc_mobile_items-number">7.4.2.</span> <span class="toc_mobile_items-text">每个Innodb表必须有个主键</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#常见索引列建议"><span class="toc_mobile_items-number">7.4.3.</span> <span class="toc_mobile_items-text">常见索引列建议</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#避免建立冗余索引（增加了查询优化器生成执行计划的时间）"><span class="toc_mobile_items-number">7.4.4.</span> <span class="toc_mobile_items-text">避免建立冗余索引（增加了查询优化器生成执行计划的时间）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#索引-SET-规范"><span class="toc_mobile_items-number">7.4.5.</span> <span class="toc_mobile_items-text">索引 SET 规范</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据库-SQL-开发规范"><span class="toc_mobile_items-number">7.5.</span> <span class="toc_mobile_items-text">数据库 SQL 开发规范</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#避免使用子查询，可以把子查询优化为-join-操作"><span class="toc_mobile_items-number">7.5.1.</span> <span class="toc_mobile_items-text">避免使用子查询，可以把子查询优化为 join 操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#拆分复杂的大-SQL-为多个小-SQL"><span class="toc_mobile_items-number">7.5.2.</span> <span class="toc_mobile_items-text">拆分复杂的大 SQL 为多个小 SQL</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#分库分表"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">分库分表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#binlog主从同步（主从不一致问题解决）"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">binlog主从同步（主从不一致问题解决）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#mysql复制的类型"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">mysql复制的类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#主从复制工作原理剖析"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">主从复制工作原理剖析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#主从复制延迟原因"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">主从复制延迟原因</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#主从复制数据丢失问题，半同步复制"><span class="toc_mobile_items-number">9.4.</span> <span class="toc_mobile_items-text">主从复制数据丢失问题，半同步复制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#缓解主从复制延迟问题"><span class="toc_mobile_items-number">9.5.</span> <span class="toc_mobile_items-text">缓解主从复制延迟问题</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库三范式"><span class="toc-number">1.</span> <span class="toc-text">数据库三范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count-1-、count-与count-列名-的区别"><span class="toc-number">2.</span> <span class="toc-text">count(1)、count(*)与count(列名)的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储引擎"><span class="toc-number">3.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看表的存储引擎"><span class="toc-number">3.1.</span> <span class="toc-text">查看表的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM和InnoDB区别"><span class="toc-number">3.2.</span> <span class="toc-text">MyISAM和InnoDB区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引篇"><span class="toc-number">4.</span> <span class="toc-text">索引篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的数据结构-底层实现"><span class="toc-number">4.1.</span> <span class="toc-text">索引的数据结构(底层实现)?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树和B-树区别"><span class="toc-number">4.2.</span> <span class="toc-text">B树和B+树区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash索引和B-树所有有什么区别或者说优劣呢"><span class="toc-number">4.3.</span> <span class="toc-text">Hash索引和B+树所有有什么区别或者说优劣呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不对表中的每一个列创建一个索引呢？"><span class="toc-number">4.4.</span> <span class="toc-text">为什么不对表中的每一个列创建一个索引呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么索引能提高查询速度"><span class="toc-number">4.5.</span> <span class="toc-text">为什么索引能提高查询速度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#先从-MySQL-的基本存储结构说起"><span class="toc-number">4.5.1.</span> <span class="toc-text">先从 MySQL 的基本存储结构说起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用索引之后"><span class="toc-number">4.5.2.</span> <span class="toc-text">使用索引之后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引类型"><span class="toc-number">4.6.</span> <span class="toc-text">索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主键索引-Primary-Key"><span class="toc-number">4.6.1.</span> <span class="toc-text">主键索引(Primary Key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二级索引-辅助索引"><span class="toc-number">4.6.2.</span> <span class="toc-text">二级索引(辅助索引)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聚集索引与非聚集索引"><span class="toc-number">4.7.</span> <span class="toc-text">聚集索引与非聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#聚集索引"><span class="toc-number">4.7.1.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非聚集索引"><span class="toc-number">4.7.2.</span> <span class="toc-text">非聚集索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非聚集索引一定回表查询吗-覆盖索引"><span class="toc-number">4.7.3.</span> <span class="toc-text">非聚集索引一定回表查询吗(覆盖索引)?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖索引"><span class="toc-number">4.7.4.</span> <span class="toc-text">覆盖索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引创建原则"><span class="toc-number">4.8.</span> <span class="toc-text">索引创建原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最左前缀原则"><span class="toc-number">4.8.1.</span> <span class="toc-text">最左前缀原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注意避免冗余索引"><span class="toc-number">4.8.2.</span> <span class="toc-text">注意避免冗余索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引不适合哪些场景"><span class="toc-number">4.9.</span> <span class="toc-text">索引不适合哪些场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一条SQL语句执行得很慢的原因有哪些？"><span class="toc-number">5.</span> <span class="toc-text">一条SQL语句执行得很慢的原因有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#大多数情况是正常的，只是偶尔会出现很慢的情况。"><span class="toc-number">5.1.</span> <span class="toc-text">大多数情况是正常的，只是偶尔会出现很慢的情况。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库在刷新脏页（flush）我也无奈啊"><span class="toc-number">5.1.1.</span> <span class="toc-text">数据库在刷新脏页（flush）我也无奈啊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拿不到锁我能怎么办"><span class="toc-number">5.1.2.</span> <span class="toc-text">拿不到锁我能怎么办</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。"><span class="toc-number">5.2.</span> <span class="toc-text">在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#没用到索引"><span class="toc-number">5.2.1.</span> <span class="toc-text">没用到索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#呵呵，数据库自己选错索引了"><span class="toc-number">5.2.2.</span> <span class="toc-text">呵呵，数据库自己选错索引了</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一条SQL语句在MySQL中如何执行的"><span class="toc-number">6.</span> <span class="toc-text">一条SQL语句在MySQL中如何执行的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL高性能优化建议"><span class="toc-number">7.</span> <span class="toc-text">MySQL高性能优化建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库基本设计规范"><span class="toc-number">7.1.</span> <span class="toc-text">数据库基本设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#所有表必须使用-Innodb-存储引擎"><span class="toc-number">7.1.1.</span> <span class="toc-text">所有表必须使用 Innodb 存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库和表的字符集统一使用-UTF8"><span class="toc-number">7.1.2.</span> <span class="toc-text">数据库和表的字符集统一使用 UTF8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#尽量控制单表数据量的大小-建议控制在-500-万以内。"><span class="toc-number">7.1.3.</span> <span class="toc-text">尽量控制单表数据量的大小,建议控制在 500 万以内。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止从开发环境-测试环境直接连接生成环境数据库"><span class="toc-number">7.1.4.</span> <span class="toc-text">禁止从开发环境,测试环境直接连接生成环境数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库字段设计规范"><span class="toc-number">7.2.</span> <span class="toc-text">数据库字段设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优先选择符合存储需要的最小的数据类型"><span class="toc-number">7.2.1.</span> <span class="toc-text">优先选择符合存储需要的最小的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#尽可能把所有列定义为-NOT-NULL"><span class="toc-number">7.2.2.</span> <span class="toc-text">尽可能把所有列定义为 NOT NULL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-同财务相关的金额类数据必须使用-decimal-类型"><span class="toc-number">7.3.</span> <span class="toc-text">6. 同财务相关的金额类数据必须使用 decimal 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引设计规范"><span class="toc-number">7.4.</span> <span class="toc-text">索引设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#限制每张表上的索引数量-建议单张表索引不超过-5-个"><span class="toc-number">7.4.1.</span> <span class="toc-text">限制每张表上的索引数量,建议单张表索引不超过 5 个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#每个Innodb表必须有个主键"><span class="toc-number">7.4.2.</span> <span class="toc-text">每个Innodb表必须有个主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见索引列建议"><span class="toc-number">7.4.3.</span> <span class="toc-text">常见索引列建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避免建立冗余索引（增加了查询优化器生成执行计划的时间）"><span class="toc-number">7.4.4.</span> <span class="toc-text">避免建立冗余索引（增加了查询优化器生成执行计划的时间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引-SET-规范"><span class="toc-number">7.4.5.</span> <span class="toc-text">索引 SET 规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库-SQL-开发规范"><span class="toc-number">7.5.</span> <span class="toc-text">数据库 SQL 开发规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#避免使用子查询，可以把子查询优化为-join-操作"><span class="toc-number">7.5.1.</span> <span class="toc-text">避免使用子查询，可以把子查询优化为 join 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拆分复杂的大-SQL-为多个小-SQL"><span class="toc-number">7.5.2.</span> <span class="toc-text">拆分复杂的大 SQL 为多个小 SQL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分库分表"><span class="toc-number">8.</span> <span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binlog主从同步（主从不一致问题解决）"><span class="toc-number">9.</span> <span class="toc-text">binlog主从同步（主从不一致问题解决）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql复制的类型"><span class="toc-number">9.1.</span> <span class="toc-text">mysql复制的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主从复制工作原理剖析"><span class="toc-number">9.2.</span> <span class="toc-text">主从复制工作原理剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主从复制延迟原因"><span class="toc-number">9.3.</span> <span class="toc-text">主从复制延迟原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主从复制数据丢失问题，半同步复制"><span class="toc-number">9.4.</span> <span class="toc-text">主从复制数据丢失问题，半同步复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓解主从复制延迟问题"><span class="toc-number">9.5.</span> <span class="toc-text">缓解主从复制延迟问题</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">数据库</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-01-15<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-10-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">8.1k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 24 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><p>范式就是规范，要满足第二范式必须先满足第一范式，要满足第三范式，必须要先满足第二范式。</p>
<ul>
<li>1NF(第一范式)：列数据不可分割，即一列不能有多个值</li>
<li>2NF(第二范式)：主键(每一行都有唯一标识)</li>
<li>3NF(第三范式)：外键(表中不包含已在其他表中包含的非主关键信息)</li>
</ul>
<h2 id="count-1-、count-与count-列名-的区别"><a href="#count-1-、count-与count-列名-的区别" class="headerlink" title="count(1)、count(*)与count(列名)的区别"></a>count(1)、count(*)与count(列名)的区别</h2><p>执行效果上： </p>
<p>count(*)=count(1)&lt;&gt;count(列名)</p>
<p>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL </p>
<p>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL </p>
<p>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空不统计。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="查看表的存储引擎"><a href="#查看表的存储引擎" class="headerlink" title="查看表的存储引擎"></a><strong>查看表的存储引擎</strong></h3><pre><code class="sql">show table status like &quot;table_name&quot; ;</code></pre>
<h3 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h3><ol>
<li><p><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
</li>
<li><p><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
</li>
<li><p><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</p>
</li>
<li><p><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：<a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MySQL-InnoDB-MVCC多版本并发控制</a></p>
<p>​        <code>MVCC协议</code>中,每个用户在连接数据库时看到的是一个具有一致性状态的镜像,每个事务在提交到数据库之前对其他用户均是不可见的。当事务需要更新数据时,不会直接覆盖以前的数据,而是生成—个新的版本的数据,因此一条数据会有多个版本存储,但是同一时刻只有最新的版本号是有效的。因此,读的时候就可以保证总是以当前时刻的版本的数据可以被读到,不论这条数据后来是否被修改或删除。</p>
<p><code>undo log</code>是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。</p>
</li>
</ol>
<ol start="5">
<li><strong>MyISAM</strong>主键索引是非聚集索引，存储的数据与索引分离，需要回表。而<strong>InnoDB</strong>主键索引是聚集索引。</li>
</ol>
<p>InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h2 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h2><h3 id="索引的数据结构-底层实现"><a href="#索引的数据结构-底层实现" class="headerlink" title="索引的数据结构(底层实现)?"></a>索引的数据结构(底层实现)?</h3><p>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.</p>
<h3 id="B树和B-树区别"><a href="#B树和B-树区别" class="headerlink" title="B树和B+树区别"></a>B树和B+树区别</h3><ul>
<li>B树的所有节点既存放键(key) 也存放数据(data)；而B+树只有叶子节点存放 key和data，其他内节点只存放key。</li>
<li>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点，有利于区间查找。</li>
<li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p>由于磁盘的读取也是按<strong>block</strong>块操作的（内存是按<strong>page</strong>页面操作的），因此B+树的节点大小一般设置为和磁盘块大小一致，这样一个B+树节点，就可以通过一次磁盘I/O把一个磁盘块的数据全部存储下来，<strong>所以当使用B-树存储索引的时候，磁盘I/O的操作次数是最少的</strong></p>
<p>那么MySQL最终为什么要采用B+树存储索引结构呢，那么看看B-树和B+树在存储结构上有什么不同？</p>
<ul>
<li>B-树的每一个节点，存了关键字和对应的数据地址，而B+树的非叶子节点只存关键字，不存数据地址。因此B+树的每一个非叶子节点存储的关键字是远远多于B-树的，B+树的叶子节点存放关键字和数据，因此，<strong>从树的高度上来说，B+树的高度要小于B-树，使用的磁盘I/O次数少，因此查询会更快一些。</strong></li>
<li>B-树由于每个节点都存储关键字和数据，因此离根节点进的数据，查询的就快，离根节点远的数据，查询的就慢；B+树所有的数据都存在叶子节点上，因此在B+树上搜索关键字，找到对应数据的<strong>时间是比较平均</strong>的，没有快慢之分。</li>
<li>在B-树上如果做区间查找，遍历的节点是非常多的；B+树所有叶子节点被连接成了有序链表结构，因此做整表遍历和<strong>区间查找是非常容易</strong>的。</li>
</ul>
<p>经过优化的B+树，主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。</p>
<p><img alt="image-20200527195106340" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf793blg6mj30eh084jul.jpg" class="lazyload"></p>
<p><img alt="image-20200527195115403" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf793gwpn1j30dz09m0x6.jpg" class="lazyload"></p>
<p>B树</p>
<p><img alt="image-20200527195146433" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf7940mxe1j308907mdgu.jpg" class="lazyload"></p>
<h3 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a><strong>Hash索引和B+树所有有什么区别或者说优劣呢?</strong></h3><p>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p>
<p>hash索引不支持使用索引进行排序,模糊查询</p>
<h3 id="为什么不对表中的每一个列创建一个索引呢？"><a href="#为什么不对表中的每一个列创建一个索引呢？" class="headerlink" title="为什么不对表中的每一个列创建一个索引呢？"></a>为什么不对表中的每一个列创建一个索引呢？</h3><p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<h3 id="为什么索引能提高查询速度"><a href="#为什么索引能提高查询速度" class="headerlink" title="为什么索引能提高查询速度"></a>为什么索引能提高查询速度</h3><h4 id="先从-MySQL-的基本存储结构说起"><a href="#先从-MySQL-的基本存储结构说起" class="headerlink" title="先从 MySQL 的基本存储结构说起"></a>先从 MySQL 的基本存储结构说起</h4><p>MySQL的基本存储结构是页(记录都存在页里边)：</p>
<p><img alt="image-20200527165933957" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf744uarg0j30lw0hewj5.jpg" class="lazyload"></p>
<p><img alt="image-20200527165912250" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf744gnf4jj30yy0cd46k.jpg" class="lazyload"></p>
<ul>
<li><strong>各个数据页可以组成一个双向链表</strong></li>
<li>每个数据页中的记录又可以组成一个单向链表<ul>
<li>每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li>
<li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li>
</ul>
</li>
</ul>
<p>所以说，如果我们写select * from user where indexname = ‘xxx’这样没有进行任何优化的sql语句，默认会这样做：</p>
<ol>
<li><strong>定位到记录所在的页：需要遍历双向链表，找到所在的页</strong></li>
<li><strong>从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了</strong></li>
</ol>
<p>很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。</p>
<h4 id="使用索引之后"><a href="#使用索引之后" class="headerlink" title="使用索引之后"></a>使用索引之后</h4><p>索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：</p>
<p><img alt="image-20200527165842152" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf743xob4oj30zh0itgyz.jpg" class="lazyload"></p>
<p>要找到id为8的记录简要步骤：</p>
<p><img alt="image-20200527165814369" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf743gld1lj30zd0jmndj.jpg" class="lazyload"></p>
<p>很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 <strong>“目录”</strong> 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）</p>
<p>其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h4><p><strong>数据表的主键列使用的就是主键索引。</strong></p>
<p><strong>一张数据表有只能有一个主键，并且主键不能为null，不能重复。</strong></p>
<p>在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。</p>
<h4 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h4><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<ol>
<li><p><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。</strong>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p>
</li>
<li><p><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</strong></p>
</li>
<li><p><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</p>
</li>
<li><p><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。</p>
</li>
</ol>
<h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p><code>聚集索引的优点</code></p>
<p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p><code>聚集索引的缺点</code></p>
<ol>
<li><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>
<p><strong>二级索引属于非聚集索引。</strong></p>
<p>非聚集索引的叶子节点存放的是主键+列值， 需要根据主键再回表查数据。</p>
<p><code>非聚集索引的优点</code></p>
<p><strong>更新代价比聚集索引要小</strong>,因为非聚集索引的叶子节点是不存放数据的</p>
<p><code>非聚集索引的缺点</code></p>
<ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<h4 id="非聚集索引一定回表查询吗-覆盖索引"><a href="#非聚集索引一定回表查询吗-覆盖索引" class="headerlink" title="非聚集索引一定回表查询吗(覆盖索引)?"></a>非聚集索引一定回表查询吗(覆盖索引)?</h4><p><strong>非聚集索引不一定回表查询。</strong></p>
<blockquote>
<p>试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。</p>
</blockquote>
<pre><code class="sql"> SELECT name FROM table WHERE username=&#39;guang19&#39;;</code></pre>
<blockquote>
<p>那么这个索引的key本身就是name，查到对应的name直接返回就行了，无需回表查询。</p>
</blockquote>
<p><strong>即使是MYISAM也是这样，虽然MYISAM的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢?</strong></p>
<pre><code class="sql">SELECT id FROM table WHERE id=1;</code></pre>
<p>主键索引本身的key就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条SQL需要查询name，name字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<hr>
<h3 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h3><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
<h4 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h4><p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<h3 id="索引不适合哪些场景"><a href="#索引不适合哪些场景" class="headerlink" title="索引不适合哪些场景"></a><strong>索引不适合哪些场景</strong></h3><ul>
<li>数据量少的不适合加索引</li>
<li>更新比较频繁的也不适合加索引</li>
<li>区分度低的字段不适合加索引（如性别） 对比 部件表 rest_status_id 就不需要添加索引。</li>
</ul>
<p>​    索引区分度越明显，查询效率越高</p>
<hr>
<h2 id="一条SQL语句执行得很慢的原因有哪些？"><a href="#一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="一条SQL语句执行得很慢的原因有哪些？"></a>一条SQL语句执行得很慢的原因有哪些？</h2><h3 id="大多数情况是正常的，只是偶尔会出现很慢的情况。"><a href="#大多数情况是正常的，只是偶尔会出现很慢的情况。" class="headerlink" title="大多数情况是正常的，只是偶尔会出现很慢的情况。"></a>大多数情况是正常的，只是偶尔会出现很慢的情况。</h3><h4 id="数据库在刷新脏页（flush）我也无奈啊"><a href="#数据库在刷新脏页（flush）我也无奈啊" class="headerlink" title="数据库在刷新脏页（flush）我也无奈啊"></a>数据库在刷新脏页（flush）我也无奈啊</h4><p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p>
<blockquote>
<p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>
</blockquote>
<p><strong>刷脏页有下面4种场景（后两种不用太关注“性能”问题）：</strong></p>
<ul>
<li><strong>redolog写满了：</strong>redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</li>
<li><strong>内存不够用了：</strong>如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li>
</ul>
<h4 id="拿不到锁我能怎么办"><a href="#拿不到锁我能怎么办" class="headerlink" title="拿不到锁我能怎么办"></a>拿不到锁我能怎么办</h4><p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p>
<h3 id="在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。"><a href="#在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。" class="headerlink" title="在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。"></a>在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</h3><h4 id="没用到索引"><a href="#没用到索引" class="headerlink" title="没用到索引"></a>没用到索引</h4><p><strong>（1）、字段没有索引</strong></p>
<p><strong>（2）、字段有索引，但却没有用索引</strong></p>
<ul>
<li>以“%”开头的LIKE语句，模糊匹配</li>
<li>OR语句前后没有同时使用索引</li>
</ul>
<h4 id="呵呵，数据库自己选错索引了"><a href="#呵呵，数据库自己选错索引了" class="headerlink" title="呵呵，数据库自己选错索引了"></a>呵呵，数据库自己选错索引了</h4><p>我们在进行查询操作的时候，例如</p>
<pre><code>select * from t where 100 &lt; c and c &lt; 100000;</code></pre><p>我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>.也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p>
<p>好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 &lt; c and c &lt; 100000 的数据。</p>
<p><strong>为什么会这样呢？</strong></p>
<p>其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。</p>
<p>如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c &lt; and c &lt; 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。</p>
<p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p>
<p>判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p>
<p>那么问题来了，<strong>系统是怎么预测判断的呢？</strong></p>
<p>居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p>
<p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p>
<blockquote>
<p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p>
</blockquote>
<p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p>
<pre><code class="sql">select * from t force index(a) where c &lt; 100 and c &lt; 100000;</code></pre>
<p>我们也可以通过</p>
<pre><code class="sql">show index from t;</code></pre>
<p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p>
<pre><code class="sql">analyze table t;</code></pre>
<p>来重新统计分析。</p>
<p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p>
<h2 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h2><p><strong>•连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p>
<p>•<strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</p>
<p>•<strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p>
<p>•<strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p>
<p>•<strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</p>
<p><img alt="image-20200527193005072" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf78hg9f9yj30mw0pztdv.jpg" class="lazyload"></p>
<h2 id="MySQL高性能优化建议"><a href="#MySQL高性能优化建议" class="headerlink" title="MySQL高性能优化建议"></a>MySQL高性能优化建议</h2><hr>
<h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><h4 id="所有表必须使用-Innodb-存储引擎"><a href="#所有表必须使用-Innodb-存储引擎" class="headerlink" title="所有表必须使用 Innodb 存储引擎"></a>所有表必须使用 Innodb 存储引擎</h4><p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。</p>
<p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>
<h4 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="数据库和表的字符集统一使用 UTF8"></a>数据库和表的字符集统一使用 UTF8</h4><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>
<h4 id="尽量控制单表数据量的大小-建议控制在-500-万以内。"><a href="#尽量控制单表数据量的大小-建议控制在-500-万以内。" class="headerlink" title="尽量控制单表数据量的大小,建议控制在 500 万以内。"></a>尽量控制单表数据量的大小,建议控制在 500 万以内。</h4><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>
<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h4 id="禁止从开发环境-测试环境直接连接生成环境数据库"><a href="#禁止从开发环境-测试环境直接连接生成环境数据库" class="headerlink" title="禁止从开发环境,测试环境直接连接生成环境数据库"></a>禁止从开发环境,测试环境直接连接生成环境数据库</h4><hr>
<h3 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h3><h4 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h4><p><strong>a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></p>
<p>MySQL 提供了两个方法来处理 ip 地址</p>
<p>•inet_aton 把 ip 转为无符号整型 (4-8 位)•inet_ntoa 把整型的 ip 转为地址</p>
<p>插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。</p>
<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储</strong></p>
<p><strong>原因：</strong></p>
<p>无符号相对于有符号可以多出一倍的存储空间</p>
<pre><code>SIGNED INT -2147483648~2147483647UNSIGNED INT 0~429496729</code></pre><h4 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="尽可能把所有列定义为 NOT NULL"></a>尽可能把所有列定义为 NOT NULL</h4><p><strong>原因：</strong></p>
<p>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间</p>
<p>进行比较和计算时要对 NULL 值做特别的处理</p>
<h3 id="6-同财务相关的金额类数据必须使用-decimal-类型"><a href="#6-同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="6. 同财务相关的金额类数据必须使用 decimal 类型"></a>6. 同财务相关的金额类数据必须使用 decimal 类型</h3><p>•非精准浮点：float,double</p>
<p>•精准浮点：decimal</p>
<p>Decimal 类型为精准浮点数，在计算时不会丢失精度</p>
<p>可用于存储比 bigint 更大的整型数据</p>
<hr>
<h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><h4 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<h4 id="每个Innodb表必须有个主键"><a href="#每个Innodb表必须有个主键" class="headerlink" title="每个Innodb表必须有个主键"></a>每个Innodb表必须有个主键</h4><p><strong>Innodb</strong> 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>
<p><strong>Innodb</strong> 是按照主键索引的顺序来组织表的</p>
<p>•不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</p>
<p>•不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</p>
<p>•主键建议使用自增 ID 值</p>
<hr>
<h4 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h4><p>1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 </p>
<p>2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式 。</p>
<hr>
<h4 id="避免建立冗余索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引（增加了查询优化器生成执行计划的时间）</h4><p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<hr>
<h4 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h4><p><strong>尽量避免使用外键约束</strong></p>
<p>•不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引•外键可用于保证数据的参照完整性，但建议在业务端实现•外键会影响父表和子表的写操作从而降低性能</p>
<hr>
<h3 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h3><h4 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h4><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>
<p><strong>子查询性能差的原因：</strong></p>
<p>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
<p>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>
<h4 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h4><p>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL•MySQL 中，一个 SQL 只能使用一个 CPU 进行计算•SQL 拆分后可以通过并行执行来提高处理效率</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard.md" target="_blank" rel="noopener">为什么要分库分表（设计高并发系统的时候，数据库层面该如何设计）？用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？你们具体是如何对数据库如何进行垂直拆分或水平拆分的？</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-method.md" target="_blank" rel="noopener">现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-dynamic-expand.md" target="_blank" rel="noopener">如何设计可以动态扩容缩容的分库分表方案？</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-global-id-generate.md" target="_blank" rel="noopener">分库分表之后，id 主键如何处理？</a></li>
</ul>
<h2 id="binlog主从同步（主从不一致问题解决）"><a href="#binlog主从同步（主从不一致问题解决）" class="headerlink" title="binlog主从同步（主从不一致问题解决）"></a>binlog主从同步（主从不一致问题解决）</h2><h3 id="mysql复制的类型"><a href="#mysql复制的类型" class="headerlink" title="mysql复制的类型"></a>mysql复制的类型</h3><p>1.基于语句的复制 ：主库把sql语句写入到bin log中，完成复制<br> 2.基于行数据的复制：主库把每一行数据变化的信息作为事件，写入到bin log，完成复制<br> 3.混合复制：上面两个结合体，默认用语句复制，出问题时候自动切换成行数据复制</p>
<h3 id="主从复制工作原理剖析"><a href="#主从复制工作原理剖析" class="headerlink" title="主从复制工作原理剖析"></a>主从复制工作原理剖析</h3><p>1、Master 数据库只要发生变化，立马记录到Binary log 日志文件中<br>2、Slave数据库启动一个I/O thread连接Master数据库，请求Master变化的二进制日志<br>3、Slave I/O获取到的二进制日志，保存到自己的Relay log 日志文件中。<br>4、Slave 有一个 SQL 线程定时检查Realy log是否变化，变化那么就更新数据。</p>
<p><img alt="image-20200811095721600" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghmn10h564j30sg0k0dos.jpg" class="lazyload"></p>
<h3 id="主从复制延迟原因"><a href="#主从复制延迟原因" class="headerlink" title="主从复制延迟原因"></a>主从复制延迟原因</h3><p>从库从主库通过的过程是串行化的（写binlog、读取到relaylog），所以会有一定的延迟，为<code>主从延迟</code>。经验来说，主库写并发为1000，从库延迟为几毫秒，写并发为2000，从库延迟为几十毫秒，写并发为6000-8000，从库延迟为几秒，此时主库快崩溃了。</p>
<h3 id="主从复制数据丢失问题，半同步复制"><a href="#主从复制数据丢失问题，半同步复制" class="headerlink" title="主从复制数据丢失问题，半同步复制"></a>主从复制数据丢失问题，半同步复制</h3><p><code>半同步复制</code>防止主数据库down了造成数据丢失，至少一个从库写入到relaylog日志里，主库才会认为写入成功了。</p>
<h3 id="缓解主从复制延迟问题"><a href="#缓解主从复制延迟问题" class="headerlink" title="缓解主从复制延迟问题"></a>缓解主从复制延迟问题</h3><p><code>问题现象：</code></p>
<p>插入一条数据，查出这条数据，更新这条数据。高峰期每秒2000多写并发，造成从库没查到。</p>
<p><code>解决：</code></p>
<p>1、写relayLog日志需多个线程。</p>
<p>2、<code>并行复制</code>mysql5.7可开启多个sql线程从relay日志去读取，缓解主从延迟问题。</p>
<p>3、将一个主库拆分为多个主库，降低主库的写并发。</p>
<p>4、可以将核心业务的查操作直连主库，但是不太建议这点，违背了读写分离的初衷。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">简凡丶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/">http://yoursite.com/2020/01/15/5.%20%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">BestBear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库    </a></div><div class="post_share"><div class="social-share" data-image="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/15/1.%20Java%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/"><img class="prev_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>网络相关基础</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/15/7.%20%E5%88%86%E5%B8%83%E5%BC%8F/Dubbo/"><img class="next_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Dubbo</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/15/5. 数据库/数据量很大，分页查询很慢，有什么优化方案？/" title="数据库优化"><img class="relatedPosts_cover lazyload"data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-15</div><div class="relatedPosts_title">数据库优化</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/15/5. 数据库/aop读写分离实战/" title="aop实现读写分离"><img class="relatedPosts_cover lazyload"data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-15</div><div class="relatedPosts_title">aop实现读写分离</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'POlJROSsMvr6BdUPhPaqFdlj-gzGzoHsz',
  appKey:'JhPOeqEkpBUGVUNuYYxRCvUt',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 简凡丶</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.5,"jsonPath":"/live2d_models/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":30,"vOffset":20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":0.6,"opacityOnHover":0.2},"log":false});</script></body></html>