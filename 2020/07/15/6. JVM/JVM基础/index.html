<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>JVM基础 | BestBear</title><meta name="description" content="JVM基础"><meta name="keywords" content="JVM"><meta name="author" content="简凡丶"><meta name="copyright" content="简凡丶"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM基础"><meta name="twitter:description" content="JVM基础"><meta name="twitter:image" content="http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg"><meta property="og:type" content="article"><meta property="og:title" content="JVM基础"><meta property="og:url" content="http://yoursite.com/2020/07/15/6.%20JVM/JVM%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="BestBear"><meta property="og:description" content="JVM基础"><meta property="og:image" content="http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/07/15/6.%20JVM/JVM%E5%9F%BA%E7%A1%80/"><link rel="prev" title="一次jvm问题排查过程" href="http://yoursite.com/2020/07/15/6.%20JVM/%E4%B8%80%E6%AC%A1jvm%E9%97%AE%E9%A2%98/"><link rel="next" title="消息队列面试总结" href="http://yoursite.com/2020/05/19/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BestBear</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/01/13/ViKAkpCRr5xde1j.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">35</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-coffee"></i><span> 关于作者</span></a></div><div class="menus_item"><a class="site-page" href="/guestsay/"><i class="fa-fw fa-coffee"></i><span> 留言板</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#JVM基础"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">JVM基础</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#简介："><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">简介：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java-中都有哪些引用类型？"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Java 中都有哪些引用类型？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Java内存区域"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Java内存区域</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#说一下-JVM-的主要组成部分及其作用？"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">说一下 JVM 的主要组成部分及其作用？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JVM的方法区和永久带是什么关系？"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">JVM的方法区和永久带是什么关系？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CodeCache"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">CodeCache</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#JIT简介"><span class="toc_mobile_items-number">4.4.1.</span> <span class="toc_mobile_items-text">JIT简介</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#说一下-JVM-运行时数据区"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">说一下 JVM 运行时数据区</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#分别介绍"><span class="toc_mobile_items-number">4.5.1.</span> <span class="toc_mobile_items-text">分别介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Java-虚拟机栈会出现两种错误："><span class="toc_mobile_items-number">4.5.2.</span> <span class="toc_mobile_items-text">Java 虚拟机栈会出现两种错误：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#虚拟机栈和虚拟机堆区别"><span class="toc_mobile_items-number">4.5.3.</span> <span class="toc_mobile_items-text">虚拟机栈和虚拟机堆区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Java文件完整的加载运行过程"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">Java文件完整的加载运行过程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#类加载器"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">类加载器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类加载器的流程（加校准解初使卸）"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">类加载器的流程（加校准解初使卸）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#加载"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">加载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#链接"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">链接</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#初始化"><span class="toc_mobile_items-number">5.1.3.</span> <span class="toc_mobile_items-text">初始化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#卸载"><span class="toc_mobile_items-number">5.1.4.</span> <span class="toc_mobile_items-text">卸载</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类加载器的加载顺序"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">类加载器的加载顺序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#双亲委派机制"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">双亲委派机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#自定义ClassLoader"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">自定义ClassLoader</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#基本用法"><span class="toc_mobile_items-number">5.4.1.</span> <span class="toc_mobile_items-text">基本用法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#用途"><span class="toc_mobile_items-number">5.4.2.</span> <span class="toc_mobile_items-text">用途</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#虚拟机堆"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">虚拟机堆</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#组成"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">组成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#垃圾回收的过程"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">垃圾回收的过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#动态年龄判断"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">动态年龄判断</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何判断一个对象需要被干掉"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">如何判断一个对象需要被干掉</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何宣告一个对象的真正死亡"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text">如何宣告一个对象的真正死亡</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#逃逸分析"><span class="toc_mobile_items-number">6.6.</span> <span class="toc_mobile_items-text">逃逸分析</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#垃圾回收算法"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">垃圾回收算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#复制算法"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">复制算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#标记清除算法"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">标记清除算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#标记整理算法"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">标记整理算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分代收集算法"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">分代收集算法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#垃圾回收器"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">垃圾回收器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#CMS垃圾回收器"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">CMS垃圾回收器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#G1-垃圾收集器"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">G1 垃圾收集器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#JVM的常用参数"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">JVM的常用参数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#通用参数"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">通用参数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#G1-GC的参数选项"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">G1 GC的参数选项</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关于JVM调优的一些方面"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">关于JVM调优的一些方面</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调整最大堆内存和最小堆内存"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text">调整最大堆内存和最小堆内存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调整新生代和老年代的比值"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text">调整新生代和老年代的比值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调整Survivor区和Eden区的比值"><span class="toc_mobile_items-number">12.3.</span> <span class="toc_mobile_items-text">调整Survivor区和Eden区的比值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#设置年轻代和老年代的大小"><span class="toc_mobile_items-number">12.4.</span> <span class="toc_mobile_items-text">设置年轻代和老年代的大小</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#小总结"><span class="toc_mobile_items-number">12.5.</span> <span class="toc_mobile_items-text">小总结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#永久区的设置"><span class="toc_mobile_items-number">12.6.</span> <span class="toc_mobile_items-text">永久区的设置</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JVM的栈参数调优"><span class="toc_mobile_items-number">12.7.</span> <span class="toc_mobile_items-text">JVM的栈参数调优</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#调整每个线程栈空间的大小"><span class="toc_mobile_items-number">12.7.1.</span> <span class="toc_mobile_items-text">调整每个线程栈空间的大小</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设置线程栈的大小"><span class="toc_mobile_items-number">12.7.2.</span> <span class="toc_mobile_items-text">设置线程栈的大小</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#JVM其他参数介绍"><span class="toc_mobile_items-number">12.8.</span> <span class="toc_mobile_items-text">JVM其他参数介绍</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设置垃圾最大年龄"><span class="toc_mobile_items-number">12.8.1.</span> <span class="toc_mobile_items-text">设置垃圾最大年龄</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设置堆空间存活时间"><span class="toc_mobile_items-number">12.8.2.</span> <span class="toc_mobile_items-text">设置堆空间存活时间</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设置对象直接分配在老年代"><span class="toc_mobile_items-number">12.8.3.</span> <span class="toc_mobile_items-text">设置对象直接分配在老年代</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设置TLAB占eden区的比例"><span class="toc_mobile_items-number">12.8.4.</span> <span class="toc_mobile_items-text">设置TLAB占eden区的比例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#设置是否优先YGC"><span class="toc_mobile_items-number">12.8.5.</span> <span class="toc_mobile_items-text">设置是否优先YGC</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM基础"><span class="toc-number">1.</span> <span class="toc-text">JVM基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介："><span class="toc-number">2.</span> <span class="toc-text">简介：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-中都有哪些引用类型？"><span class="toc-number">3.</span> <span class="toc-text">Java 中都有哪些引用类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存区域"><span class="toc-number">4.</span> <span class="toc-text">Java内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说一下-JVM-的主要组成部分及其作用？"><span class="toc-number">4.1.</span> <span class="toc-text">说一下 JVM 的主要组成部分及其作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM的方法区和永久带是什么关系？"><span class="toc-number">4.2.</span> <span class="toc-text">JVM的方法区和永久带是什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><span class="toc-number">4.3.</span> <span class="toc-text">为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeCache"><span class="toc-number">4.4.</span> <span class="toc-text">CodeCache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JIT简介"><span class="toc-number">4.4.1.</span> <span class="toc-text">JIT简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说一下-JVM-运行时数据区"><span class="toc-number">4.5.</span> <span class="toc-text">说一下 JVM 运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分别介绍"><span class="toc-number">4.5.1.</span> <span class="toc-text">分别介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-虚拟机栈会出现两种错误："><span class="toc-number">4.5.2.</span> <span class="toc-text">Java 虚拟机栈会出现两种错误：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟机栈和虚拟机堆区别"><span class="toc-number">4.5.3.</span> <span class="toc-text">虚拟机栈和虚拟机堆区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java文件完整的加载运行过程"><span class="toc-number">4.6.</span> <span class="toc-text">Java文件完整的加载运行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-number">5.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的流程（加校准解初使卸）"><span class="toc-number">5.1.</span> <span class="toc-text">类加载器的流程（加校准解初使卸）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加载"><span class="toc-number">5.1.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链接"><span class="toc-number">5.1.2.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-number">5.1.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卸载"><span class="toc-number">5.1.4.</span> <span class="toc-text">卸载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器的加载顺序"><span class="toc-number">5.2.</span> <span class="toc-text">类加载器的加载顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">5.3.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义ClassLoader"><span class="toc-number">5.4.</span> <span class="toc-text">自定义ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-number">5.4.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用途"><span class="toc-number">5.4.2.</span> <span class="toc-text">用途</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机堆"><span class="toc-number">6.</span> <span class="toc-text">虚拟机堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#组成"><span class="toc-number">6.1.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收的过程"><span class="toc-number">6.2.</span> <span class="toc-text">垃圾回收的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态年龄判断"><span class="toc-number">6.3.</span> <span class="toc-text">动态年龄判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断一个对象需要被干掉"><span class="toc-number">6.4.</span> <span class="toc-text">如何判断一个对象需要被干掉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何宣告一个对象的真正死亡"><span class="toc-number">6.5.</span> <span class="toc-text">如何宣告一个对象的真正死亡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逃逸分析"><span class="toc-number">6.6.</span> <span class="toc-text">逃逸分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收算法"><span class="toc-number">7.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复制算法"><span class="toc-number">7.1.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记清除算法"><span class="toc-number">7.2.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记整理算法"><span class="toc-number">7.3.</span> <span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集算法"><span class="toc-number">7.4.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收器"><span class="toc-number">8.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMS垃圾回收器"><span class="toc-number">9.</span> <span class="toc-text">CMS垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1-垃圾收集器"><span class="toc-number">10.</span> <span class="toc-text">G1 垃圾收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM的常用参数"><span class="toc-number">11.</span> <span class="toc-text">JVM的常用参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用参数"><span class="toc-number">11.1.</span> <span class="toc-text">通用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-GC的参数选项"><span class="toc-number">11.2.</span> <span class="toc-text">G1 GC的参数选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于JVM调优的一些方面"><span class="toc-number">12.</span> <span class="toc-text">关于JVM调优的一些方面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调整最大堆内存和最小堆内存"><span class="toc-number">12.1.</span> <span class="toc-text">调整最大堆内存和最小堆内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调整新生代和老年代的比值"><span class="toc-number">12.2.</span> <span class="toc-text">调整新生代和老年代的比值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调整Survivor区和Eden区的比值"><span class="toc-number">12.3.</span> <span class="toc-text">调整Survivor区和Eden区的比值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置年轻代和老年代的大小"><span class="toc-number">12.4.</span> <span class="toc-text">设置年轻代和老年代的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小总结"><span class="toc-number">12.5.</span> <span class="toc-text">小总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#永久区的设置"><span class="toc-number">12.6.</span> <span class="toc-text">永久区的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM的栈参数调优"><span class="toc-number">12.7.</span> <span class="toc-text">JVM的栈参数调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调整每个线程栈空间的大小"><span class="toc-number">12.7.1.</span> <span class="toc-text">调整每个线程栈空间的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置线程栈的大小"><span class="toc-number">12.7.2.</span> <span class="toc-text">设置线程栈的大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM其他参数介绍"><span class="toc-number">12.8.</span> <span class="toc-text">JVM其他参数介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设置垃圾最大年龄"><span class="toc-number">12.8.1.</span> <span class="toc-text">设置垃圾最大年龄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置堆空间存活时间"><span class="toc-number">12.8.2.</span> <span class="toc-text">设置堆空间存活时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置对象直接分配在老年代"><span class="toc-number">12.8.3.</span> <span class="toc-text">设置对象直接分配在老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置TLAB占eden区的比例"><span class="toc-number">12.8.4.</span> <span class="toc-text">设置TLAB占eden区的比例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置是否优先YGC"><span class="toc-number">12.8.5.</span> <span class="toc-text">设置是否优先YGC</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">JVM基础</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-07-15<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-10-23</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JVM/">JVM</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">10.6k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 33 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="JVM基础"><a href="#JVM基础" class="headerlink" title="JVM基础"></a>JVM基础</h2><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>本文介绍了一些常见的JVM中的面试题</p>
<hr>
<h2 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h2><ul>
<li><p><code>强引用：</code>发生 gc 的时候不会被回收。</p>
<p>之前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。比如下面这段代码中的object和str都是强引用：</p>
<pre><code class="java">Object object = new Object();
String str = &quot;StrongReference&quot;;</code></pre>
</li>
<li><p><code>软引用：</code>有用但不是必须的对象，在发生内存溢出之前会被回收。在Java中用java.lang.ref.SoftReference类来表示。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>
</li>
<li><p><code>弱引用：</code>有用但不是必须的对象，在下一次GC时会被回收。应用场景：如果一个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么应该用 Weak Reference 来记住此对象。或者想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候就应该用弱引用，这个引用不会在对象的垃圾回收判断中产生任何附加的影响。</p>
</li>
<li><p><code>虚引用：</code>和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动。</p>
</li>
</ul>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="说一下-JVM-的主要组成部分及其作用？"><a href="#说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分及其作用？"></a>说一下 JVM 的主要组成部分及其作用？</h3><p><img alt="image-20200607182848130" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjwj4acnpj31ho0tkwvt.jpg" class="lazyload"></p>
<p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p>
<ul>
<li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li>
<li>Execution engine（执行引擎）：执行classes中的指令。</li>
<li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li>
</ul>
<p><strong>作用</strong> ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h3 id="JVM的方法区和永久带是什么关系？"><a href="#JVM的方法区和永久带是什么关系？" class="headerlink" title="JVM的方法区和永久带是什么关系？"></a>JVM的方法区和永久带是什么关系？</h3><p>（1）方法区是规范层面的东西，规定了这一个区域要存放哪些东西</p>
<p>（2）永久带或者是metaspace是对方法区的不同实现，是实现层面的东西。</p>
<h3 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?"></a>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h3><ol>
<li><p>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。间接性地解决了永久代的OOM问题。</p>
<pre><code>MetaspaceSize：初始化元空间大小，控制发生GC
MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</code></pre></li>
<li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
<h3 id="CodeCache"><a href="#CodeCache" class="headerlink" title="CodeCache"></a>CodeCache</h3><h4 id="JIT简介"><a href="#JIT简介" class="headerlink" title="JIT简介"></a>JIT简介</h4><p>JIT是just in time的缩写，也就是即时编译。通过JIT技术，能够做到Java程序执行速度的加速。那么，是怎么做到的呢？</p>
<p>我们都知道，Java是一门解释型语言（或者说是半编译，半解释型语言）。Java通过编译器javac先将源程序编译成与平台无关的Java字节码文件（.class），再由JVM解释执行字节码文件，从而做到平台无关。 但是，有利必有弊。对字节码的解释执行过程实质为：<strong>JVM先将字节码翻译为对应的机器指令，然后执行机器指令。</strong>很显然，这样经过解释执行，其执行速度必然不如直接执行二进制字节码文件。</p>
<p>而为了提高执行速度，便引入了 JIT 技术。通过<code>热点探测</code>，<strong>当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。</strong></p>
<p><strong><img alt="img" data-src="https://img-blog.csdnimg.cn/20190101150248567.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTAyNjg0,size_16,color_FFFFFF,t_70" class="lazyload"></strong></p>
<p><code>codecache</code>代码缓存区,主要存放JIT所编译的代码,同时还有Java所使用的本地方法代码也会存储在codecache中.</p>
<p><code>相关参数:</code></p>
<p><code>-XX:ReservedCodeCacheSize</code>  ：设置codeCache的size大小</p>
<p>一种推荐的设置思路是设置为当前值（或者默认值）的2倍 对于64位jvm，由于内存空间足够大，codeCache设置的过大不会对应用产生明显影响</p>
<p><code>-XX:+UseCodeCacheFlushing</code> ：启用code cache的回收机制。</p>
<ul>
<li>当codeCache将要耗尽时，最早被编译的一半方法将会被放到一个old列表中等待回收,在一定时间间隔内，如果方法没有被调用，这个方法就会被从codeCache充清除</li>
</ul>
<p>在jdk8中，提供了一个启动参数XX:+PrintCodeCache在jvm停止的时候打印出codeCache的使用情况</p>
<p>由于JIT是随着代码被调用的次数达到CompileThreshold之后进行的，因此，codecache使用也会随之增加，常见的问题就是，随着时间的推移应用占用CPU会随之增高，请求相应变慢等问题，这时就需要考虑codecache的问题了。</p>
<h3 id="说一下-JVM-运行时数据区"><a href="#说一下-JVM-运行时数据区" class="headerlink" title="说一下 JVM 运行时数据区"></a>说一下 JVM 运行时数据区</h3><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域</strong>。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：</p>
<p><img alt="image-20200610123657999" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn37yjhp4j30iq0czwh3.jpg" class="lazyload"></p>
<h4 id="分别介绍"><a href="#分别介绍" class="headerlink" title="分别介绍"></a>分别介绍</h4><ul>
<li><code>程序计数器</code>：程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</li>
<li><code>虚拟机栈</code>：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<ul>
<li>每个栈帧都存放以上4个信息，每个栈帧是一个<strong>方法</strong></li>
<li><strong>局部变量表</strong>，存放局部变量，例如int a=2;</li>
<li><strong>操作数栈</strong>存放帮助栈帧进行运算的临时操作数。</li>
<li><strong>动态链接</strong>：通过javap命令查看class文件，可以看到很多符号引用，在类加载的过程（静态链接）或运行过程会将部分符号引用在运行期间转化为直接引用。直接引用可被jvm通过命令调用。</li>
</ul>
</li>
<li><code>本地方法栈</code>：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>
<li><code>Java堆</code>：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>
<li><code>方法区</code>：用于存储已被虚拟机加载的类元信息、常量、静态变量、即时编译后的代码等数据。</li>
</ul>
<p><img alt="image-20200610124342656" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfn3exp8l0j30he09uwfo.jpg" class="lazyload"></p>
<h4 id="Java-虚拟机栈会出现两种错误："><a href="#Java-虚拟机栈会出现两种错误：" class="headerlink" title="Java 虚拟机栈会出现两种错误："></a>Java 虚拟机栈会出现两种错误：</h4><p>StackOverFlowError 和 OutOfMemoryError。</p>
<ul>
<li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<h4 id="虚拟机栈和虚拟机堆区别"><a href="#虚拟机栈和虚拟机堆区别" class="headerlink" title="虚拟机栈和虚拟机堆区别"></a>虚拟机栈和虚拟机堆区别</h4><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p>
<h3 id="Java文件完整的加载运行过程"><a href="#Java文件完整的加载运行过程" class="headerlink" title="Java文件完整的加载运行过程"></a>Java文件完整的加载运行过程</h3><p>一个简单的学生类 <a href="https://camo.githubusercontent.com/6349bcfb73fc5bbf962fdaab7546c381b828136a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f32393034366137323163323534386530613036383065633562616634656139352d6e65772d696d61676562306234326535652d386532352d343039652d623762392d3635383661333961306238642e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/6349bcfb73fc5bbf962fdaab7546c381b828136a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f32393034366137323163323534386530613036383065633562616634656139352d6e65772d696d61676562306234326535652d386532352d343039652d623762392d3635383661333961306238642e706e67" class="lazyload"></a></p>
<p>一个main方法 <a href="https://camo.githubusercontent.com/6c5bb22ea8dbc90158b3207d8fd602731a14b42a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f61336433346433336561623734663666383734336563663632383037343435632d6e65772d696d61676530383530366139652d353130312d346633302d623062632d3361626263623866313839342e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/6c5bb22ea8dbc90158b3207d8fd602731a14b42a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f61336433346433336561623734663666383734336563663632383037343435632d6e65772d696d61676530383530366139652d353130312d346633302d623062632d3361626263623866313839342e706e67" class="lazyload"></a></p>
<p>执行main方法的步骤如下:</p>
<ol>
<li>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li>
<li>JVM 找到 App 的主程序入口，执行main方法</li>
<li>这个main中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li>
<li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的元信息</strong> 的引用</li>
<li>执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li>
<li>执行sayName()</li>
</ol>
<p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p>
<h3 id="类加载器的流程（加校准解初使卸）"><a href="#类加载器的流程（加校准解初使卸）" class="headerlink" title="类加载器的流程（加校准解初使卸）"></a>类加载器的流程（加校准解初使卸）</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，校验，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li>将class文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li>
</ol>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ol>
<li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li>
<li>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的），但这里只是赋值为int a=0，即根据数据类型符默认值。</li>
<li>解析：虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化其实就是一个赋值的操作，它会执行一个类构造器的<clinit>()方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3</clinit></p>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>GC将无用对象从内存中卸载</p>
<h3 id="类加载器的加载顺序"><a href="#类加载器的加载顺序" class="headerlink" title="类加载器的加载顺序"></a>类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p>
<ol>
<li>启动类加载器：BootStrap ClassLoader：rt.jar</li>
<li>拓展类加载器：Extention ClassLoader: 加载扩展的jar包</li>
<li>应用类加载器：App ClassLoader：指定的classpath下面的jar包</li>
<li>自定义类加载器：Custom ClassLoader</li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载</p>
<p>这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p>
<p>其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码。</p>
<h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Java类加载机制的强大之处在于，我们可以创建自定义的ClassLoader，自定义ClassLoader是Tomcat实现应用隔离、支持JSP，OSGI实现动态模块化的基础。 </p>
<p>怎么自定义呢？一般而言，继承类ClassLoader，重写findClass就可以了。怎么实现findClass呢？使用自己的逻辑寻找class文件字节码的字节形式，找到后，使用如下方法转换为Class对象：</p>
<p>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</p>
<p>name表示类名，b是存放字节码数据的字节数组，有效数据从off开始，长度为len。</p>
<p>看个例子：</p>
<pre><code class="java">    public class MyClassLoader extends ClassLoader {
    private static final String BASE_DIR = &quot;data/c87/&quot;;
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        String fileName = name.replaceAll(&quot;\\.&quot;, &quot;/&quot;);
        fileName = BASE_DIR + fileName + &quot;.class&quot;;
        try {
            byte[] bytes = BinaryFileUtils.readFileToByteArray(fileName);
            return defineClass(name, bytes, 0, bytes.length);
        } catch (IOException ex) {
            throw new ClassNotFoundException(&quot;failed to load class &quot; + name, ex);
        }
    }
}</code></pre>
<p>MyClassLoader从BASE_DIR下的路径中加载类，转换为byte数组。MyClassLoader没有指定父ClassLoader，默认是系统类加载器，即ClassLoader.getSystemClassLoader()的返回值，不过，ClassLoader有一个可重写的构造方法，可以指定父ClassLoader：protected ClassLoader(ClassLoader parent) </p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>这到底有什么用呢？</p>
<ul>
<li>可以实现<code>隔离</code>，一个复杂的程序，内部可能按模块组织，不同模块可能使用同一个类，但使用的是不同版本，如果使用同一个类加载器，它们是无法共存的，不同模块使用不同的类加载器就可以实现隔离，Tomcat使用它隔离不同的Web应用，OSGI使用它隔离不同模块。</li>
<li>可以实现<code>热部署</code>，使用同一个ClassLoader，类只会被加载一次，加载后，即使class文件已经变了，再次加载，得到的也还是原来的Class对象，而使用MyClassLoader，则可以先创建一个新的ClassLoader，再用它加载Class，得到的Class对象就是新的，从而实现动态更新。</li>
</ul>
<h2 id="虚拟机堆"><a href="#虚拟机堆" class="headerlink" title="虚拟机堆"></a>虚拟机堆</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img alt="image-20200812110120377" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghnuhus4w6j316h0kh446.jpg" class="lazyload"></p>
<p>​        JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，默认比例是1:2，而非堆内存则为<strong>永久代</strong>（）。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。</p>
<h3 id="垃圾回收的过程"><a href="#垃圾回收的过程" class="headerlink" title="垃圾回收的过程"></a>垃圾回收的过程</h3><ol>
<li><p>当我们new一个对象后，会先放到<strong>Eden</strong>划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会<strong>预先申请</strong>好一块连续的内存空间并规定了对象存放的位置。</p>
</li>
<li><p>当Eden空间满了之后，会触发一个叫做<code>Minor GC</code>（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 <code>Minor GC</code>，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。</p>
</li>
<li><p>经过多次的 Minor GC后仍然存活的对象（<strong>这里的存活判断是15次，对应虚拟机参数XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15</strong>）会移动到老年代。</p>
</li>
<li><p>老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p>
</li>
<li><p>当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是<strong>堆内存设置的大小过小</strong>，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的<strong>对象大且多</strong>，而且它们一直在<strong>被引用</strong>从而长时间垃圾收集无法收集它们。JVM默认使用系统内存的1/4。</p>
</li>
</ol>
<p><a href="https://camo.githubusercontent.com/3c6ec61a270148e9f2bea602bce6998d8aa31bde/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f63303265636261336333336634333432396137363539383762393238653432332d6e65772d696d61676539336234366633642d333366392d343666392d613832352d6563373132396230303466362e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/3c6ec61a270148e9f2bea602bce6998d8aa31bde/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f63303265636261336333336634333432396137363539383762393238653432332d6e65772d696d61676539336234366633642d333366392d343666392d613832352d6563373132396230303466362e706e67" class="lazyload"></a></p>
<h3 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a>动态年龄判断</h3><p>​        一句话：当某年龄在survivor区占比超过预设值时，大于等于该年龄的对象会直接进行老年代，无需等到MaxTenuringThreshold中要求的15。</p>
<p>​        设定的参数为：-XX:TargetSurvivorRatio</p>
<h3 id="如何判断一个对象需要被干掉"><a href="#如何判断一个对象需要被干掉" class="headerlink" title="如何判断一个对象需要被干掉"></a>如何判断一个对象需要被干掉</h3><p><a href="https://camo.githubusercontent.com/29dbca08b9255c2e71c234dcf599ed0d93e90c81/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f31633164383562356662386234373233396166326135633034333665623264372d6e65772d696d61676530636431303832372d326639362d343333632d396231362d3933643466653439316438382e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/29dbca08b9255c2e71c234dcf599ed0d93e90c81/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f31633164383562356662386234373233396166326135633034333665623264372d6e65772d696d61676530636431303832372d326639362d343333632d396231362d3933643466653439316438382e706e67" class="lazyload"></a></p>
<p>​        程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p>
<p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法：</p>
<p>1.<code>引用计数器</code>：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</p>
<p>2.<code>可达性分析</code>：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。</p>
<p><code>能作为GC Roots的对象分为以下几种：</code></p>
<ol>
<li>虚拟机栈中引用的对象（局部变量）</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中静态变量所引用的对象和常量引用的对象（静态变量）</li>
</ol>
<p>这种方法的优点是能够解决<strong>循环引用</strong>的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p>
<h3 id="如何宣告一个对象的真正死亡"><a href="#如何宣告一个对象的真正死亡" class="headerlink" title="如何宣告一个对象的真正死亡"></a>如何宣告一个对象的真正死亡</h3><p>判断一个对象的死亡至少需要两次标记</p>
<ol>
<li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否重写了finalize()方法。如果对象重写了finalize()方法，则被放入F-Queue队列中。</li>
<li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li>
</ol>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p><img alt="image-20200610210559246" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfnhxjqulej30j607sdjv.jpg" class="lazyload"></p>
<p>例如：</p>
<p>开启逃逸分析后test2中的user对象，直接在栈内存中创建，当方法完成后直接被垃圾回收。jdk7以后默认开启逃逸分析。</p>
<p><img alt="image-20200610210625390" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfnhy0h9yyj309m09yzlk.jpg" class="lazyload"></p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>常用的有标记清除，复制，标记整理和分代收集算法</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>Hotspot JVM把年轻代分为了三部分:1个Eden区和2个 Survivor区(分别叫from和to),默认比例为8:1:1,一般情况下 新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次 Minor gc后,如果仍然存活,将会被移到 Survivor区。对象在 Survivor区中每熬过一次 Minor gc,年齡就会增加1岁,当它的年齡(15默认)增加到一定程度时,就会被移动到 年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上),所以在<strong>年轻代的垃圾回收算法使用的是复制算法</strong>,复制算法的基本思想就是将内存分为两块,每次只用其中一块,当这一块内存用完,就将还活着的对象复制到另外一块上面。</p>
<p><code>好处</code>：复制算法不会产生内存碎片，对象完整不会丢。</p>
<p><code>缺点</code>：浪费了10%空间。</p>
<p><a href="https://camo.githubusercontent.com/532263eb835a296a059c16f25be1a2b2b4b23893/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66633334396662623962323034343935613533323166656265323738313864342d6e65772d696d61676534353932306139612d353532632d343635362d393464362d6533636134356666396237362e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/532263eb835a296a059c16f25be1a2b2b4b23893/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66633334396662623962323034343935613533323166656265323738313864342d6e65772d696d61676534353932306139612d353532632d343635362d393464362d6533636134356666396237362e706e67" class="lazyload"></a></p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记清除算法就是分为“标记”和“清除”两个阶段。<strong>标记出所有需要回收的对象，标记结束后统一回收</strong>。</p>
<p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p>
<p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p>
<p><a href="https://camo.githubusercontent.com/f54d91118e4ffbd266bf7be3b7149881cb0a63fc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f30313630356439366438356634646161623962666135653730303066306433312d6e65772d696d61676537386530336238352d666265662d346466392d623431652d3262363364373864313139662e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/f54d91118e4ffbd266bf7be3b7149881cb0a63fc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f30313630356439366438356634646161623962666135653730303066306433312d6e65772d696d61676537386530336238352d666265662d346466392d623431652d3262363364373864313139662e706e67" class="lazyload"></a></p>
<p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p>标记整理算法唯一的<code>缺点</code>就是效率也不髙,不仅要<strong>标记所有存活对象,还要整理所有存活对象的引用地址</strong>。从效率上来说,标记整理算法要低于复制算法。</p>
<p><a href="https://camo.githubusercontent.com/24d3da571e399084768678257c97c1ecefadac06/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f32353939653966373232303734643334613366376664396630303736663132312d6e65772d696d61676563373631393265632d623633612d343365332d613664362d6366303166373439393533662e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/24d3da571e399084768678257c97c1ecefadac06/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f32353939653966373232303734643334613366376664396630303736663132312d6e65772d696d61676563373631393265632d623633612d343365332d613664362d6366303166373439393533662e706e67" class="lazyload"></a></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>HotSpot VM中的垃圾回收器，以及适用场景 <a href="https://camo.githubusercontent.com/e5b0e914fca887cfb0906a3a73b30a60d8fa984b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f31316539646364306631656534663235383336653666316334373130346335312d6e65772d696d61676536396531633536612d316434302d343933612d393930312d3665666336343761303166332e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/e5b0e914fca887cfb0906a3a73b30a60d8fa984b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f31316539646364306631656534663235383336653666316334373130346335312d6e65772d696d61676536396531633536612d316434302d343933612d393930312d3665666336343761303166332e706e67" class="lazyload"></a></p>
<p>串行：Serial（新生代） ，Serial Old（老年代），适用于单CPU的Client模式</p>
<p>并行：Parallel Scavenge （新生代）和 Parallel Old（老年代），侧重于吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间））优先，是jdk8默认的垃圾收集器，所以更适合做后台运算等不需要太多用户交互的任务。Parallel Old使用多线程和标记整理法</p>
<p>并行：ParNew（新生代）和CMS（老年代），侧重于响应速度优先。</p>
<p><code>ParNew：</code></p>
<p>多线程版的 Serial。多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，<strong>只有它能与 CMS 收集器配合工作</strong>。</p>
<h2 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h2><p>关注点是获得最短的回收停顿时间，用的是“标记-清除”算法，它运作过程分为四个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）- Stop The World，标记GC_ROOT根节点及其子节点，时间短</li>
<li>并发标记（CMS concurrent mark），标记第一步接下来的节点。</li>
<li>重新标记（CMS remark）- Stop The World：补充标记前两步后新生成的节点。</li>
<li>并发清除（CMS concurrent sweep），</li>
</ul>
<p>其中并发标记、并发清除时间是相对较长的，都是可以和用户线程并发执行的，所以Stop The World时间是很短的，总体上来看就是并发执行的，这对要求响应速度较快的应用场景比较适合。</p>
<p><code>CMS缺点：</code></p>
<ul>
<li>对CPU资源敏感，抢占CPU资源将导致用户线程的CPU资源减少而变得缓慢；</li>
<li>无法处理浮动垃圾，在并发回收垃圾时，用户线程会产生新的垃圾对象，这些垃圾要等下次回收；</li>
<li>由于在并发回收的过程用户线程还在工作，这就需要预留一定的内存空间给用户线程，导致内存空间利用率下降；然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 <strong>Concurrent Mode Failure</strong> 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。</li>
<li>CMS采用的是标记-清除算法，这就导致内存碎片化。若出现内存空间还很多，但由于碎片化的情况，无法满足大对象的分配，当顶不住要触发Full GC时开启内存碎片合并整理过程，这个过程是不能并发的，会Stop The World。</li>
</ul>
<p>到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old</p>
<p>从jdk9开始，G1收集器成为默认的垃圾收集器 目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。</p>
<p><img alt="image-20200611140259211" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfobbsd03zj30hj0eygmu.jpg" class="lazyload"></p>
<h2 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h2><p>​        通过引入 <code>Region</code> 的概念，从而将原来的整块堆内存空间划分成2048个的小空间，使得每个小空间可以单独进行垃圾回收。每块可作为Eden、Survivor、Old、Humongous中的一种。</p>
<p>​        这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>​        每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用来记录该 <code>Region</code> 对象的引用对象所在的 <code>Region</code>。在做可达性分析的时候就可以避免全堆扫描。</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong>：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中。这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收</strong>：首先对各个 <code>Region</code> 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p><code>优点</code>：</p>
<ul>
<li>空间整理，与<strong>CMS</strong>的<strong>标记-清理</strong>相比，它采用的是<strong>标记-整理</strong>，从局部Region来看又是<strong>复制算法</strong>；另外CMS在回收阶段将标记的垃圾全部回收，但G1根据设定参数，排序后，只回收优先级高的垃圾，缩短了垃圾回收的时间，保证了响应速度。</li>
<li>可预测停顿，可以让使用这指定在长度为M毫秒的是时间内，垃圾收集时间不能超过N毫秒；</li>
<li>年轻代初始赋值5%的内存空间，如果达到此空间，但还没达到设置的GC时间，就会动态增加年轻代的Region。</li>
</ul>
<p><img alt="image-20200610154046331" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggq7zvne60j30g8059tao.jpg" class="lazyload"></p>
<p>当一个对象大于Region大小的50%，称为巨型对象；它就会独占一个或多个Region，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区-Humongous Region</p>
<h2 id="JVM的常用参数"><a href="#JVM的常用参数" class="headerlink" title="JVM的常用参数"></a>JVM的常用参数</h2><h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3><p><code>-Xms</code></p>
<p>初始大小内存，默认为物理内存 1/64</p>
<p>等价于 -XX:InitialHeapSize</p>
<p><code>-Xmx</code></p>
<p>最大分配内存，默认为物理内存的 1/4</p>
<p>等价于 -XX:MaxHeapSize</p>
<p><strong>-Xms和-Xmx最好一致，以避免每次垃圾回收完成后JVM重新分配内存。</strong></p>
<p><code>-XX:SurvivorRatio</code></p>
<p>设置新生代中 eden 和 S0/S1 空间比例</p>
<p>默认 -XX:SurvivorRatio=8，Eden : S0 : S1 = 8 : 1 : 1</p>
<p><code>-XX:NewRatio</code></p>
<p>配置年轻代和老年代在堆结构的占比</p>
<p>默认 -XX:NewRatio=2 新生代占1，老年代占2，年轻代占整个堆的 1/3</p>
<p><code>-Xss</code></p>
<p>设置单个线程栈的大小，一般默认为 512-1024k</p>
<p>等价于 -XX:ThreadStackSize</p>
<p>在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
<p><code>-XX:MetaspaceSize</code></p>
<p>设置元空间大小（元空间的本质和永久代类似，都是对 JVM 规范中的方法区的实现，不过元空间于永久代之间最大区别在于，元空间并不在虚拟中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地内存限制）</p>
<p>元空间默认比较小，我们可以调大一点</p>
<p><code>-XX:MaxTenuringThreshold</code></p>
<p>设置垃圾最大年龄</p>
<p><code>-XX:+PrintGCDetails</code></p>
<p>输出详细 GC 收集日志信息 </p>
<p><img alt="image-20200812112340234" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghnv54e8gaj30ks01ywh6.jpg" class="lazyload"></p>
<h3 id="G1-GC的参数选项"><a href="#G1-GC的参数选项" class="headerlink" title="G1 GC的参数选项"></a>G1 GC的参数选项</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseG1GC</td>
<td>==使用G1收集器==</td>
<td>JDK1.8中还需要显式指定</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis=n</td>
<td>设置一个==期望的最大GC暂停时间==，这是一个柔性的目标，JVM会尽力去达到这个目标</td>
<td>200</td>
</tr>
<tr>
<td>-XX:InitiatingHeapOccupancyPercent=n</td>
<td>当整个堆的空间使用百分比超过这个值时，就会触发一次并发收集周期，记住是整个堆</td>
<td>45</td>
</tr>
<tr>
<td>-XX:NewRatio=n</td>
<td>新生代和老年代的比例</td>
<td>2</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=n</td>
<td>Eden空间和Survivor空间的比例</td>
<td>8</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=n</td>
<td>对象在新生代中经历的最多的新生代收集，或者说最大的岁数</td>
<td>G1中是15</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads=n</td>
<td>设置垃圾收集器的并行阶段的垃圾收集线程数</td>
<td>不同的平台有不同的值</td>
</tr>
<tr>
<td>-XX:ConcGCThreads=n</td>
<td>设置垃圾收集器并发执行GC的线程数</td>
<td>n一般是ParallelGCThreads的四分之一</td>
</tr>
<tr>
<td>-XX:G1ReservePercent=n</td>
<td>设置作为==空闲空间的预留内存百分比==，以降低目标空间溢出（疏散失败）的风险。默认值是 10%。增加或减少这个值，请确保对总的 Java 堆调整相同的量</td>
<td>10</td>
</tr>
<tr>
<td>-XX:G1HeapRegionSize=n</td>
<td>分区的大小</td>
<td>堆内存大小的1/2000，单位是MB，值是2的幂，范围是1MB到32MB之间</td>
</tr>
<tr>
<td>-XX:G1HeapWastePercent=n</td>
<td>设置您愿意浪费的堆百分比。如果可回收百分比小于堆废物百分比，JavaHotSpotVM不会启动混合垃圾回收周期（注意，这个参数可以用于调整混合收集的频率）。</td>
<td>JDK1.8是5</td>
</tr>
<tr>
<td>-XX:G1MixedGCCountTarget=8</td>
<td>设置并发周期后需要执行多少次混合收集，如果混合收集中STW的时间过长，可以考虑增大这个参数。（注意：这个可以用来调整每次混合收集中回收掉老年代分区的多少，即调节混合收集的停顿时间）</td>
<td>8</td>
</tr>
<tr>
<td>-XX:G1MixedGCLiveThresholdPercent=n</td>
<td>一个分区是否会被放入mix GC的CSet的阈值。对于一个分区来说，它的存活对象率如果超过这个比例，则改分区不会被列入mixed gc的CSet中</td>
<td>JDK1.6和1.7是65，JDK1.8是85</td>
</tr>
</tbody></table>
<h2 id="关于JVM调优的一些方面"><a href="#关于JVM调优的一些方面" class="headerlink" title="关于JVM调优的一些方面"></a>关于JVM调优的一些方面</h2><p>我们可以尝试对JVM进行调优，主要就是堆内存那块</p>
<h3 id="调整最大堆内存和最小堆内存"><a href="#调整最大堆内存和最小堆内存" class="headerlink" title="调整最大堆内存和最小堆内存"></a>调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB))</p>
<p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p>
<p>开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p>
<p>我们执行下面的代码</p>
<pre><code class="java">System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);    //系统的最大空间
System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间
System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);  //当前可用的总空间</code></pre>
<p>注意：此处设置的是Java堆大小，也就是新生代大小 + 老年代大小 <a href="https://camo.githubusercontent.com/9a9d237967393ea65368245aacc26b93eb787f84/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f35653762333532633136643734633738396336363561663436643361323530392d6e65772d696d61676564643634356461652d333037642d343537322d623665322d6235613939323561343663642e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/9a9d237967393ea65368245aacc26b93eb787f84/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f35653762333532633136643734633738396336363561663436643361323530392d6e65772d696d61676564643634356461652d333037642d343537322d623665322d6235613939323561343663642e706e67" class="lazyload"></a></p>
<p>设置一个VM options的参数</p>
<pre><code>-Xmx20m -Xms5m -XX:+PrintGCDetails</code></pre><p><a href="https://camo.githubusercontent.com/caf41e27bf203a1281f20969d94cd790258a6a12/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66653939653335356634373534666134626537343237636236353236316633642d6e65772d696d61676562623563663438352d393966382d343365622d383830392d3261383965366131373638652e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/caf41e27bf203a1281f20969d94cd790258a6a12/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f66653939653335356634373534666134626537343237636236353236316633642d6e65772d696d61676562623563663438352d393966382d343365622d383830392d3261383965366131373638652e706e67" class="lazyload"></a></p>
<p>再次启动main方法</p>
<p><a href="https://camo.githubusercontent.com/b536da4f44b4b683f323afb045009f734095da49/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f33303035333966363536303034336464386133666530383564323834323065362d6e65772d696d61676533633538316132652d313936662d346230312d393066312d6332373733316234363130622e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/b536da4f44b4b683f323afb045009f734095da49/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f33303035333966363536303034336464386133666530383564323834323065362d6e65772d696d61676533633538316132652d313936662d346230312d393066312d6332373733316234363130622e706e67" class="lazyload"></a> 这里GC弹出了一个Allocation Failure分配失败，这个事情发生在PSYoungGen，也就是年轻代中</p>
<p>这时候申请到的内存为18M，空闲内存为4.214195251464844M</p>
<p>我们此时创建一个字节数组看看，执行下面的代码</p>
<pre><code>byte[] b = new byte[1 * 1024 * 1024];
System.out.println(&quot;分配了1M空间给数组&quot;);
System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的最大空间
System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间
System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);</code></pre><p><a href="https://camo.githubusercontent.com/1225930990b2cf980c6acf943d630d1cdbd82798/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f62646437313764306133333934626537613733333736303035323737333337342d6e65772d696d61676533373162356435392d303032302d343039312d393837342d3630336330616230303733642e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/1225930990b2cf980c6acf943d630d1cdbd82798/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f62646437313764306133333934626537613733333736303035323737333337342d6e65772d696d61676533373162356435392d303032302d343039312d393837342d3630336330616230303733642e706e67" class="lazyload"></a></p>
<p>此时free memory就又缩水了，不过total memory是没有变化的。Java会尽可能将total mem的值维持在最小堆内存大小</p>
<pre><code>byte[] b = new byte[10 * 1024 * 1024];
System.out.println(&quot;分配了10M空间给数组&quot;);
System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的最大空间
System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间
System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);  //当前可用的总空间</code></pre><p><a href="https://camo.githubusercontent.com/1eea5da0254d2ebc0dc1af43082a0f4ae47bd0bc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f30666437353530616532313434616463613865643265646531326435666239362d6e65772d696d61676530633331666632302d323839642d343038382d386336372d6138343664306335643165302e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/1eea5da0254d2ebc0dc1af43082a0f4ae47bd0bc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f30666437353530616532313434616463613865643265646531326435666239362d6e65772d696d61676530633331666632302d323839642d343038382d386336372d6138343664306335643165302e706e67" class="lazyload"></a></p>
<p>这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total memory已经变成了15M，这就是已经申请了一次内存的结果。</p>
<p>此时我们再跑一下这个代码</p>
<pre><code>System.gc();
System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);    //系统的最大空间
System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间
System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);  //当前可用的总空间</code></pre><p><a href="https://camo.githubusercontent.com/279fdb13bff8b2970b9977f93091f2389c957a25/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f34636334346235643564316334306334383634306563653661323936623161632d6e65772d696d61676534623537626166362d303835622d343135302d396336302d6163353162306638313564372e706e67" target="_blank" rel="noopener"><img alt="img" data-src="https://camo.githubusercontent.com/279fdb13bff8b2970b9977f93091f2389c957a25/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f34636334346235643564316334306334383634306563653661323936623161632d6e65772d696d61676534623537626166362d303835622d343135302d396336302d6163353162306638313564372e706e67" class="lazyload"></a></p>
<p>此时我们手动执行了一次fullgc，此时total memory的内存空间又变回5.5M了，此时又是把申请的内存释放掉的结果。</p>
<h3 id="调整新生代和老年代的比值"><a href="#调整新生代和老年代的比值" class="headerlink" title="调整新生代和老年代的比值"></a>调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p>
<p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p>
<h3 id="调整Survivor区和Eden区的比值"><a href="#调整Survivor区和Eden区的比值" class="headerlink" title="调整Survivor区和Eden区的比值"></a>调整Survivor区和Eden区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个Survivor区和eden的比值</p>
<p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p>
<h3 id="设置年轻代和老年代的大小"><a href="#设置年轻代和老年代的大小" class="headerlink" title="设置年轻代和老年代的大小"></a>设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p>
<p>-XX:MaxNewSize — 设置年轻代最大值</p>
<p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10</p>
<p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。</p>
<pre><code>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</code></pre><p>一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p>
<h3 id="永久区的设置"><a href="#永久区的设置" class="headerlink" title="永久区的设置"></a>永久区的设置</h3><pre><code>-XX:PermSize -XX:MaxPermSize</code></pre><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p>
<p>tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。</p>
<h3 id="JVM的栈参数调优"><a href="#JVM的栈参数调优" class="headerlink" title="JVM的栈参数调优"></a>JVM的栈参数调优</h3><h4 id="调整每个线程栈空间的大小"><a href="#调整每个线程栈空间的大小" class="headerlink" title="调整每个线程栈空间的大小"></a>调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p>
<p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p>
<h4 id="设置线程栈的大小"><a href="#设置线程栈的大小" class="headerlink" title="设置线程栈的大小"></a>设置线程栈的大小</h4><pre><code>-XXThreadStackSize：
    设置线程栈的大小(0 means use default stack size)</code></pre><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了</p>
<h3 id="JVM其他参数介绍"><a href="#JVM其他参数介绍" class="headerlink" title="JVM其他参数介绍"></a>JVM其他参数介绍</h3><p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p>
<h4 id="设置垃圾最大年龄"><a href="#设置垃圾最大年龄" class="headerlink" title="设置垃圾最大年龄"></a>设置垃圾最大年龄</h4><pre><code>-XX:MaxTenuringThreshold
    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.
    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,
    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,
    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</code></pre><h4 id="设置堆空间存活时间"><a href="#设置堆空间存活时间" class="headerlink" title="设置堆空间存活时间"></a>设置堆空间存活时间</h4><pre><code>-XX:SoftRefLRUPolicyMSPerMB
    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。</code></pre><h4 id="设置对象直接分配在老年代"><a href="#设置对象直接分配在老年代" class="headerlink" title="设置对象直接分配在老年代"></a>设置对象直接分配在老年代</h4><pre><code>-XX:PretenureSizeThreshold
    设置对象超过多大时直接在老年代分配，默认值是0。</code></pre><h4 id="设置TLAB占eden区的比例"><a href="#设置TLAB占eden区的比例" class="headerlink" title="设置TLAB占eden区的比例"></a>设置TLAB占eden区的比例</h4><pre><code>-XX:TLABWasteTargetPercent
    设置TLAB占eden区的百分比，默认值是1% 。 </code></pre><h4 id="设置是否优先YGC"><a href="#设置是否优先YGC" class="headerlink" title="设置是否优先YGC"></a>设置是否优先YGC</h4><pre><code>-XX:+CollectGen0First
    设置FullGC时是否先YGC，默认值是false。</code></pre></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">简凡丶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/15/6.%20JVM/JVM%E5%9F%BA%E7%A1%80/">http://yoursite.com/2020/07/15/6.%20JVM/JVM%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">BestBear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM    </a></div><div class="post_share"><div class="social-share" data-image="http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/15/6.%20JVM/%E4%B8%80%E6%AC%A1jvm%E9%97%AE%E9%A2%98/"><img class="prev_cover lazyload" data-src="http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>一次jvm问题排查过程</span></div></a></div><div class="next-post pull_right"><a href="/2020/05/19/4.%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><img class="next_cover lazyload" data-src="https://p3.ssl.qhimg.com/bdr/__85/t01b11174e3eca6230a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>消息队列面试总结</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/15/6. JVM/FGC问题排查/" title="线上服务的FGC问题排查"><img class="relatedPosts_cover lazyload"data-src="http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-15</div><div class="relatedPosts_title">线上服务的FGC问题排查</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/15/6. JVM/JVM问题排查/" title="JVM问题排查"><img class="relatedPosts_cover lazyload"data-src="http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-15</div><div class="relatedPosts_title">JVM问题排查</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/15/6. JVM/一次jvm问题/" title="一次jvm问题排查过程"><img class="relatedPosts_cover lazyload"data-src="http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-15</div><div class="relatedPosts_title">一次jvm问题排查过程</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'POlJROSsMvr6BdUPhPaqFdlj-gzGzoHsz',
  appKey:'JhPOeqEkpBUGVUNuYYxRCvUt',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(http://img.netbian.com/file/2020/0712/ccd6fce7874f4f9351ddf67c71ed4536.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 简凡丶</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2d_models/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d_models/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.5,"jsonPath":"/live2d_models/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":200,"position":"right","hOffset":30,"vOffset":20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":0.6,"opacityOnHover":0.2},"log":false});</script></body></html>